public class AgelessEntity extends CardImpl { public AgelessEntity ( UUID ownerId )  { super ( ownerId, 18, "Ageless Entity", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "DDH"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new GainLifeControllerTriggeredAbility ( new AgelessEntityEffect (  ) , false, true )  ) ; } public AgelessEntity ( final AgelessEntity card )  { super ( card ) ; } @Override public AgelessEntity copy (  )  { return new AgelessEntity ( this ) ; } } class AgelessEntityEffect extends OneShotEffect { public AgelessEntityEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "put that many +1/+1 counters on this creature"; } public AgelessEntityEffect ( final AgelessEntityEffect effect )  { super ( effect ) ; } @Override public AgelessEntityEffect copy (  )  { return new AgelessEntityEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int lifeGained =  ( Integer )  this . getValue ( "gainedLife" ) ; if  ( lifeGained > 0 )  { return new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( lifeGained )  )  . apply ( game, source ) ; } return false; } } 
public class AgonizingDemise extends CardImpl { private static final FilterCreaturePermanent filterNonBlackCreature = new FilterCreaturePermanent ( "nonblack creature" ) ; static { filterNonBlackCreature . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public AgonizingDemise ( UUID ownerId )  { super ( ownerId, 66, "Agonizing Demise", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{B}" ) ; this . expansionSetCode = "DDH"; this . addAbility ( new KickerAbility ( "{1}{R}" )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filterNonBlackCreature )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new AgonizingDemiseEffect (  ) , KickedCondition . getInstance (  ) , "If {this} was kicked, it deals damage equal to that creature's power to the creature's controller . " )  ) ; } public AgonizingDemise ( final AgonizingDemise card )  { super ( card ) ; } @Override public AgonizingDemise copy (  )  { return new AgonizingDemise ( this ) ; } } class AgonizingDemiseEffect extends OneShotEffect { public AgonizingDemiseEffect (  )  { super ( Outcome . Damage ) ; } public AgonizingDemiseEffect ( final AgonizingDemiseEffect effect )  { super ( effect ) ; } @Override public AgonizingDemiseEffect copy (  )  { return new AgonizingDemiseEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanentOrLKIBattlefield ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if ( permanent != null )  { Player controller = game . getPlayer ( permanent . getControllerId (  )  ) ; if ( controller != null )  { int amount = permanent . getPower (  )  . getValue (  ) ; controller . damage ( amount, source . getSourceId (  ) , game, false, true ) ; return true; } } return false; } } 
public class OgreSavant extends CardImpl { public OgreSavant ( UUID ownerId )  { super ( ownerId, 55, "Ogre Savant", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "DDH"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new ReturnToHandTargetEffect (  ) ,false ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, new ManaWasSpentCondition ( ColoredManaSymbol . U ) , "if {U} was spent to cast {this}, return target creature to its owner's hand . " ) , new ManaSpentToCastWatcher (  )  ) ; } public OgreSavant ( final OgreSavant card )  { super ( card ) ; } @Override public OgreSavant copy (  )  { return new OgreSavant ( this ) ; } } 
public class Anathemancer extends CardImpl { public Anathemancer ( UUID ownerId )  { super ( ownerId, 33, "Anathemancer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new DamageTargetEffect ( new AnathemancerCount (  )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new UnearthAbility ( new ManaCostsImpl ( "{5}{B}{R}" )  )  ) ; } public Anathemancer ( final Anathemancer card )  { super ( card ) ; } @Override public Anathemancer copy (  )  { return new Anathemancer ( this ) ; } } class AnathemancerCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { if  ( sourceAbility . getFirstTarget (  )  == null )  { return 0; } FilterLandPermanent filter = new FilterLandPermanent (  ) ; filter . add ( Predicates . not ( new SupertypePredicate ( "Basic" )  )  ) ; filter . add ( new ControllerIdPredicate ( sourceAbility . getFirstTarget (  )  )  ) ; return game . getBattlefield (  )  . count ( filter, sourceAbility . getSourceId (  ) , sourceAbility . getControllerId (  ) , game ) ; } @Override public DynamicValue copy (  )  { return new AnathemancerCount (  ) ; } @Override public String toString (  )  { return "1"; } @Override public String getMessage (  )  { return "nonbasic lands that player controls"; } } 
public class ArchitectsOfWill extends CardImpl { public ArchitectsOfWill ( UUID ownerId )  { super ( ownerId, 17, "Architects of Will", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new ArchitectsOfWillEffect (  ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{U/B}" )  )  ) ; } public ArchitectsOfWill ( final ArchitectsOfWill card )  { super ( card ) ; } @Override public ArchitectsOfWill copy (  )  { return new ArchitectsOfWill ( this ) ; } } class ArchitectsOfWillEffect extends OneShotEffect { public ArchitectsOfWillEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "look at the top three cards of target player's library, then put them back in any order"; } public ArchitectsOfWillEffect ( final ArchitectsOfWillEffect effect )  { super ( effect ) ; } @Override public ArchitectsOfWillEffect copy (  )  { return new ArchitectsOfWillEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer == null || controller == null )  { return false; } Cards cards = new CardsImpl (  ) ; int count = Math . min ( targetPlayer . getLibrary (  )  . size (  ) , 3 ) ; for  ( int i = 0; i < count; i++ )  { Card card = targetPlayer . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { cards . add ( card ) ; } } controller . lookAtCards ( "Architects of Will", cards, game ) ; controller . putCardsOnTopOfLibrary ( cards, game, source, true ) ; return true; } } 
public class ArdentPlea extends CardImpl { public ArdentPlea  ( UUID ownerId )  { super ( ownerId, 1, "Ardent Plea", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new ExaltedAbility (  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public ArdentPlea  ( final ArdentPlea card )  { super ( card ) ; } @Override public ArdentPlea copy (  )  { return new ArdentPlea ( this ) ; } } 
public class ArsenalThresher extends CardImpl { public ArsenalThresher ( UUID ownerId )  { super ( ownerId, 131, "Arsenal Thresher", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}{W/B}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Construct" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new ArsenalThresherEffect (  ) , "you may reveal any number of other artifact cards from your hand .  {this} enters the battlefield with a +1/+1 counter on it for each card revealed this way" )  ) ; } public ArsenalThresher ( final ArsenalThresher card )  { super ( card ) ; } @Override public ArsenalThresher copy (  )  { return new ArsenalThresher ( this ) ; } } class ArsenalThresherEffect extends OneShotEffect { public ArsenalThresherEffect (  )  { super ( Outcome . Benefit ) ; } public ArsenalThresherEffect ( final ArsenalThresherEffect effect )  { super ( effect ) ; } @Override public ArsenalThresherEffect copy (  )  { return new ArsenalThresherEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } Permanent arsenalThresher = game . getPermanentEntering ( source . getSourceId (  )  ) ; FilterArtifactCard filter = new FilterArtifactCard (  ) ; filter . add ( new AnotherCardPredicate (  )  ) ; if  ( controller . chooseUse ( Outcome . Benefit, "Do you want to reveal other artifacts in your hand?", source, game )  )  { Cards cards = new CardsImpl (  ) ; if  ( controller . getHand (  )  . count ( filter, source . getSourceId (  ) , source . getControllerId (  ) , game )  > 0 )  { TargetCardInHand target = new TargetCardInHand ( 0, Integer . MAX_VALUE, filter ) ; if  ( controller . choose ( Outcome . Benefit, target, source . getSourceId (  ) , game )  )  { for  ( UUID uuid : target . getTargets (  )  )  { cards . add ( controller . getHand (  )  . get ( uuid, game )  ) ; } if  ( arsenalThresher != null )  { controller . revealCards ( arsenalThresher . getIdName (  ) , cards, game ) ; arsenalThresher . addCounters ( CounterType . P1P1 . createInstance ( cards . size (  )  ) , game ) ; } } } return true; } return false; } } 
public class AvenMimeomancer extends CardImpl { public AvenMimeomancer ( UUID ownerId )  { super ( ownerId, 2, "Aven Mimeomancer", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new AddCountersTargetEffect ( CounterType . FEATHER . createInstance (  )  ) , TargetController . YOU, true ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; ability . addEffect ( new AvenEffect (  )  ) ; ability . addEffect ( new AvenEffect2 (  )  ) ; this . addAbility ( ability ) ; } public AvenMimeomancer ( final AvenMimeomancer card )  { super ( card ) ; } @Override public AvenMimeomancer copy (  )  { return new AvenMimeomancer ( this ) ; } } class AvenEffect extends ContinuousEffectImpl { public AvenEffect (  )  { super ( Duration . Custom, Layer . PTChangingEffects_7, SubLayer . SetPT_7b, Outcome . BoostCreature ) ; } public AvenEffect ( final AvenEffect effect )  { super ( effect ) ; } @Override public AvenEffect copy (  )  { return new AvenEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent target = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( target != null )  { target . getPower (  )  . setValue ( 3 ) ; target . getToughness (  )  . setValue ( 1 ) ; return true; } return false; } @Override public boolean isInactive ( Ability source, Game game )  { Permanent creature = game . getPermanent ( this . targetPointer . getFirst ( game, source )  ) ; if  ( creature != null && creature . getCounters (  )  . getCount ( CounterType . FEATHER )  < 1 )  { return true; } return false; } @Override public String getText ( Mode mode )  { StringBuilder sb = new StringBuilder (  ) ; sb . append ( "If you do, that creature has base power and toughness 3/1 and has flying for as long as it has a feather counter on it" ) ; return sb . toString (  ) ; } } class AvenEffect2 extends ContinuousEffectImpl { public AvenEffect2 (  )  { super ( Duration . Custom, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . BoostCreature ) ; } public AvenEffect2 ( final AvenEffect2 effect )  { super ( effect ) ; } @Override public AvenEffect2 copy (  )  { return new AvenEffect2 ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent target = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( target != null )  { if  ( !target . getAbilities (  )  . contains ( FlyingAbility . getInstance (  )  )  )  { target . addAbility ( FlyingAbility . getInstance (  ) , source . getSourceId (  ) , game ) ; return true; } } return false; } @Override public boolean isInactive ( Ability source, Game game )  { Permanent creature = game . getPermanent ( this . targetPointer . getFirst ( game, source )  ) ; if  ( creature != null && creature . getCounters (  )  . getCount ( CounterType . FEATHER )  < 1 )  { return true; } return false; } } 
public class BantSojourners extends CardImpl { public BantSojourners ( UUID ownerId )  { super ( ownerId, 125, "Bant Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability1 = new CycleTriggeredAbility ( new CreateTokenEffect ( new SoldierToken (  )  ) , true ) ; Ability ability2 = new DiesTriggeredAbility ( new CreateTokenEffect ( new SoldierToken (  )  ) , true ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{W}" )  )  ) ; } public BantSojourners ( final BantSojourners card )  { super ( card ) ; } @Override public BantSojourners copy (  )  { return new BantSojourners ( this ) ; } } 
public class BantSureblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public BantSureblade ( UUID ownerId )  { super ( ownerId, 143, "Bant Sureblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G/U}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( FirstStrikeAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has first strike" )  ) ; this . addAbility ( ability ) ; } public BantSureblade ( final BantSureblade card )  { super ( card ) ; } @Override public BantSureblade copy (  )  { return new BantSureblade ( this ) ; } } 
public class BehemothSledge extends CardImpl { public BehemothSledge ( UUID ownerId )  { super ( ownerId, 65, "Behemoth Sledge", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 2, 2 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( LifelinkAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( TrampleAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 3 )  )  ) ; } protected BehemothSledge ( BehemothSledge me )  { super ( me ) ; } @Override public BehemothSledge copy (  )  { return new BehemothSledge ( this ) ; } } 
public class BituminousBlast extends CardImpl { public BituminousBlast ( UUID ownerId )  { super ( ownerId, 34, "Bituminous Blast", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 4 )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public BituminousBlast ( final BituminousBlast card )  { super ( card ) ; } @Override public BituminousBlast copy (  )  { return new BituminousBlast ( this ) ; } } 
public class BlitzHellion extends CardImpl { public BlitzHellion ( UUID ownerId )  { super ( ownerId, 49, "Blitz Hellion", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Hellion" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Effect effect = new ShuffleIntoLibrarySourceEffect (  ) ; effect . setText ( "{this}'s owner shuffles it into his or her library . " ) ; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( Zone . BATTLEFIELD, effect, TargetController . ANY, null, false )  ) ; } public BlitzHellion ( final BlitzHellion card )  { super ( card ) ; } @Override public BlitzHellion copy (  )  { return new BlitzHellion ( this ) ; } } 
public class BloodbraidElf extends CardImpl { public BloodbraidElf ( UUID ownerId )  { super ( ownerId, 50, "Bloodbraid Elf", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public BloodbraidElf ( final BloodbraidElf card )  { super ( card ) ; } @Override public BloodbraidElf copy (  )  { return new BloodbraidElf ( this ) ; } } 
public class Brainbite extends CardImpl { public Brainbite ( UUID ownerId )  { super ( ownerId, 18, "Brainbite", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DiscardCardYouChooseTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public Brainbite ( final Brainbite card )  { super ( card ) ; } @Override public Brainbite copy (  )  { return new Brainbite ( this ) ; } } 
public class BreathOfMalfegor extends CardImpl { public BreathOfMalfegor ( UUID ownerId )  { super ( ownerId, 35, "Breath of Malfegor", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DamagePlayersEffect ( 5, TargetController . OPPONENT )  ) ; } public BreathOfMalfegor ( final BreathOfMalfegor card )  { super ( card ) ; } @Override public BreathOfMalfegor copy (  )  { return new BreathOfMalfegor ( this ) ; } } 
public class CapturedSunlight extends CardImpl { public CapturedSunlight  ( UUID ownerId )  { super ( ownerId, 66, "Captured Sunlight", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 4 )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public CapturedSunlight  ( final CapturedSunlight card )  { super ( card ) ; } @Override public CapturedSunlight copy (  )  { return new CapturedSunlight ( this ) ; } } 
public class CerodonYearling extends CardImpl { public CerodonYearling ( UUID ownerId )  { super ( ownerId, 96, "Cerodon Yearling", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; } public CerodonYearling ( final CerodonYearling card )  { super ( card ) ; } @Override public CerodonYearling copy (  )  { return new CerodonYearling ( this ) ; } } 
public class Crystallization extends CardImpl { public Crystallization ( UUID ownerId )  { super ( ownerId, 144, "Crystallization", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{G/U}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantAttackBlockAttachedEffect ( AttachmentType . AURA )  )  ) ; this . addAbility ( new CrystallizationTriggeredAbility (  )  ) ; } public Crystallization ( final Crystallization card )  { super ( card ) ; } @Override public Crystallization copy (  )  { return new Crystallization ( this ) ; } } class CrystallizationTriggeredAbility extends TriggeredAbilityImpl { public CrystallizationTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new ExileTargetEffect (  )  ) ; } public CrystallizationTriggeredAbility ( final CrystallizationTriggeredAbility ability )  { super ( ability ) ; } @Override public CrystallizationTriggeredAbility copy (  )  { return new CrystallizationTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TARGETED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent enchantment = game . getPermanent ( sourceId ) ; if  ( enchantment != null && enchantment . getAttachedTo (  )  != null )  { UUID enchanted = enchantment . getAttachedTo (  ) ; if  ( event . getTargetId (  )  . equals ( enchanted )  )  { getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( enchanted )  ) ; return true; } } return false; } @Override public String getRule (  )  { return "When enchanted creature becomes the target of a spell or ability, exile that creature . "; } } 
public class DauntlessEscort extends CardImpl { public DauntlessEscort ( UUID ownerId )  { super ( ownerId, 67, "Dauntless Escort", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rhino" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; FilterPermanent filter = new FilterControlledCreaturePermanent ( "Creatures you control" ) ; Effect effect = new GainAbilityAllEffect ( IndestructibleAbility . getInstance (  ) , Duration . EndOfTurn, filter, false ) ; effect . setText ( "Creatures you control are indestructible this turn" ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new SacrificeSourceCost (  )  )  ) ; } public DauntlessEscort ( final DauntlessEscort card )  { super ( card ) ; } @Override public DauntlessEscort copy (  )  { return new DauntlessEscort ( this ) ; } } 
public class DeadshotMinotaur extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public DeadshotMinotaur ( UUID ownerId )  { super ( ownerId, 52, "Deadshot Minotaur", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Minotaur" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DamageTargetEffect ( 3 ) , false ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{R/G}" )  )  ) ; } public DeadshotMinotaur ( final DeadshotMinotaur card )  { super ( card ) ; } @Override public DeadshotMinotaur copy (  )  { return new DeadshotMinotaur ( this ) ; } } 
public class DeathbringerThoctar extends CardImpl { public DeathbringerThoctar ( UUID ownerId )  { super ( ownerId, 36, "Deathbringer Thoctar", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , true, true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new RemoveCountersSourceCost ( CounterType . P1P1 . createInstance (  )  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public DeathbringerThoctar ( final DeathbringerThoctar card )  { super ( card ) ; } @Override public DeathbringerThoctar copy (  )  { return new DeathbringerThoctar ( this ) ; } } 
public class DefilerOfSouls extends CardImpl { public DefilerOfSouls ( UUID ownerId )  { super ( ownerId, 37, "Defiler of Souls", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{B}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new DefilerOfSoulsEffect (  ) , TargetController . ANY, false, true )  ) ; } public DefilerOfSouls ( final DefilerOfSouls card )  { super ( card ) ; } @Override public DefilerOfSouls copy (  )  { return new DefilerOfSouls ( this ) ; } } class DefilerOfSoulsEffect extends OneShotEffect { DefilerOfSoulsEffect (  )  { super ( Outcome . Sacrifice ) ; staticText = "that player sacrifices a monocolored creature"; } DefilerOfSoulsEffect ( final DefilerOfSoulsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "monocolored creature" ) ; Player player = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( player == null )  { return false; } filter . add ( new MonocoloredPredicate (  )  ) ; int amount; int realCount = game . getBattlefield (  )  . countAll ( filter, player . getId (  ) , game ) ; amount = Math . min ( 1, realCount ) ; Target target = new TargetControlledPermanent ( amount, amount, filter, false ) ; target . setNotTarget ( true ) ; if  ( amount > 0 && target . canChoose ( source . getSourceId (  ) , player . getId (  ) , game )  )  { boolean abilityApplied = false; while  ( player . canRespond (  )  && !target . isChosen (  )  && target . canChoose ( player . getId (  ) , game )  )  { player . choose ( Outcome . Sacrifice, target, source . getSourceId (  ) , game ) ; } for  (  int idx = 0; idx < target . getTargets (  )  . size (  ) ; idx++ )  { Permanent permanent = game . getPermanent (  ( UUID ) target . getTargets (  )  . get ( idx )  ) ; if  (  permanent != null  )  { abilityApplied |= permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } return abilityApplied; } return false; } @Override public DefilerOfSoulsEffect copy (  )  { return new DefilerOfSoulsEffect ( this ) ; } } 
public class DemonicDread extends CardImpl { public DemonicDread ( UUID ownerId )  { super ( ownerId, 38, "Demonic Dread", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new CascadeAbility (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CantBlockTargetEffect ( Duration . EndOfTurn )  ) ; } public DemonicDread ( final DemonicDread card )  { super ( card ) ; } @Override public DemonicDread copy (  )  { return new DemonicDread ( this ) ; } } 
public class DemonspineWhip extends CardImpl { public DemonspineWhip ( UUID ownerId )  { super ( ownerId, 39, "Demonspine Whip", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( new XPaid (  ) , new StaticValue ( 0 ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{X}" )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 1 )  )  ) ; } public DemonspineWhip ( final DemonspineWhip card )  { super ( card ) ; } @Override public DemonspineWhip copy (  )  { return new DemonspineWhip ( this ) ; } } class XPaid implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { int paid = sourceAbility . getManaCostsToPay (  )  . getX (  ) ; return paid; } @Override public DynamicValue copy (  )  { return this; } @Override public String getMessage (  )  { return "X paid"; } @Override public String toString (  )  { return "X"; } } 
public class DenyReality extends CardImpl { public DenyReality  ( UUID ownerId )  { super ( ownerId, 19, "Deny Reality", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public DenyReality  ( final DenyReality card )  { super ( card ) ; } @Override public DenyReality copy (  )  { return new DenyReality ( this ) ; } } 
public class DoubleNegative extends CardImpl { public DoubleNegative ( UUID ownerId )  { super ( ownerId, 87, "Double Negative", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{U}{U}{R}" ) ; this . expansionSetCode = "ARB"; Effect effect = new CounterTargetEffect (  ) ; effect . setText ( "Counter up to two target spells" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( 0, 2, new FilterSpell (  )  )  ) ; } public DoubleNegative ( final DoubleNegative card )  { super ( card ) ; } @Override public DoubleNegative copy (  )  { return new DoubleNegative ( this ) ; } } 
public class DragonAppeasement extends CardImpl { public DragonAppeasement ( UUID ownerId )  { super ( ownerId, 115, "Dragon Appeasement", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SkipDrawStepEffect (  )  )  ) ; this . addAbility ( new DragonAppeasementTriggeredAbility (  )  ) ; } public DragonAppeasement ( final DragonAppeasement card )  { super ( card ) ; } @Override public DragonAppeasement copy (  )  { return new DragonAppeasement ( this ) ; } } class DragonAppeasementTriggeredAbility extends TriggeredAbilityImpl { public DragonAppeasementTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , true ) ; setLeavesTheBattlefieldTrigger ( true ) ; } public DragonAppeasementTriggeredAbility ( final DragonAppeasementTriggeredAbility ability )  { super ( ability ) ; } @Override public DragonAppeasementTriggeredAbility copy (  )  { return new DragonAppeasementTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SACRIFICED_PERMANENT; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { return event . getPlayerId (  )  . equals ( this . getControllerId (  )  )  && game . getLastKnownInformation ( event . getTargetId (  ) , Zone . BATTLEFIELD )  . getCardType (  )  . contains ( CardType . CREATURE ) ; } @Override public String getRule (  )  { return "Whenever you sacrifice a creature, " + super . getRule (  ) ; } } 
public class DragonBroodmother extends CardImpl { public DragonBroodmother ( UUID ownerId )  { super ( ownerId, 53, "Dragon Broodmother", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{R}{R}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new CreateTokenEffect ( new DragonToken (  )  ) , TargetController . ANY, false )  ) ; } public DragonBroodmother ( final DragonBroodmother card )  { super ( card ) ; } @Override public DragonBroodmother copy (  )  { return new DragonBroodmother ( this ) ; } } class DragonToken extends Token { DragonToken (  )  { super ( "Dragon", "1/1 red and green Dragon creature token with flying and devour 2" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; color . setRed ( true ) ; subtype . add ( "Dragon" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; addAbility ( new DevourAbility ( DevourEffect . DevourFactor . Devour2 )  ) ; } } 
public class DrasticRevelation extends CardImpl { public DrasticRevelation ( UUID ownerId )  { super ( ownerId, 111, "Drastic Revelation", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{U}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DrasticRevelationEffect (  )  ) ; } public DrasticRevelation ( final DrasticRevelation card )  { super ( card ) ; } @Override public DrasticRevelation copy (  )  { return new DrasticRevelation ( this ) ; } } class DrasticRevelationEffect extends OneShotEffect { DrasticRevelationEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Discard your hand .  Draw seven cards, then discard three cards at random"; } DrasticRevelationEffect ( final DrasticRevelationEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player you = game . getPlayer ( source . getControllerId (  )  ) ; you . discardToMax ( game ) ; you . drawCards ( 7, game ) ; Cards hand = you . getHand (  ) ; for  ( int i = 0; i < 3; i++ )  { Card card = hand . getRandom ( game ) ; if  ( card != null )  { you . discard ( card, source, game ) ; } } return false; } @Override public DrasticRevelationEffect copy (  )  { return new DrasticRevelationEffect ( this ) ; } } 
public class EnigmaSphinx extends CardImpl { public EnigmaSphinx ( UUID ownerId )  { super ( ownerId, 106, "Enigma Sphinx", Rarity . RARE, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Sphinx" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EnigmaSphinxTriggeredAbility ( new EnigmaSphinxEffect (  )  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public EnigmaSphinx ( final EnigmaSphinx card )  { super ( card ) ; } @Override public EnigmaSphinx copy (  )  { return new EnigmaSphinx ( this ) ; } } class EnigmaSphinxTriggeredAbility extends TriggeredAbilityImpl { public EnigmaSphinxTriggeredAbility ( Effect effect )  { this ( effect, false ) ; } public EnigmaSphinxTriggeredAbility ( Effect effect, boolean optional )  { super ( Zone . ALL, effect, optional ) ; } EnigmaSphinxTriggeredAbility ( EnigmaSphinxTriggeredAbility ability )  { super ( ability ) ; } @Override public EnigmaSphinxTriggeredAbility copy (  )  { return new EnigmaSphinxTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; Permanent permanent = zEvent . getTarget (  ) ; if  ( permanent != null && zEvent . getToZone (  )  == Zone . GRAVEYARD && zEvent . getFromZone (  )  == Zone . BATTLEFIELD && permanent . getId (  )  . equals ( this . getSourceId (  )  )  && permanent . getOwnerId (  )  . equals ( permanent . getControllerId (  )  )  )  { return true; } return false; } @Override public String getRule (  )  { return "When {this} is put into your graveyard from the battlefield, " + super . getRule (  ) ; } } class EnigmaSphinxEffect extends OneShotEffect { public EnigmaSphinxEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "put it into your library third from the top"; } public EnigmaSphinxEffect ( final EnigmaSphinxEffect effect )  { super ( effect ) ; } @Override public EnigmaSphinxEffect copy (  )  { return new EnigmaSphinxEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card card = game . getCard ( source . getSourceId (  )  ) ; if  ( card != null && game . getState (  )  . getZone ( source . getSourceId (  )  )  == Zone . GRAVEYARD )  { Player owner = game . getPlayer ( card . getOwnerId (  )  ) ; if  ( owner != null && card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true )  )  { game . informPlayers ( card . getLogName (  )  + " is put into " + owner . getLogName (  )  +"'s library third from the top" ) ; Library lib = owner . getLibrary (  ) ; if  ( lib != null )  { Card card1 = lib . removeFromTop ( game ) ; if  ( card1 != null && card1 . getId (  )  . equals ( source . getSourceId (  )  )  )  { Card card2 = lib . removeFromTop ( game ) ; Card card3 = lib . removeFromTop ( game ) ; lib . putOnTop ( card1, game ) ; if  ( card3 != null )  { lib . putOnTop ( card3, game ) ; } if  ( card2 != null )  { lib . putOnTop ( card2, game ) ; } return true; } } } } return false; } } 
public class EnlistedWurm extends CardImpl { public EnlistedWurm ( UUID ownerId )  { super ( ownerId, 68, "Enlisted Wurm", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public EnlistedWurm ( final EnlistedWurm card )  { super ( card ) ; } @Override public EnlistedWurm copy (  )  { return new EnlistedWurm ( this ) ; } } 
public class EsperSojourners extends CardImpl { public EsperSojourners ( UUID ownerId )  { super ( ownerId, 107, "Esper Sojourners", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Vedalken" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability1 = new CycleTriggeredAbility ( new MayTapOrUntapTargetEffect (  )  ) ; Ability ability2 = new DiesTriggeredAbility ( new MayTapOrUntapTargetEffect (  )  ) ; ability1 . addTarget ( new TargetPermanent (  )  ) ; ability2 . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{U}" )  )  ) ; } public EsperSojourners ( final EsperSojourners card )  { super ( card ) ; } @Override public EsperSojourners copy (  )  { return new EsperSojourners ( this ) ; } } 
public class EsperStormblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public EsperStormblade ( UUID ownerId )  { super ( ownerId, 132, "Esper Stormblade", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{W/B}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Vedalken" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( FlyingAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has flying" )  ) ; this . addAbility ( ability ) ; } public EsperStormblade ( final EsperStormblade card )  { super ( card ) ; } @Override public EsperStormblade copy (  )  { return new EsperStormblade ( this ) ; } } 
public class EthercasteKnight extends CardImpl { public EthercasteKnight  ( UUID ownerId )  { super ( ownerId, 3, "Ethercaste Knight", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new ExaltedAbility (  )  ) ; } public EthercasteKnight  ( final EthercasteKnight card )  { super ( card ) ; } @Override public EthercasteKnight copy (  )  { return new EthercasteKnight ( this ) ; } } 
public class EtheriumAbomination extends CardImpl { public EtheriumAbomination  ( UUID ownerId )  { super ( ownerId, 20, "Etherium Abomination", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new UnearthAbility ( new ManaCostsImpl ( "{1}{U}{B}" )  )  ) ; } public EtheriumAbomination  ( final EtheriumAbomination card )  { super ( card ) ; } @Override public EtheriumAbomination copy (  )  { return new EtheriumAbomination ( this ) ; } } 
public class FieldmistBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public FieldmistBorderpost  ( UUID ownerId )  { super ( ownerId, 5, "Fieldmist Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new WhiteManaAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; } public FieldmistBorderpost  ( final FieldmistBorderpost card )  { super ( card ) ; } @Override public FieldmistBorderpost copy (  )  { return new FieldmistBorderpost ( this ) ; } } 
public class FightToTheDeath extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "all blocking creatures and all blocked creatures" ) ; static { filter . add ( Predicates . or (  new BlockingPredicate (  ) , new BlockedPredicate (  )  )  ) ; } public FightToTheDeath ( UUID ownerId )  { super ( ownerId, 97, "Fight to the Death", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{R}{W}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DestroyAllEffect ( filter )  ) ; } public FightToTheDeath ( final FightToTheDeath card )  { super ( card ) ; } @Override public FightToTheDeath copy (  )  { return new FightToTheDeath ( this ) ; } } 
public class FiligreeAngel extends CardImpl { public FiligreeAngel  ( UUID ownerId )  { super ( ownerId, 6, "Filigree Angel", Rarity . RARE, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{5}{W}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new FiligreeAngelEffect (  )  )  ) ; } public FiligreeAngel  ( final FiligreeAngel card )  { super ( card ) ; } @Override public FiligreeAngel copy (  )  { return new FiligreeAngel ( this ) ; } } class FiligreeAngelEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterControlledPermanent (  ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; } public FiligreeAngelEffect (  )  { super ( Outcome . GainLife ) ; staticText = "you gain 3 life for each artifact you control"; } public FiligreeAngelEffect ( final FiligreeAngelEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { int life = game . getBattlefield (  )  . count ( filter, source . getSourceId (  ) , source . getControllerId (  ) , game )  * 3; player . gainLife ( life, game ) ; } return true; } @Override public FiligreeAngelEffect copy (  )  { return new FiligreeAngelEffect ( this ) ; } } 
public class FinestHour extends CardImpl { public FinestHour ( UUID ownerId )  { super ( ownerId, 126, "Finest Hour", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new ExaltedAbility (  )  ) ; this . addAbility ( new FinestHourAbility (  )  ) ; } public FinestHour ( final FinestHour card )  { super ( card ) ; } @Override public FinestHour copy (  )  { return new FinestHour ( this ) ; } } class FinestHourAbility extends TriggeredAbilityImpl { public FinestHourAbility (  )  { super ( Zone . BATTLEFIELD, new FinestHourEffect (  )  ) ; } public FinestHourAbility ( final FinestHourAbility ability )  { super ( ability ) ; } @Override public FinestHourAbility copy (  )  { return new FinestHourAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DECLARED_ATTACKERS; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( game . getActivePlayerId (  )  . equals ( this . controllerId )  )  { if  ( game . getCombat (  )  . attacksAlone (  )  )  { for  ( Effect effect: this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( game . getCombat (  )  . getAttackers (  )  . get ( 0 )  )  ) ; } return true; } } return false; } @Override public boolean checkInterveningIfClause ( Game game )  { return game . getTurn (  )  . getPhase ( TurnPhase . COMBAT )  . getCount (  )  == 0; } @Override public String getRule (  )  { return "Whenever a creature you control attacks alone, if it's the first combat phase of the turn, untap that creature .  After this phase, there is an additional combat phase . "; } } class FinestHourEffect extends OneShotEffect { public FinestHourEffect (  )  { super ( Outcome . Benefit ) ; } public FinestHourEffect ( final FinestHourEffect effect )  { super ( effect ) ; } @Override public FinestHourEffect copy (  )  { return new FinestHourEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( permanent != null )  { permanent . untap ( game ) ; game . getState (  )  . getTurnMods (  )  . add ( new TurnMod ( source . getControllerId (  ) , TurnPhase . COMBAT, null, false )  ) ; return true; } return false; } } 
public class FirewildBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public FirewildBorderpost  ( UUID ownerId )  { super ( ownerId, 54, "Firewild Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new RedManaAbility (  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; } public FirewildBorderpost  ( final FirewildBorderpost card )  { super ( card ) ; } @Override public FirewildBorderpost copy (  )  { return new FirewildBorderpost ( this ) ; } } 
public class FlurryOfWings extends CardImpl { private static final FilterAttackingCreature filter = new FilterAttackingCreature ( "the number of attacking creatures" ) ; public FlurryOfWings ( UUID ownerId )  { super ( ownerId, 127, "Flurry of Wings", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new BirdSoldierToken (  ) , new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public FlurryOfWings ( final FlurryOfWings card )  { super ( card ) ; } @Override public FlurryOfWings copy (  )  { return new FlurryOfWings ( this ) ; } } class BirdSoldierToken extends Token { public BirdSoldierToken (  )  { super ( "Bird Soldier", "1/1 white Bird Soldier creature with flying" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Bird" ) ; color . setWhite ( true ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class GiantAmbushBeetle extends CardImpl { public GiantAmbushBeetle ( UUID ownerId )  { super ( ownerId, 137, "Giant Ambush Beetle", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B/G}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Insect" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new MustBeBlockedByTargetSourceEffect ( Duration . EndOfTurn ) , true ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public GiantAmbushBeetle ( final GiantAmbushBeetle card )  { super ( card ) ; } @Override public GiantAmbushBeetle copy (  )  { return new GiantAmbushBeetle ( this ) ; } } 
public class GlassdustHulk extends CardImpl { private static final FilterPermanent filter = new FilterArtifactPermanent ( "another artifact" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public GlassdustHulk ( UUID ownerId )  { super ( ownerId, 7, "Glassdust Hulk", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new EntersBattlefieldControlledTriggeredAbility ( new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , filter, "Whenever another artifact enters the battlefield under your control, Glassdust Hulk gets +1/+1 until end of turn and can't be blocked this turn . " ) ; ability . addEffect ( new CantBeBlockedSourceEffect ( Duration . EndOfTurn )  ) ; this . addAbility ( ability ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{W/U}" )  )  ) ; } public GlassdustHulk ( final GlassdustHulk card )  { super ( card ) ; } @Override public GlassdustHulk copy (  )  { return new GlassdustHulk ( this ) ; } } 
public class GloryOfWarfare extends CardImpl { public GloryOfWarfare  ( UUID ownerId )  { super ( ownerId, 98, "Glory of Warfare", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}{W}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostControlledEffect ( 2, 0, Duration . WhileOnBattlefield ) , MyTurnCondition . getInstance (  ) , "As long as it's your turn, creatures you control get +2/+0" )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostControlledEffect ( 0, 2, Duration . WhileOnBattlefield ) , NotMyTurnCondition . getInstance (  ) , "As long as it's not your turn, creatures you control get +0/+2" )  )  ) ; } public GloryOfWarfare  ( final GloryOfWarfare card )  { super ( card ) ; } @Override public GloryOfWarfare copy (  )  { return new GloryOfWarfare ( this ) ; } } 
public class GloryscaleViashino extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "a multicolored spell" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public GloryscaleViashino  ( UUID ownerId )  { super ( ownerId, 120, "Gloryscale Viashino", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Viashino" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new BoostSourceEffect ( 3, 3, Duration . EndOfTurn ) , filter, false )  ) ; } public GloryscaleViashino  ( final GloryscaleViashino card )  { super ( card ) ; } @Override public GloryscaleViashino copy (  )  { return new GloryscaleViashino ( this ) ; } } 
public class GodtrackerOfJund extends CardImpl { final private static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; static { filter . add ( new PowerPredicate ( Filter . ComparisonType . GreaterThan, 4 )  ) ; } String rule = "Whenever a creature with power 5 or greater enters the battlefield under your control, you may put a +1/+1 counter on {this} . "; public GodtrackerOfJund ( UUID ownerId )  { super ( ownerId, 55, "Godtracker of Jund", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new EntersBattlefieldAllTriggeredAbility ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , filter, true, rule, true )  ) ; } public GodtrackerOfJund ( final GodtrackerOfJund card )  { super ( card ) ; } @Override public GodtrackerOfJund copy (  )  { return new GodtrackerOfJund ( this ) ; } } 
public class GorgerWurm extends CardImpl { public GorgerWurm ( UUID ownerId )  { super ( ownerId, 56, "Gorger Wurm", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DevourAbility ( DevourEffect . DevourFactor . Devour1 )  ) ; } public GorgerWurm ( final GorgerWurm card )  { super ( card ) ; } @Override public GorgerWurm copy (  )  { return new GorgerWurm ( this ) ; } } 
public class GrixisGrimblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public GrixisGrimblade ( UUID ownerId )  { super ( ownerId, 134, "Grixis Grimblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U/R}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( DeathtouchAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has deathtouch" )  ) ; this . addAbility ( ability ) ; } public GrixisGrimblade ( final GrixisGrimblade card )  { super ( card ) ; } @Override public GrixisGrimblade copy (  )  { return new GrixisGrimblade ( this ) ; } } 
public class GrixisSojourners extends CardImpl { public GrixisSojourners ( UUID ownerId )  { super ( ownerId, 112, "Grixis Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Ogre" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability1 = new CycleTriggeredAbility ( new ExileTargetEffect (  ) , true ) ; Ability ability2 = new DiesTriggeredAbility ( new ExileTargetEffect (  ) , true ) ; ability1 . addTarget ( new TargetCardInASingleGraveyard ( 1, 1, new FilterCard (  )  )  ) ; ability2 . addTarget ( new TargetCardInASingleGraveyard ( 1, 1, new FilterCard (  )  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{B}" )  )  ) ; } public GrixisSojourners ( final GrixisSojourners card )  { super ( card ) ; } @Override public GrixisSojourners copy (  )  { return new GrixisSojourners ( this ) ; } } 
public class GrizzledLeotau extends CardImpl { public GrizzledLeotau ( UUID ownerId )  { super ( ownerId, 69, "Grizzled Leotau", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Cat" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 5 ) ; } public GrizzledLeotau ( final GrizzledLeotau card )  { super ( card ) ; } @Override public GrizzledLeotau copy (  )  { return new GrizzledLeotau ( this ) ; } } 
public class IdentityCrisis extends CardImpl { public IdentityCrisis  ( UUID ownerId )  { super ( ownerId, 81, "Identity Crisis", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{W}{W}{B}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new IdentityCrisisEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public IdentityCrisis  ( final IdentityCrisis card )  { super ( card ) ; } @Override public IdentityCrisis copy (  )  { return new IdentityCrisis ( this ) ; } } class IdentityCrisisEffect extends OneShotEffect { IdentityCrisisEffect (  )  { super ( Outcome . Exile ) ; staticText = "Exile all cards from target player's hand and graveyard"; } IdentityCrisisEffect ( final IdentityCrisisEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null )  { for  ( UUID cid : player . getHand (  )  . copy (  )  )  { Card c = game . getCard ( cid ) ; if  ( c != null )  { c . moveToExile ( null, null, source . getSourceId (  ) , game ) ; } } for  ( UUID cid : player . getGraveyard (  )  . copy (  )  )  { Card c = game . getCard ( cid ) ; if  ( c != null )  { c . moveToExile ( null, null, source . getSourceId (  ) , game ) ; } } return true; } return false; } @Override public IdentityCrisisEffect copy (  )  { return new IdentityCrisisEffect ( this ) ; } } 
public class IgneousPouncer extends CardImpl { public IgneousPouncer ( UUID ownerId )  { super ( ownerId, 40, "Igneous Pouncer", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new SwampcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new MountaincyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public IgneousPouncer ( final IgneousPouncer card )  { super ( card ) ; } @Override public IgneousPouncer copy (  )  { return new IgneousPouncer ( this ) ; } } 
public class IllusoryDemon extends CardImpl { public IllusoryDemon ( UUID ownerId )  { super ( ownerId, 21, "Illusory Demon", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Demon" ) ; this . subtype . add ( "Illusion" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new SacrificeSourceEffect (  ) , false )  ) ; } public IllusoryDemon ( final IllusoryDemon card )  { super ( card ) ; } @Override public IllusoryDemon copy (  )  { return new IllusoryDemon ( this ) ; } } 
public class JhessianZombies extends CardImpl { public JhessianZombies ( UUID ownerId )  { super ( ownerId, 22, "Jhessian Zombies", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FearAbility . getInstance (  )  ) ; this . addAbility ( new IslandcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new SwampcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public JhessianZombies ( final JhessianZombies card )  { super ( card ) ; } @Override public JhessianZombies copy (  )  { return new JhessianZombies ( this ) ; } } 
public class JundHackblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public JundHackblade ( UUID ownerId )  { super ( ownerId, 138, "Jund Hackblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B/G}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( HasteAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has haste" )  ) ; this . addAbility ( ability ) ; } public JundHackblade ( final JundHackblade card )  { super ( card ) ; } @Override public JundHackblade copy (  )  { return new JundHackblade ( this ) ; } } 
public class JundSojourners extends CardImpl { public JundSojourners ( UUID ownerId )  { super ( ownerId, 116, "Jund Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Viashino" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability1 = new CycleTriggeredAbility ( new DamageTargetEffect ( 1 )  ) ; Ability ability2 = new DiesTriggeredAbility ( new DamageTargetEffect ( 1 )  ) ; ability1 . addTarget ( new TargetCreatureOrPlayer (  )  ) ; ability2 . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{R}" )  )  ) ; } public JundSojourners ( final JundSojourners card )  { super ( card ) ; } @Override public JundSojourners copy (  )  { return new JundSojourners ( this ) ; } } 
public class KarrthusTyrantOfJund extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Dragon creatures you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new SubtypePredicate ( "Dragon" )  ) ; } public KarrthusTyrantOfJund ( UUID ownerId )  { super ( ownerId, 117, "Karrthus, Tyrant of Jund", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new KarrthusEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAllEffect ( HasteAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter, true )  )  ) ; } public KarrthusTyrantOfJund ( final KarrthusTyrantOfJund card )  { super ( card ) ; } @Override public KarrthusTyrantOfJund copy (  )  { return new KarrthusTyrantOfJund ( this ) ; } } class KarrthusEffect extends OneShotEffect { public KarrthusEffect (  )  { super ( Outcome . GainControl ) ; this . staticText = "gain control of all Dragons, then untap all Dragons"; } public KarrthusEffect ( final KarrthusEffect effect )  { super ( effect ) ; } @Override public KarrthusEffect copy (  )  { return new KarrthusEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { FilterPermanent filter = new FilterPermanent (  ) ; filter . add ( new SubtypePredicate ( "Dragon" )  ) ; List<Permanent> dragons = game . getBattlefield (  )  . getAllActivePermanents ( filter, game ) ; for  ( Permanent dragon : dragons )  { ContinuousEffect effect = new KarrthusControlEffect ( source . getControllerId (  )  ) ; effect . setTargetPointer ( new FixedTarget ( dragon . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } for  ( Permanent dragon : dragons )  { dragon . untap ( game ) ; } return true; } } class KarrthusControlEffect extends ContinuousEffectImpl { private UUID controllerId; public KarrthusControlEffect ( UUID controllerId )  { super ( Duration . EndOfGame, Layer . ControlChangingEffects_2, SubLayer . NA, Outcome . GainControl ) ; this . controllerId = controllerId; } public KarrthusControlEffect ( final KarrthusControlEffect effect )  { super ( effect ) ; this . controllerId = effect . controllerId; } @Override public KarrthusControlEffect copy (  )  { return new KarrthusControlEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent dragon = game . getPermanent ( targetPointer . getFirst ( game, source )  ) ; if  ( dragon != null && controllerId != null )  { return dragon . changeControllerId ( controllerId, game ) ; } return false; } } 
public class KathariBomber extends CardImpl { public KathariBomber ( UUID ownerId )  { super ( ownerId, 41, "Kathari Bomber", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility ( new CreateTokenEffect ( new GoblinToken (  ) , 2 ) , false ) ; ability . addEffect ( new SacrificeSourceEffect (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new UnearthAbility ( new ManaCostsImpl ( "{3}{B}{R}" )  )  ) ; } public KathariBomber ( final KathariBomber card )  { super ( card ) ; } @Override public KathariBomber copy (  )  { return new KathariBomber ( this ) ; } } 
public class KathariRemnant extends CardImpl { public KathariRemnant  ( UUID ownerId )  { super ( ownerId, 23, "Kathari Remnant", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Skeleton" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public KathariRemnant  ( final KathariRemnant card )  { super ( card ) ; } @Override public KathariRemnant copy (  )  { return new KathariRemnant ( this ) ; } } 
public class KnightOfNewAlara extends CardImpl { public KnightOfNewAlara ( UUID ownerId )  { super ( ownerId, 70, "Knight of New Alara", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new KnightOfNewAlaraEffect (  )  )  ) ; } public KnightOfNewAlara ( final KnightOfNewAlara card )  { super ( card ) ; } @Override public KnightOfNewAlara copy (  )  { return new KnightOfNewAlara ( this ) ; } } class KnightOfNewAlaraEffect extends ContinuousEffectImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public KnightOfNewAlaraEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . PTChangingEffects_7, SubLayer . ModifyPT_7c, Outcome . BoostCreature ) ; staticText = "Each other multicolored creature you control gets +1/+1 for each of its colors"; } public KnightOfNewAlaraEffect ( final KnightOfNewAlaraEffect effect )  { super ( effect ) ; } @Override public KnightOfNewAlaraEffect copy (  )  { return new KnightOfNewAlaraEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent creature : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { if  ( creature != null && !creature . getId (  )  . equals ( source . getSourceId (  )  )  )  { int colors = creature . getColor ( game )  . getColorCount (  ) ; creature . addPower ( colors ) ; creature . addToughness ( colors ) ; } } return true; } } 
public class KnotvinePaladin extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creature you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public KnotvinePaladin ( UUID ownerId )  { super ( ownerId, 71, "Knotvine Paladin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( new PermanentsOnBattlefieldCount ( filter ) , new PermanentsOnBattlefieldCount ( filter ) , Duration . EndOfTurn ) , false )  ) ; } public KnotvinePaladin ( final KnotvinePaladin card )  { super ( card ) ; } @Override public KnotvinePaladin copy (  )  { return new KnotvinePaladin ( this ) ; } } 
public class Lavalanche extends CardImpl { public Lavalanche ( UUID ownerId )  { super ( ownerId, 118, "Lavalanche", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new LavalancheEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public Lavalanche ( final Lavalanche card )  { super ( card ) ; } @Override public Lavalanche copy (  )  { return new Lavalanche ( this ) ; } } class LavalancheEffect extends OneShotEffect { private DynamicValue amount; public LavalancheEffect ( DynamicValue amount )  { super ( Outcome . Damage ) ; this . amount = amount; staticText = "Lavalanche deals X damage to target player and each creature he or she controls"; } public LavalancheEffect ( final LavalancheEffect effect )  { super ( effect ) ; this . amount = effect . amount; } @Override public LavalancheEffect copy (  )  { return new LavalancheEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer == null )  { return false; } targetPlayer . damage ( amount . calculate ( game, source, this ) , source . getSourceId (  ) , game, false, true ) ; FilterPermanent filter = new FilterPermanent ( "and each creature he or she controls" ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; filter . add ( new ControllerIdPredicate ( targetPlayer . getId (  )  )  ) ; List<Permanent> permanents = game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game ) ; for  ( Permanent permanent: permanents )  { permanent . damage ( amount . calculate ( game, source, this ) , source . getSourceId (  ) , game, false, true ) ; } return true; } } 
public class LeoninArmorguard extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creatures you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public LeoninArmorguard ( UUID ownerId )  { super ( ownerId, 72, "Leonin Armorguard", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Cat" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new BoostAllEffect ( 1, 1, Duration . EndOfTurn, filter, false )  )  ) ; } public LeoninArmorguard ( final LeoninArmorguard card )  { super ( card ) ; } @Override public LeoninArmorguard copy (  )  { return new LeoninArmorguard ( this ) ; } } 
public class LichLordOfUnx extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Zombies you control" ) ; static { filter . add ( new SubtypePredicate ( "Zombie" )  ) ; } public LichLordOfUnx  ( UUID ownerId )  { super ( ownerId, 24, "Lich Lord of Unx", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new ZombieWizardToken (  )  ) , new ManaCostsImpl ( "{U}{B}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new LoseLifeTargetEffect ( new PermanentsOnBattlefieldCount ( filter )  ) , new ManaCostsImpl ( "{U}{U}{B}{B}" )  ) ; ability . addEffect ( new PutLibraryIntoGraveTargetEffect ( new PermanentsOnBattlefieldCount ( filter, 1 )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public LichLordOfUnx  ( final LichLordOfUnx card )  { super ( card ) ; } @Override public LichLordOfUnx copy (  )  { return new LichLordOfUnx ( this ) ; } } class ZombieWizardToken extends Token { ZombieWizardToken (  )  { super ( "Zombie Wizard", "a 1/1 blue and black Zombie Wizard creature token" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; color . setBlack ( true ) ; subtype . add ( "Zombie" ) ; subtype . add ( "Wizard" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; } } 
public class LightningReaver extends CardImpl { public LightningReaver ( UUID ownerId )  { super ( ownerId, 42, "Lightning Reaver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( FearAbility . getInstance (  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . CHARGE . createInstance (  )  ) , false )  ) ; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( new DamageOpponentsEffect (  ) , TargetController . YOU, false )  ) ; } public LightningReaver ( final LightningReaver card )  { super ( card ) ; } @Override public LightningReaver copy (  )  { return new LightningReaver ( this ) ; } } class DamageOpponentsEffect extends OneShotEffect { public DamageOpponentsEffect (  )  { super ( Outcome . Damage ) ; staticText = "Lightning Reaver deals damage equal to the number of charge counters on it to each opponent"; } public DamageOpponentsEffect ( final DamageOpponentsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { DynamicValue amount = new CountersCount ( CounterType . CHARGE ) ; for  ( UUID playerId : game . getOpponents ( source . getControllerId (  )  )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { player . damage ( amount . calculate ( game, source, this ) , source . getSourceId (  ) , game, false, true ) ; } } return true; } @Override public DamageOpponentsEffect copy (  )  { return new DamageOpponentsEffect ( this ) ; } } 
public class LordOfExtinction extends CardImpl { public LordOfExtinction ( UUID ownerId )  { super ( ownerId, 91, "Lord of Extinction", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new SetPowerToughnessSourceEffect ( new LordOfExtinctionDynamicCount (  ) , Duration . EndOfGame )  )  ) ; } public LordOfExtinction ( final LordOfExtinction card )  { super ( card ) ; } @Override public LordOfExtinction copy (  )  { return new LordOfExtinction ( this ) ; } } class LordOfExtinctionDynamicCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { int count = 0; for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( sourceAbility . getControllerId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { count += player . getGraveyard (  )  . size (  ) ; } } return count; } @Override public DynamicValue copy (  )  { return new LordOfExtinctionDynamicCount (  ) ; } @Override public String getMessage (  )  { return "cards in all graveyards"; } @Override public String toString (  )  { return "1"; } } 
public class LorescaleCoatl extends CardImpl { public LorescaleCoatl  ( UUID ownerId )  { super ( ownerId, 101, "Lorescale Coatl", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DrawCardControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , true )  ) ; } public LorescaleCoatl  ( final LorescaleCoatl card )  { super ( card ) ; } @Override public LorescaleCoatl copy (  )  { return new LorescaleCoatl ( this ) ; } } 
public class MadrushCyclops extends CardImpl { public MadrushCyclops  ( UUID ownerId )  { super ( ownerId, 119, "Madrush Cyclops", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Cyclops" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( HasteAbility . getInstance (  ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent (  )  )  )  ) ; } public MadrushCyclops  ( final MadrushCyclops card )  { super ( card ) ; } @Override public MadrushCyclops copy (  )  { return new MadrushCyclops ( this ) ; } } 
public class MaelstromNexus extends CardImpl { public MaelstromNexus ( UUID ownerId )  { super ( ownerId, 130, "Maelstrom Nexus", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT}, "{W}{U}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MaelstromNexusGainCascadeFirstSpellEffect (  )  ) , new FirstSpellCastThisTurnWatcher (  )  ) ; } public MaelstromNexus ( final MaelstromNexus card )  { super ( card ) ; } @Override public MaelstromNexus copy (  )  { return new MaelstromNexus ( this ) ; } } class MaelstromNexusGainCascadeFirstSpellEffect extends ContinuousEffectImpl { private Ability cascadeAbility = new CascadeAbility (  ) ; public MaelstromNexusGainCascadeFirstSpellEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; staticText = "The first spell you cast each turn has cascade"; } public MaelstromNexusGainCascadeFirstSpellEffect ( final MaelstromNexusGainCascadeFirstSpellEffect effect )  { super ( effect ) ; } @Override public MaelstromNexusGainCascadeFirstSpellEffect copy (  )  { return new MaelstromNexusGainCascadeFirstSpellEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { for  ( StackObject stackObject : game . getStack (  )  )  { if  (  ( stackObject instanceof Spell )  && !stackObject . isCopy (  )  && stackObject . getControllerId (  )  . equals ( source . getControllerId (  )  )  )  { Spell spell =  ( Spell )  stackObject; FirstSpellCastThisTurnWatcher watcher =  ( FirstSpellCastThisTurnWatcher )  game . getState (  )  . getWatchers (  )  . get ( "FirstSpellCastThisTurn" ) ; if  ( watcher != null && spell . getId (  )  . equals ( watcher . getIdOfFirstCastSpell ( source . getControllerId (  )  )  )  )  { game . getState (  )  . addOtherAbility ( spell . getCard (  ) , cascadeAbility ) ; } } } return true; } return false; } } class FirstSpellCastThisTurnWatcher extends Watcher { Map<UUID, UUID> playerFirstSpellCast = new HashMap<> (  ) ; Map<UUID, UUID> playerFirstCastSpell = new HashMap<> (  ) ; public FirstSpellCastThisTurnWatcher (  )  { super ( "FirstSpellCastThisTurn", WatcherScope . GAME ) ; } public FirstSpellCastThisTurnWatcher ( final FirstSpellCastThisTurnWatcher watcher )  { super ( watcher ) ; } @Override public void watch ( GameEvent event, Game game )  { switch  ( event . getType (  )  )  { case SPELL_CAST: case CAST_SPELL: Spell spell =  ( Spell )  game . getObject ( event . getTargetId (  )  ) ; if  ( spell != null && !playerFirstSpellCast . containsKey ( spell . getControllerId (  )  )  )  { if  ( event . getType (  )  . equals ( EventType . SPELL_CAST )  )  { playerFirstSpellCast . put ( spell . getControllerId (  ) , spell . getId (  )  ) ; } else if  ( event . getType (  )  . equals ( EventType . CAST_SPELL )  )  { playerFirstCastSpell . put ( spell . getControllerId (  ) , spell . getId (  )  ) ; } } } } @Override public FirstSpellCastThisTurnWatcher copy (  )  { return new FirstSpellCastThisTurnWatcher ( this ) ; } @Override public void reset (  )  { super . reset (  ) ; playerFirstSpellCast . clear (  ) ; playerFirstCastSpell . clear (  ) ; } public UUID getIdOfFirstCastSpell ( UUID playerId )  { if  ( playerFirstSpellCast . get ( playerId )  == null )  { return playerFirstCastSpell . get ( playerId ) ; } else { return playerFirstSpellCast . get ( playerId ) ; } } } 
public class MaelstromPulse extends CardImpl { public MaelstromPulse ( UUID ownerId )  { super ( ownerId, 92, "Maelstrom Pulse", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{1}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetNonlandPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyAllNamedPermanentsEffect (  )  ) ; } public MaelstromPulse ( final MaelstromPulse card )  { super ( card ) ; } @Override public MaelstromPulse copy (  )  { return new MaelstromPulse ( this ) ; } } 
public class MagefireWings extends CardImpl { public MagefireWings  ( UUID ownerId )  { super ( ownerId, 88, "Magefire Wings", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{U}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 0, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; } public MagefireWings  ( final MagefireWings card )  { super ( card ) ; } @Override public MagefireWings copy (  )  { return new MagefireWings ( this ) ; } } 
public class MarrowChomper extends CardImpl { public MarrowChomper ( UUID ownerId )  { super ( ownerId, 93, "Marrow Chomper", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Lizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevourAbility ( DevourEffect . DevourFactor . Devour2 )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( new DevouredCreaturesCount ( 2 )  )  )  ) ; } public MarrowChomper ( final MarrowChomper card )  { super ( card ) ; } @Override public MarrowChomper copy (  )  { return new MarrowChomper ( this ) ; } } 
public class MaskOfRiddles extends CardImpl { public MaskOfRiddles ( UUID ownerId )  { super ( ownerId, 25, "Mask of Riddles", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FearAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new DealsDamageToAPlayerAttachedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , "equipped", true )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 )  )  ) ; } public MaskOfRiddles ( final MaskOfRiddles card )  { super ( card ) ; } @Override public MaskOfRiddles copy (  )  { return new MaskOfRiddles ( this ) ; } } 
public class MayaelsAria extends CardImpl { public MayaelsAria ( UUID ownerId )  { super ( ownerId, 121, "Mayael's Aria", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new MayaelsAriaEffect (  ) , TargetController . YOU, false )  ) ; } public MayaelsAria ( final MayaelsAria card )  { super ( card ) ; } @Override public MayaelsAria copy (  )  { return new MayaelsAria ( this ) ; } } class MayaelsAriaEffect extends OneShotEffect { public MayaelsAriaEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "put a +1/+1 counter on each creature you control if you control a creature with power 5 or greater .  Then you gain 10 life if you control a creature with power 10 or greater .  Then you win the game if you control a creature with power 20 or greater"; } public MayaelsAriaEffect ( final MayaelsAriaEffect effect )  { super ( effect ) ; } @Override public MayaelsAriaEffect copy (  )  { return new MayaelsAriaEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; filter . add ( new PowerPredicate ( Filter . ComparisonType . GreaterThan, 4 )  ) ; if  ( game . getState (  )  . getBattlefield (  )  . countAll ( filter, controller . getId (  ) , game )  > 0 )  { for  ( Permanent creature : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { creature . addCounters ( CounterType . P1P1 . createInstance (  ) , game ) ; } } game . applyEffects (  ) ;  
public class MeddlingMage extends CardImpl { public MeddlingMage ( UUID ownerId )  { super ( ownerId, 8, "Meddling Mage", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new NameACardEffect ( NameACardEffect . TypeOfName . NON_LAND_NAME )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MeddlingMageReplacementEffect (  )  )  ) ; } public MeddlingMage ( final MeddlingMage card )  { super ( card ) ; } @Override public MeddlingMage copy (  )  { return new MeddlingMage ( this ) ; } } class MeddlingMageReplacementEffect extends ContinuousRuleModifyingEffectImpl { public MeddlingMageReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Detriment ) ; staticText = "The named card can't be cast"; } public MeddlingMageReplacementEffect ( final MeddlingMageReplacementEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public MeddlingMageReplacementEffect copy (  )  { return new MeddlingMageReplacementEffect ( this ) ; } @Override public String getInfoMessage ( Ability source, GameEvent event, Game game )  { MageObject mageObject = game . getObject ( source . getSourceId (  )  ) ; if  ( mageObject != null )  { return "You can't cast a card with that name  ( " + mageObject . getLogName (  )  + " in play )  . "; } return null; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . CAST_SPELL; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { MageObject object = game . getObject ( event . getSourceId (  )  ) ; return object != null && !object . isCopy (  )  && object . getName (  )  . equals ( game . getState (  )  . getValue ( source . getSourceId (  )  . toString (  )  + NameACardEffect . INFO_KEY )  ) ; } } 
public class MessengerFalcons extends CardImpl { public MessengerFalcons ( UUID ownerId )  { super ( ownerId, 145, "Messenger Falcons", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G/U}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; } public MessengerFalcons ( final MessengerFalcons card )  { super ( card ) ; } @Override public MessengerFalcons copy (  )  { return new MessengerFalcons ( this ) ; } } 
public class MindFuneral extends CardImpl { public MindFuneral ( UUID ownerId )  { super ( ownerId, 26, "Mind Funeral", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new MindFuneralEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public MindFuneral ( final MindFuneral card )  { super ( card ) ; } @Override public MindFuneral copy (  )  { return new MindFuneral ( this ) ; } } class MindFuneralEffect extends OneShotEffect { public MindFuneralEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "Target opponent reveals cards from the top of his or her library until four land cards are revealed .  That player puts all cards revealed this way into his or her graveyard"; } public MindFuneralEffect ( final MindFuneralEffect effect )  { super ( effect ) ; } @Override public MindFuneralEffect copy (  )  { return new MindFuneralEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player opponent = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( opponent != null )  { Cards cards = new CardsImpl (  ) ; int landsFound = 0; while  ( landsFound < 4 && opponent . getLibrary (  )  . size (  )  > 0 )  { Card card = opponent . getLibrary (  )  . removeFromTop ( game ) ; if  ( card == null )  { break; } if  ( card . getCardType (  )  . contains ( CardType . LAND )  )  { landsFound++; } cards . add ( card ) ; } opponent . revealCards ( "Mind Funeral", cards, game ) ; opponent . moveCards ( cards, Zone . LIBRARY, Zone . GRAVEYARD, source, game ) ; return true; } return false; } } 
public class MistveinBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public MistveinBorderpost  ( UUID ownerId )  { super ( ownerId, 27, "Mistvein Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public MistveinBorderpost  ( final MistveinBorderpost card )  { super ( card ) ; } @Override public MistveinBorderpost copy (  )  { return new MistveinBorderpost ( this ) ; } } 
public class MonstrousCarabid extends CardImpl { public MonstrousCarabid ( UUID ownerId )  { super ( ownerId, 43, "Monstrous Carabid", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Insect" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new AttacksEachTurnStaticAbility (  )  ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{B/R}" )  )  ) ; } public MonstrousCarabid ( final MonstrousCarabid card )  { super ( card ) ; } @Override public MonstrousCarabid copy (  )  { return new MonstrousCarabid ( this ) ; } } 
public class MorbidBloom extends CardImpl { public MorbidBloom ( UUID ownerId )  { super ( ownerId, 94, "Morbid Bloom", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new MorbidBloomEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInGraveyard ( new FilterCreatureCard ( "creature from a graveyard" )  )  ) ; } public MorbidBloom ( final MorbidBloom card )  { super ( card ) ; } @Override public MorbidBloom copy (  )  { return new MorbidBloom ( this ) ; } } class MorbidBloomEffect extends OneShotEffect { public MorbidBloomEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "Exile target creature card from a graveyard, then put X 1/1 green Saproling creature tokens onto the battlefield, where X is the exiled card's toughness"; } public MorbidBloomEffect ( final MorbidBloomEffect effect )  { super ( effect ) ; } @Override public MorbidBloomEffect copy (  )  { return new MorbidBloomEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card targetCreatureCard = game . getCard ( source . getFirstTarget (  )  ) ; if  ( targetCreatureCard != null )  { targetCreatureCard . moveToExile ( null, null, source . getSourceId (  ) , game ) ; int toughness = targetCreatureCard . getToughness (  )  . getValue (  ) ; SaprolingToken token = new SaprolingToken (  ) ; return token . putOntoBattlefield ( toughness, game, source . getSourceId (  ) , source . getControllerId (  )  ) ; } return false; } } 
public class MycoidShepherd extends CardImpl { public MycoidShepherd ( UUID ownerId )  { super ( ownerId, 73, "Mycoid Shepherd", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Fungus" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new MycoidShepherdTriggeredAbility (  )  ) ; } public MycoidShepherd ( final MycoidShepherd card )  { super ( card ) ; } @Override public MycoidShepherd copy (  )  { return new MycoidShepherd ( this ) ; } } class MycoidShepherdTriggeredAbility extends TriggeredAbilityImpl { public MycoidShepherdTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new GainLifeEffect ( 5 ) , true ) ; } public MycoidShepherdTriggeredAbility ( final MycoidShepherdTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { MageObject lastKnown = game . getLastKnownInformation ( event . getTargetId (  ) , Zone . BATTLEFIELD ) ; if  ( lastKnown == null )  { return false; } ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; Permanent permanent = zEvent . getTarget (  ) ; if  ( permanent == null )  { return false; } if  ( super . getSourceId (  )  . equals ( event . getTargetId (  )  )  || permanent . getPower (  )  . getValue (  )  > 4 && permanent . getControllerId (  )  . equals ( controllerId )  )  { Zone after = game . getState (  )  . getZone ( event . getTargetId (  )  ) ; return after != null && Zone . GRAVEYARD . match ( after ) ; } return false; } @Override public String getRule (  )  { return "Whenever Mycoid Shepherd or another creature you control with power 5 or greater dies, you may gain 5 life . "; } @Override public MycoidShepherdTriggeredAbility copy (  )  { return new MycoidShepherdTriggeredAbility ( this ) ; } } 
public class NayaHushblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public NayaHushblade ( UUID ownerId )  { super ( ownerId, 141, "Naya Hushblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R/W}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, Naya Hushblade gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( ShroudAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , " and has shroud" )  ) ; this . addAbility ( ability ) ; } public NayaHushblade ( final NayaHushblade card )  { super ( card ) ; } @Override public NayaHushblade copy (  )  { return new NayaHushblade ( this ) ; } } 
public class NayaSojourners extends CardImpl { public NayaSojourners ( UUID ownerId )  { super ( ownerId, 122, "Naya Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability1 = new CycleTriggeredAbility ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance (  )  )  ) ; Ability ability2 = new DiesTriggeredAbility ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance (  )  )  ) ; ability1 . addTarget ( new TargetCreaturePermanent (  )  ) ; ability2 . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{G}" )  )  ) ; } public NayaSojourners ( final NayaSojourners card )  { super ( card ) ; } @Override public NayaSojourners copy (  )  { return new NayaSojourners ( this ) ; } } 
public class NecromancersCovenant extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Zombies you control" ) ; static { filter . add ( new SubtypePredicate ( "Zombie" )  ) ; } public NecromancersCovenant ( UUID ownerId )  { super ( ownerId, 82, "Necromancer's Covenant", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}{B}{B}" ) ; this . expansionSetCode = "ARB"; Ability ability = new EntersBattlefieldTriggeredAbility ( new NecromancersConvenantEffect (  ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAllEffect ( LifelinkAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public NecromancersCovenant ( final NecromancersCovenant card )  { super ( card ) ; } @Override public NecromancersCovenant copy (  )  { return new NecromancersCovenant ( this ) ; } } class NecromancersConvenantEffect extends OneShotEffect { public NecromancersConvenantEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "exile all creature cards from target player's graveyard, then put a 2/2 black Zombie creature token onto the battlefield for each card exiled this way"; } public NecromancersConvenantEffect ( NecromancersConvenantEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player == null )  { return false; } int count = 0; for  ( Card card : player . getGraveyard (  )  . getCards ( new FilterCreatureCard (  ) , game )  )  { if  ( card . moveToExile ( source . getSourceId (  ) , "Necromancer Covenant", source . getSourceId (  ) , game )  )  { count += 1; } } ZombieToken zombieToken = new ZombieToken (  ) ; if  ( zombieToken . putOntoBattlefield ( count, game, source . getSourceId (  ) , source . getControllerId (  )  )  )  { return true; } return false; } @Override public NecromancersConvenantEffect copy (  )  { return new NecromancersConvenantEffect ( this ) ; } } 
public class NemesisOfReason extends CardImpl { public NemesisOfReason  ( UUID ownerId )  { super ( ownerId, 28, "Nemesis of Reason", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Leviathan" ) ; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 7 ) ; Effect effect = new PutLibraryIntoGraveTargetEffect ( 10 ) ; effect . setText ( "defending player puts the top ten cards of his or her library into his or her graveyard" ) ; this . addAbility ( new NemesisOfReasonTriggeredAbility ( effect )  ) ; } public NemesisOfReason  ( final NemesisOfReason card )  { super ( card ) ; } @Override public NemesisOfReason copy (  )  { return new NemesisOfReason ( this ) ; } } class NemesisOfReasonTriggeredAbility extends TriggeredAbilityImpl { NemesisOfReasonTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect ) ; } NemesisOfReasonTriggeredAbility ( final NemesisOfReasonTriggeredAbility ability )  { super ( ability ) ; } @Override public NemesisOfReasonTriggeredAbility copy (  )  { return new NemesisOfReasonTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  . equals ( this . getSourceId (  )  )   )  { UUID defenderId = game . getCombat (  )  . getDefendingPlayerId ( this . getSourceId (  ) , game ) ; for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( defenderId )  ) ; } return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} attacks, defending player puts the top ten cards of his or her library into his or her graveyard . "; } } 
public class NulltreadGargantuan extends CardImpl { public NulltreadGargantuan  ( UUID ownerId )  { super ( ownerId, 102, "Nulltread Gargantuan", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 6 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new PutOnLibraryTargetEffect ( true ) , false ) ; Target target = new TargetControlledCreaturePermanent (  ) ; target . setNotTarget ( true ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public NulltreadGargantuan  ( final NulltreadGargantuan card )  { super ( card ) ; } @Override public NulltreadGargantuan copy (  )  { return new NulltreadGargantuan ( this ) ; } } 
public class OfferingToAsha extends CardImpl { public OfferingToAsha ( UUID ownerId )  { super ( ownerId, 9, "Offering to Asha", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetSpell (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CounterUnlessPaysEffect ( new GenericManaCost ( 4 )  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 4 )  ) ; } public OfferingToAsha ( final OfferingToAsha card )  { super ( card ) ; } @Override public OfferingToAsha copy (  )  { return new OfferingToAsha ( this ) ; } } 
public class PaleRecluse extends CardImpl { public PaleRecluse ( UUID ownerId )  { super ( ownerId, 74, "Pale Recluse", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Spider" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; this . addAbility ( new ForestcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new PlainscyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public PaleRecluse ( final PaleRecluse card )  { super ( card ) ; } @Override public PaleRecluse copy (  )  { return new PaleRecluse ( this ) ; } } 
public class PredatoryAdvantage extends CardImpl { public PredatoryAdvantage ( UUID ownerId )  { super ( ownerId, 58, "Predatory Advantage", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new LizardToken (  )  ) , TargetController . OPPONENT, new DidNotCastCreatureCondition (  ) , false ) , new CastCreatureWatcher (  )  ) ; } public PredatoryAdvantage ( final PredatoryAdvantage card )  { super ( card ) ; } @Override public PredatoryAdvantage copy (  )  { return new PredatoryAdvantage ( this ) ; } } class DidNotCastCreatureCondition implements Condition { @Override public boolean apply ( Game game, Ability source )  { Permanent p = game . getPermanent ( source . getSourceId (  )  ) ; if  ( p != null )  { Watcher watcher = game . getState (  )  . getWatchers (  )  . get ( "CastCreature", source . getSourceId (  )  ) ; if  ( watcher != null && !watcher . conditionMet (  )  )  { return true; } } return false; } @Override public String toString (  )  { StringBuilder sb = new StringBuilder ( "if that player didn't cast a creature spell this turn" ) ; return sb . toString (  ) ; } } class CastCreatureWatcher extends Watcher { public CastCreatureWatcher (  )  { super ( "CastCreature", WatcherScope . CARD ) ; } public CastCreatureWatcher ( final CastCreatureWatcher watcher )  { super ( watcher ) ; } @Override public void watch ( GameEvent event, Game game )  { if  ( event . getType (  )  == GameEvent . EventType . SPELL_CAST && game . getActivePlayerId (  )  . equals ( event . getPlayerId (  )  )  && game . getOpponents ( controllerId )  . contains ( event . getPlayerId (  )  )  )  { Spell spell =  ( Spell )  game . getObject ( event . getTargetId (  )  ) ; if  ( spell . getCardType (  )  . contains ( CardType . CREATURE )  )  { condition = true; } } } @Override public CastCreatureWatcher copy (  )  { return new CastCreatureWatcher ( this ) ; } } class LizardToken extends Token { public LizardToken (  )  { super ( "Lizard", "2/2 green Lizard creature token onto the battlefield" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; subtype . add ( "Lizard" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 2 ) ; } } 
public class RebornHope extends CardImpl { private static final FilterCard filter = new FilterCard ( "multicolored card from your graveyard" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public RebornHope ( UUID ownerId )  { super ( ownerId, 76, "Reborn Hope", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{G}{W}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToHandTargetEffect (  )  ) ; } public RebornHope ( final RebornHope card )  { super ( card ) ; } @Override public RebornHope copy (  )  { return new RebornHope ( this ) ; } } 
public class RetaliatorGriffin extends CardImpl { public RetaliatorGriffin ( UUID ownerId )  { super ( ownerId, 123, "Retaliator Griffin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Griffin" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new RetaliatorGriffinTriggeredAbility (  )  ) ; } public RetaliatorGriffin ( final RetaliatorGriffin card )  { super ( card ) ; } @Override public RetaliatorGriffin copy (  )  { return new RetaliatorGriffin ( this ) ; } } class RetaliatorGriffinTriggeredAbility extends TriggeredAbilityImpl { public RetaliatorGriffinTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new RetaliatorGriffinEffect (  ) , true ) ; } public RetaliatorGriffinTriggeredAbility ( final RetaliatorGriffinTriggeredAbility ability )  { super ( ability ) ; } @Override public RetaliatorGriffinTriggeredAbility copy (  )  { return new RetaliatorGriffinTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  . equals ( GameEvent . EventType . DAMAGED_PLAYER ) ; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( getControllerId (  )  )  )  { UUID sourceControllerId = game . getControllerId ( event . getSourceId (  )  ) ; if  ( sourceControllerId != null && game . getOpponents ( getControllerId (  )  )  . contains ( sourceControllerId )  )  { getEffects (  )  . get ( 0 )  . setValue ( "damageAmount", event . getAmount (  )  ) ; return true; } } return false; } @Override public String getRule (  )  { return "Whenever a source an opponent controls deals damage to you, you may put that many +1/+1 counters on {this} . "; } } class RetaliatorGriffinEffect extends OneShotEffect { public RetaliatorGriffinEffect (  )  { super ( Outcome . BoostCreature ) ; } public RetaliatorGriffinEffect ( final RetaliatorGriffinEffect effect )  { super ( effect ) ; } @Override public RetaliatorGriffinEffect copy (  )  { return new RetaliatorGriffinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; Integer amount =  ( Integer )  this . getValue ( "damageAmount" ) ; if  ( permanent != null && amount != null && amount > 0 )  { new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( amount ) , true )  . apply ( game, source ) ; } return true; } return false; } } 
public class RhoxBrute extends CardImpl { public RhoxBrute  ( UUID ownerId )  { super ( ownerId, 59, "Rhox Brute", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rhino" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; } public RhoxBrute  ( final RhoxBrute card )  { super ( card ) ; } @Override public RhoxBrute copy (  )  { return new RhoxBrute ( this ) ; } } 
public class SagesOfTheAnima extends CardImpl { public SagesOfTheAnima ( UUID ownerId )  { super ( ownerId, 103, "Sages of the Anima", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SagesOfTheAnimaReplacementEffect (  )  )  ) ; } public SagesOfTheAnima ( final SagesOfTheAnima card )  { super ( card ) ; } @Override public SagesOfTheAnima copy (  )  { return new SagesOfTheAnima ( this ) ; } } class SagesOfTheAnimaReplacementEffect extends ReplacementEffectImpl { public SagesOfTheAnimaReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "If you would draw a card, instead reveal the top three cards of your library .  Put all creature cards revealed this way into your hand and the rest on the bottom of your library in any order"; } public SagesOfTheAnimaReplacementEffect ( final SagesOfTheAnimaReplacementEffect effect )  { super ( effect ) ; } @Override public SagesOfTheAnimaReplacementEffect copy (  )  { return new SagesOfTheAnimaReplacementEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { FilterCard filter = new FilterCard (  ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; Player player = game . getPlayer ( event . getPlayerId (  )  ) ; Cards cards = new CardsImpl (  ) ; if  ( player != null )  { for  ( int i = 0; i < 3; i++ )  { Card card = player . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { cards . add ( card ) ; } } player . revealCards ( "Top three cards of library revealed", cards, game ) ; for  ( Card revealedCard : cards . getCards ( game )  )  { if  ( revealedCard . getCardType (  )  . contains ( CardType . CREATURE )  )  { revealedCard . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; cards . remove ( revealedCard ) ; } } TargetCard target = new TargetCard ( Zone . LIBRARY, new FilterCard (  )  ) ; while  ( player . canRespond (  )  && cards . size (  )  > 1 )  { player . choose ( Outcome . Neutral, cards, target, game ) ; Card card = cards . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { cards . remove ( card ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } target . clearChosen (  ) ; } if  ( cards . size (  )  == 1 )  { Card card = cards . get ( cards . iterator (  )  . next (  ) , game ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } } return true; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DRAW_CARD; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getPlayerId (  )  . equals ( source . getControllerId (  )  ) ; } } 
public class SanctumPlowbeast extends CardImpl { public SanctumPlowbeast ( UUID ownerId )  { super ( ownerId, 10, "Sanctum Plowbeast", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( new PlainscyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new IslandcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public SanctumPlowbeast ( final SanctumPlowbeast card )  { super ( card ) ; } @Override public SanctumPlowbeast copy (  )  { return new SanctumPlowbeast ( this ) ; } } 
public class SangriteBacklash extends CardImpl { public SangriteBacklash ( UUID ownerId )  { super ( ownerId, 139, "Sangrite Backlash", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{B/G}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 3, -3 )  )  ) ; } public SangriteBacklash ( final SangriteBacklash card )  { super ( card ) ; } @Override public SangriteBacklash copy (  )  { return new SangriteBacklash ( this ) ; } } 
public class SanityGnawers extends CardImpl { public SanityGnawers ( UUID ownerId )  { super ( ownerId, 44, "Sanity Gnawers", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rat" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DiscardTargetEffect ( 1, true ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public SanityGnawers ( final SanityGnawers card )  { super ( card ) ; } @Override public SanityGnawers copy (  )  { return new SanityGnawers ( this ) ; } } 
public class SenTriplets extends CardImpl { public SenTriplets ( UUID ownerId )  { super ( ownerId, 109, "Sen Triplets", Rarity . MYTHIC, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new SenTripletsRuleModifyingEffect (  ) , TargetController . YOU, false, false ) ; ability . addEffect ( new SenTripletsOpponentRevealsHandEffect (  )  ) ; ability . addEffect ( new SenTripletsPlayFromOpponentsHandEffect (  )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public SenTriplets ( final SenTriplets card )  { super ( card ) ; } @Override public SenTriplets copy (  )  { return new SenTriplets ( this ) ; } } class SenTripletsRuleModifyingEffect extends ContinuousRuleModifyingEffectImpl { public SenTripletsRuleModifyingEffect (  )  { super ( Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "At the beginning of your upkeep, choose target opponent .  This turn, that player can't cast spells or activate abilities"; } public SenTripletsRuleModifyingEffect ( final SenTripletsRuleModifyingEffect effect )  { super ( effect ) ; } @Override public SenTripletsRuleModifyingEffect copy (  )  { return new SenTripletsRuleModifyingEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public String getInfoMessage ( Ability source, GameEvent event, Game game )  { Player targetPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; MageObject mageObject = game . getObject ( source . getSourceId (  )  ) ; if  ( targetPlayer != null && mageObject != null )  { return "This turn you can't cast spells or activate abilities" + "  ( " + mageObject . getLogName (  )  + " ) "; } return null; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . CAST_SPELL || event . getType (  )  == GameEvent . EventType . ACTIVATE_ABILITY; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getPlayerId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  ) ; } } class SenTripletsOpponentRevealsHandEffect extends ContinuousEffectImpl { public SenTripletsOpponentRevealsHandEffect (  )  { super ( Duration . EndOfTurn, Layer . PlayerEffects, SubLayer . NA, Outcome . Detriment ) ; staticText = "and plays with his or her hand revealed"; } public SenTripletsOpponentRevealsHandEffect ( final SenTripletsOpponentRevealsHandEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( player != null )  { player . revealCards ( player . getName (  )  + "'s hand cards", player . getHand (  ) , game, false ) ; } return true; } @Override public SenTripletsOpponentRevealsHandEffect copy (  )  { return new SenTripletsOpponentRevealsHandEffect ( this ) ; } } class SenTripletsPlayFromOpponentsHandEffect extends AsThoughEffectImpl { public SenTripletsPlayFromOpponentsHandEffect (  )  { super ( AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE, Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "You may play cards from that player's hand this turn"; } public SenTripletsPlayFromOpponentsHandEffect ( final SenTripletsPlayFromOpponentsHandEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public SenTripletsPlayFromOpponentsHandEffect copy (  )  { return new SenTripletsPlayFromOpponentsHandEffect ( this ) ; } @Override public boolean applies ( UUID objectId, Ability source, UUID affectedControllerId, Game game )  { Card card = game . getCard ( objectId ) ; return card != null && card . getOwnerId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  )  && game . getState (  )  . getZone ( objectId )  . equals ( Zone . HAND )  && affectedControllerId . equals ( source . getControllerId (  )  ) ; } } 
public class SewnEyeDrake extends CardImpl { public SewnEyeDrake  ( UUID ownerId )  { super ( ownerId, 135, "Sewn-Eye Drake", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U/R}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; } public SewnEyeDrake  ( final SewnEyeDrake card )  { super ( card ) ; } @Override public SewnEyeDrake copy (  )  { return new SewnEyeDrake ( this ) ; } } 
public class ShieldOfTheRighteous extends CardImpl { public ShieldOfTheRighteous ( UUID ownerId )  { super ( ownerId, 11, "Shield of the Righteous", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 0, 2 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( VigilanceAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new BlocksCreatureAttachedTriggeredAbility ( new DontUntapInControllersNextUntapStepTargetEffect ( "that creature" ) , "equipped", false, false, true )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 ) , new TargetControlledCreaturePermanent (  )  )  ) ; } public ShieldOfTheRighteous ( final ShieldOfTheRighteous card )  { super ( card ) ; } @Override public ShieldOfTheRighteous copy (  )  { return new ShieldOfTheRighteous ( this ) ; } } 
public class SigilCaptain extends CardImpl { public SigilCaptain ( UUID ownerId )  { super ( ownerId, 77, "Sigil Captain", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{W}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rhino" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SigilCaptainTriggeredAbility (  )  ) ; } public SigilCaptain ( final SigilCaptain card )  { super ( card ) ; } @Override public SigilCaptain copy (  )  { return new SigilCaptain ( this ) ; } } class SigilCaptainTriggeredAbility extends TriggeredAbilityImpl { public SigilCaptainTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new AddCountersTargetEffect ( CounterType . P1P1 . createInstance ( 2 )  )  ) ; } public SigilCaptainTriggeredAbility ( final SigilCaptainTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent == null )  { return false; } if  ( permanent . getControllerId (  )  . equals ( controllerId )  && permanent . getPower (  )  . getValue (  )  == 1 && permanent . getToughness (  )  . getValue (  )  == 1 )  { for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( event . getTargetId (  )  )  ) ; } return true; } return false; } @Override public SigilCaptainTriggeredAbility copy (  )  { return new SigilCaptainTriggeredAbility ( this ) ; } @Override public String getRule (  )  { StringBuilder sb = new StringBuilder (  ) ; sb . append ( "Whenever a creature enters the battlefield under your control, if that creature is 1/1, put two +1/+1 counters on it" ) ; return sb . toString (  ) ; } } 
public class SigiledBehemoth extends CardImpl { public SigiledBehemoth  ( UUID ownerId )  { super ( ownerId, 79, "Sigiled Behemoth", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new ExaltedAbility (  )  ) ; } public SigiledBehemoth  ( final SigiledBehemoth card )  { super ( card ) ; } @Override public SigiledBehemoth copy (  )  { return new SigiledBehemoth ( this ) ; } } 
public class SigilOfTheNayanGods extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; public SigilOfTheNayanGods ( UUID ownerId )  { super ( ownerId, 78, "Sigil of the Nayan Gods", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; this . addAbility ( new EnchantAbility ( auraTarget . getTargetName (  )  )  ) ; PermanentsOnBattlefieldCount amount = new PermanentsOnBattlefieldCount ( filter, 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( amount, amount, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{G/W}" )  )  ) ; } public SigilOfTheNayanGods ( final SigilOfTheNayanGods card )  { super ( card ) ; } @Override public SigilOfTheNayanGods copy (  )  { return new SigilOfTheNayanGods ( this ) ; } } 
public class SingeMindOgre extends CardImpl { public SingeMindOgre ( UUID ownerId )  { super ( ownerId, 45, "Singe-Mind Ogre", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Mutant" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new SingeMindOgreEffect (  ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public SingeMindOgre ( final SingeMindOgre card )  { super ( card ) ; } @Override public SingeMindOgre copy (  )  { return new SingeMindOgre ( this ) ; } } class SingeMindOgreEffect extends OneShotEffect { public SingeMindOgreEffect (  )  { super ( Outcome . LoseLife ) ; this . staticText = "target player reveals a card at random from his or her hand, then loses life equal to that card's converted mana cost"; } public SingeMindOgreEffect ( final SingeMindOgreEffect effect )  { super ( effect ) ; } @Override public SingeMindOgreEffect copy (  )  { return new SingeMindOgreEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer != null && targetPlayer . getHand (  )  . size (  )  > 0 )  { Cards revealed = new CardsImpl (  ) ; Card card = targetPlayer . getHand (  )  . getRandom ( game ) ; revealed . add ( card ) ; targetPlayer . revealCards ( "Singe-Mind Ogre", revealed, game ) ; targetPlayer . loseLife ( card . getManaCost (  )  . convertedManaCost (  ) , game ) ; return true; } return false; } } 
public class SkyclawThrash extends CardImpl { public SkyclawThrash ( UUID ownerId )  { super ( ownerId, 89, "Skyclaw Thrash", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}{U}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Viashino" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; } public SkyclawThrash ( final SkyclawThrash card )  { super ( card ) ; } @Override public SkyclawThrash copy (  )  { return new SkyclawThrash ( this ) ; } } 
public class SlaveOfBolas extends CardImpl { public SlaveOfBolas ( UUID ownerId )  { super ( ownerId, 136, "Slave of Bolas", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{U/R}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new GainControlTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new UntapTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new SlaveOfBolasEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public SlaveOfBolas ( final SlaveOfBolas card )  { super ( card ) ; } @Override public SlaveOfBolas copy (  )  { return new SlaveOfBolas ( this ) ; } } class SlaveOfBolasEffect extends OneShotEffect { public SlaveOfBolasEffect (  )  { super ( Outcome . Sacrifice ) ; staticText = "Sacrifice it at the beginning of the next end step"; } public SlaveOfBolasEffect ( final SlaveOfBolasEffect effect )  { super ( effect ) ; } @Override public SlaveOfBolasEffect copy (  )  { return new SlaveOfBolasEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect ( "sacrifice this", source . getControllerId (  )  ) ; sacrificeEffect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( sacrificeEffect ) ; game . addDelayedTriggeredAbility ( delayedAbility, source ) ; return true; } return false; } } 
public class SoulManipulation extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "creature spell" ) ; private static final FilterCreatureCard filter2 = new FilterCreatureCard ( "creature card from your graveyard" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public SoulManipulation ( UUID ownerId )  { super ( ownerId, 29, "Soul Manipulation", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . getModes (  )  . setMinModes ( 1 ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 2 ) ; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new ReturnFromGraveyardToHandTargetEffect (  )  ) ; mode . getTargets (  )  . add ( new TargetCardInYourGraveyard ( filter2 )  ) ; this . getSpellAbility (  )  . addMode ( mode ) ; } public SoulManipulation ( final SoulManipulation card )  { super ( card ) ; } @Override public SoulManipulation copy (  )  { return new SoulManipulation ( this ) ; } } 
public class Soulquake extends CardImpl { public Soulquake ( UUID ownerId )  { super ( ownerId, 30, "Soulquake", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}{U}{B}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new SoulquakeEffect (  )  ) ; } public Soulquake ( final Soulquake card )  { super ( card ) ; } @Override public Soulquake copy (  )  { return new Soulquake ( this ) ; } } class SoulquakeEffect extends OneShotEffect { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature" ) ; private static final FilterCreatureCard filter2 = new FilterCreatureCard ( "creature" ) ; public SoulquakeEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "Return all creatures on the battlefield and all creature cards in graveyards to their owners' hands"; } public SoulquakeEffect ( final SoulquakeEffect effect )  { super ( effect ) ; } @Override public SoulquakeEffect copy (  )  { return new SoulquakeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, true ) ; } for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( source . getControllerId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { for  ( Card card : player . getGraveyard (  )  . getCards ( filter2, game )  )  { card . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, true ) ; } } } return true; } } 
public class SpellbreakerBehemoth extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "Creature spells you control with power 5 or greater" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; filter . add ( new PowerPredicate ( Filter . ComparisonType . GreaterThan, 4 )  ) ; } public SpellbreakerBehemoth ( UUID ownerId )  { super ( ownerId, 60, "Spellbreaker Behemoth", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{R}{G}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . STACK, new CantBeCounteredSourceEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeCounteredControlledEffect ( filter, Duration . WhileOnBattlefield )  )  ) ; } public SpellbreakerBehemoth ( final SpellbreakerBehemoth card )  { super ( card ) ; } @Override public SpellbreakerBehemoth copy (  )  { return new SpellbreakerBehemoth ( this ) ; } } 
public class SphinxOfTheSteelWind extends CardImpl { private static final FilterCard filter = new FilterCard ( "red and from green" ) ; static { filter . add ( Predicates . or (  new ColorPredicate ( ObjectColor . RED ) , new ColorPredicate ( ObjectColor . GREEN )  )  ) ; } public SphinxOfTheSteelWind  ( UUID ownerId )  { super ( ownerId, 110, "Sphinx of the Steel Wind", Rarity . MYTHIC, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{5}{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Sphinx" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( LifelinkAbility . getInstance (  )  ) ; this . addAbility ( new ProtectionAbility ( filter )  ) ; } public SphinxOfTheSteelWind  ( final SphinxOfTheSteelWind card )  { super ( card ) ; } @Override public SphinxOfTheSteelWind copy (  )  { return new SphinxOfTheSteelWind ( this ) ; } } 
public class StormcallersBoon extends CardImpl { public StormcallersBoon ( UUID ownerId )  { super ( ownerId, 13, "Stormcaller's Boon", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "Creatures" )  ) , new SacrificeSourceCost (  )  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public StormcallersBoon ( final StormcallersBoon card )  { super ( card ) ; } @Override public StormcallersBoon copy (  )  { return new StormcallersBoon ( this ) ; } } 
public class StunSniper extends CardImpl { public StunSniper  ( UUID ownerId )  { super ( ownerId, 100, "Stun Sniper", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Archer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addEffect ( new TapTargetEffect (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public StunSniper  ( final StunSniper card )  { super ( card ) ; } @Override public StunSniper copy (  )  { return new StunSniper ( this ) ; } } 
public class TaintedSigil extends CardImpl { String rule = "You gain life equal to the total life lost by all players this turn"; public TaintedSigil ( UUID ownerId )  { super ( ownerId, 83, "Tainted Sigil", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}{W}{B}" ) ; this . expansionSetCode = "ARB"; AllPlayersLostLifeCount totalLifeLostThisTurn = new AllPlayersLostLifeCount (  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( totalLifeLostThisTurn, rule ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public TaintedSigil ( final TaintedSigil card )  { super ( card ) ; } @Override public TaintedSigil copy (  )  { return new TaintedSigil ( this ) ; } } class AllPlayersLostLifeCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { return this . calculate ( game, sourceAbility . getControllerId (  )  ) ; } public int calculate ( Game game, UUID controllerId )  { PlayerLostLifeWatcher watcher =  ( PlayerLostLifeWatcher )  game . getState (  )  . getWatchers (  )  . get ( "PlayerLostLifeWatcher" ) ; if  ( watcher != null )  { int amountLifeLost = 0; for  ( UUID playerId : game . getPlayerList (  )  )  { amountLifeLost += watcher . getLiveLost ( playerId ) ; } return amountLifeLost; } return 0; } @Override public DynamicValue copy (  )  { return new AllPlayersLostLifeCount (  ) ; } @Override public String toString (  )  { return "X"; } @Override public String getMessage (  )  { return "the total life lost by all players this turn"; } } 
public class TalonTrooper extends CardImpl { public TalonTrooper  ( UUID ownerId )  { super ( ownerId, 14, "Talon Trooper", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } public TalonTrooper  ( final TalonTrooper card )  { super ( card ) ; } @Override public TalonTrooper copy (  )  { return new TalonTrooper ( this ) ; } } 
public class Terminate extends CardImpl { public Terminate ( UUID ownerId )  { super ( ownerId, 46, "Terminate", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect ( true )  ) ; } public Terminate ( final Terminate card )  { super ( card ) ; } @Override public Terminate copy (  )  { return new Terminate ( this ) ; } } 
public class ThopterFoundry extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "a nontoken artifact" ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; filter . add ( Predicates . not ( new TokenPredicate (  )  )  ) ; } public ThopterFoundry ( UUID ownerId )  { super ( ownerId, 133, "Thopter Foundry", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{W/B}{U}" ) ; this . expansionSetCode = "ARB"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new ThopterToken (  )  ) , new GenericManaCost ( 1 )  ) ; ability . addEffect ( new GainLifeEffect ( 1 )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public ThopterFoundry ( final ThopterFoundry card )  { super ( card ) ; } @Override public ThopterFoundry copy (  )  { return new ThopterFoundry ( this ) ; } } class ThopterToken extends Token { ThopterToken (  )  { super ( "Thopter", "a 1/1 blue Thopter artifact creature token with flying" ) ; cardType . add ( CardType . CREATURE ) ; cardType . add ( CardType . ARTIFACT ) ; color . setBlue ( true ) ; subtype . add ( "Thopter" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class ThoughtHemorrhage extends CardImpl { public ThoughtHemorrhage ( UUID ownerId )  { super ( ownerId, 47, "Thought Hemorrhage", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new NameACardEffect ( NameACardEffect . TypeOfName . NON_LAND_NAME )  ) ; this . getSpellAbility (  )  . addEffect ( new ThoughtHemorrhageEffect (  )  ) ; } public ThoughtHemorrhage ( final ThoughtHemorrhage card )  { super ( card ) ; } @Override public ThoughtHemorrhage copy (  )  { return new ThoughtHemorrhage ( this ) ; } } class ThoughtHemorrhageEffect extends OneShotEffect { final String rule = "Target player reveals his or her hand .  {this} deals 3 damage to that player for each card with that name revealed this way .  Search that player's graveyard, hand, and library for all cards with that name and exile them .  Then that player shuffles his or her library"; public ThoughtHemorrhageEffect (  )  { super ( Outcome . Detriment ) ; staticText = rule; } public ThoughtHemorrhageEffect ( final ThoughtHemorrhageEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; String cardName =  ( String )  game . getState (  )  . getValue ( source . getSourceId (  )  . toString (  )  + NameACardEffect . INFO_KEY ) ; if  ( sourceObject != null && controller != null && cardName != null && !cardName . isEmpty (  )  )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer != null )  { targetPlayer . revealCards ( "hand of " + targetPlayer . getName (  ) , targetPlayer . getHand (  ) , game ) ; int cardsFound = 0; for  ( Card card : targetPlayer . getHand (  )  . getCards ( game )  )  { if  ( card . getName (  )  . equals ( cardName )  )  { cardsFound++; } } if  ( cardsFound > 0 )  { targetPlayer . damage ( 3 * cardsFound, source . getSourceId (  ) , game, false, true ) ; } FilterCard filterNamedCards = new FilterCard (  ) ; filterNamedCards . add ( new NamePredicate ( cardName )  ) ; for  ( Card checkCard : targetPlayer . getGraveyard (  )  . getCards ( game )  )  { if  ( checkCard . getName (  )  . equals ( cardName )  )  { controller . moveCardToExileWithInfo ( checkCard, null, "", source . getSourceId (  ) , game, Zone . GRAVEYARD, true ) ; } } TargetCardInHand targetCardsHand = new TargetCardInHand ( 0, Integer . MAX_VALUE, filterNamedCards ) ; controller . chooseTarget ( outcome, targetPlayer . getGraveyard (  ) , targetCardsHand, source, game ) ; for ( UUID cardId: targetCardsHand . getTargets (  )  )  { Card card = game . getCard ( cardId ) ; if  ( card != null )  { controller . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . HAND, true ) ; } } TargetCardInLibrary targetCardsLibrary = new TargetCardInLibrary ( 0, Integer . MAX_VALUE, filterNamedCards ) ; controller . searchLibrary ( targetCardsLibrary, game, targetPlayer . getId (  )  ) ; for ( UUID cardId: targetCardsLibrary . getTargets (  )  )  { Card card = game . getCard ( cardId ) ; if  ( card != null )  { controller . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . LIBRARY, true ) ; } } targetPlayer . shuffleLibrary ( game ) ; return true; } } return false; } @Override public ThoughtHemorrhageEffect copy (  )  { return new ThoughtHemorrhageEffect ( this ) ; } } 
public class Thraximundar extends CardImpl { public Thraximundar ( UUID ownerId )  { super ( ownerId, 113, "Thraximundar", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{U}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Assassin" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new ThraximundarTriggeredAbility (  )  ) ; this . addAbility ( new PlayerSacrificesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , true )  ) ; } public Thraximundar ( final Thraximundar card )  { super ( card ) ; } @Override public Thraximundar copy (  )  { return new Thraximundar ( this ) ; } } class ThraximundarTriggeredAbility extends TriggeredAbilityImpl { private static final FilterControlledPermanent filter; static { filter = new FilterControlledPermanent ( " a creature" ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public ThraximundarTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new SacrificeEffect ( filter, 1, "defending player" )  ) ; } public ThraximundarTriggeredAbility ( final ThraximundarTriggeredAbility ability )  { super ( ability ) ; } @Override public ThraximundarTriggeredAbility copy (  )  { return new ThraximundarTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  != null && event . getSourceId (  )  . equals ( this . getSourceId (  )  )  )  { UUID defender = game . getCombat (  )  . getDefendingPlayerId ( this . getSourceId (  ) , game ) ; this . getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( defender )  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} attacks, defending player sacrifices a creature . "; } } class PlayerSacrificesCreatureTriggeredAbility extends TriggeredAbilityImpl { public PlayerSacrificesCreatureTriggeredAbility ( Effect effect, boolean optional )  { super ( Zone . BATTLEFIELD, effect, optional ) ; } public PlayerSacrificesCreatureTriggeredAbility ( final PlayerSacrificesCreatureTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SACRIFICED_PERMANENT; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { MageObject mageObject = game . getLastKnownInformation ( event . getTargetId (  ) , Zone . BATTLEFIELD ) ; return mageObject != null && mageObject . getCardType (  )  . contains ( CardType . CREATURE ) ; } @Override public String getRule (  )  { return "Whenever a player sacrifices a creature, " + super . getRule (  ) ; } @Override public PlayerSacrificesCreatureTriggeredAbility copy (  )  { return new PlayerSacrificesCreatureTriggeredAbility ( this ) ; } } 
public class TimeSieve extends CardImpl { public TimeSieve ( UUID ownerId )  { super ( ownerId, 31, "Time Sieve", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{U}{B}" ) ; this . expansionSetCode = "ARB"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddExtraTurnControllerEffect (  ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( 5, 5, new FilterControlledArtifactPermanent ( "five artifacts" ) , true )  )  ) ; this . addAbility ( ability ) ; } public TimeSieve ( final TimeSieve card )  { super ( card ) ; } @Override public TimeSieve copy (  )  { return new TimeSieve ( this ) ; } } 
public class TraceOfAbundance extends CardImpl { private String rule = "Enchanted land has shroud"; public TraceOfAbundance ( UUID ownerId )  { super ( ownerId, 142, "Trace of Abundance", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{R/W}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Benefit )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ShroudAbility . getInstance (  ) , AttachmentType . AURA, Duration . WhileOnBattlefield, rule )  )  ) ; this . addAbility ( new TraceOfAbundanceTriggeredAbility (  )  ) ; } public TraceOfAbundance ( final TraceOfAbundance card )  { super ( card ) ; } @Override public TraceOfAbundance copy (  )  { return new TraceOfAbundance ( this ) ; } } class TraceOfAbundanceTriggeredAbility extends TriggeredManaAbility { public TraceOfAbundanceTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new AddManaAnyColorAttachedControllerEffect (  )  ) ; } public TraceOfAbundanceTriggeredAbility ( final TraceOfAbundanceTriggeredAbility ability )  { super ( ability ) ; } @Override public TraceOfAbundanceTriggeredAbility copy (  )  { return new TraceOfAbundanceTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TAPPED_FOR_MANA; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent enchantment = game . getPermanent ( this . getSourceId (  )  ) ; return enchantment != null && event . getSourceId (  )  . equals ( enchantment . getAttachedTo (  )  ) ; } @Override public String getRule (  )  { return "Whenever enchanted land is tapped for mana, its controller adds one mana of any color to his or her mana pool . "; } } 
public class UnbenderTine extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "another target permanent" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public UnbenderTine ( UUID ownerId )  { super ( ownerId, 15, "Unbender Tine", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}{W}{U}" ) ; this . expansionSetCode = "ARB"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new UnbenderTineEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public UnbenderTine ( final UnbenderTine card )  { super ( card ) ; } @Override public UnbenderTine copy (  )  { return new UnbenderTine ( this ) ; } } class UnbenderTineEffect extends OneShotEffect { public UnbenderTineEffect (  )  { super ( Outcome . Untap ) ; this . staticText = "Untap another target permanent"; } public UnbenderTineEffect ( final UnbenderTineEffect effect )  { super ( effect ) ; } @Override public UnbenderTineEffect copy (  )  { return new UnbenderTineEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent targetPermanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( targetPermanent == null )  { return false; } return targetPermanent . untap ( game ) ; } } 
public class UnscytheKillerOfKings extends CardImpl { public UnscytheKillerOfKings ( UUID ownerId )  { super ( ownerId, 114, "Unscythe, Killer of Kings", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{U}{B}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 3, 3 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FirstStrikeAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new UnscytheKillerOfKingsTriggeredAbility ( new UnscytheEffect (  )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 ) , new TargetControlledCreaturePermanent (  )  )  ) ; } public UnscytheKillerOfKings ( final UnscytheKillerOfKings card )  { super ( card ) ; } @Override public UnscytheKillerOfKings copy (  )  { return new UnscytheKillerOfKings ( this ) ; } } class UnscytheKillerOfKingsTriggeredAbility extends TriggeredAbilityImpl { public UnscytheKillerOfKingsTriggeredAbility ( Effect effect )  { super ( Zone . ALL, effect, true ) ; } public UnscytheKillerOfKingsTriggeredAbility ( final UnscytheKillerOfKingsTriggeredAbility ability )  { super ( ability ) ; } @Override public UnscytheKillerOfKingsTriggeredAbility copy (  )  { return new UnscytheKillerOfKingsTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  (  (  ( ZoneChangeEvent )  event )  . isDiesEvent (  )  )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; if  ( zEvent . getTarget (  )  . getCardType (  )  . contains ( CardType . CREATURE )  )  {  
public class UrilTheMiststalker extends CardImpl { public UrilTheMiststalker ( UUID ownerId )  { super ( ownerId, 124, "Uril, the Miststalker", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( HexproofAbility . getInstance (  )  ) ; AuraAttachedCount count = new AuraAttachedCount ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( count, count, Duration . WhileOnBattlefield )  )  ) ; } public UrilTheMiststalker ( final UrilTheMiststalker card )  { super ( card ) ; } @Override public UrilTheMiststalker copy (  )  { return new UrilTheMiststalker ( this ) ; } } 
public class ValleyRannet extends CardImpl { public ValleyRannet ( UUID ownerId )  { super ( ownerId, 61, "Valley Rannet", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new MountaincyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new ForestcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public ValleyRannet ( final ValleyRannet card )  { super ( card ) ; } @Override public ValleyRannet copy (  )  { return new ValleyRannet ( this ) ; } } 
public class VectisDominator extends CardImpl { public VectisDominator ( UUID ownerId )  { super ( ownerId, 84, "Vectis Dominator", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{1}{W}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new VectisDominatorEffect ( new PayLifeCost ( 2 )  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public VectisDominator ( final VectisDominator card )  { super ( card ) ; } @Override public VectisDominator copy (  )  { return new VectisDominator ( this ) ; } } class VectisDominatorEffect extends OneShotEffect { protected Cost cost; public VectisDominatorEffect ( Cost cost )  { super ( Outcome . Detriment ) ; this . staticText = "Tap target creature unless its controller pays 2 life"; this . cost = cost; } public VectisDominatorEffect ( final VectisDominatorEffect effect )  { super ( effect ) ; this . cost = effect . cost . copy (  ) ; } @Override public VectisDominatorEffect copy (  )  { return new VectisDominatorEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent targetCreature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( targetCreature != null )  { Player player = game . getPlayer ( targetCreature . getControllerId (  )  ) ; if  ( player != null )  { cost . clearPaid (  ) ; final StringBuilder sb = new StringBuilder ( "Pay 2 life?  ( Otherwise " )  . append ( targetCreature . getName (  )  )  . append ( " will be tapped ) " ) ; if  ( player . chooseUse ( Outcome . Benefit, sb . toString (  ) , source, game )  )  { cost . pay ( source, game, targetCreature . getControllerId (  ) , targetCreature . getControllerId (  ) , true, null ) ; } if  ( !cost . isPaid (  )  )  { return targetCreature . tap ( game ) ; } } } return false; } } 
public class VedalkenGhoul extends CardImpl { public VedalkenGhoul ( UUID ownerId )  { super ( ownerId, 32, "Vedalken Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Vedalken" ) ; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new VedalkenGhoulTriggeredAbility (  )  ) ; } public VedalkenGhoul ( final VedalkenGhoul card )  { super ( card ) ; } @Override public VedalkenGhoul copy (  )  { return new VedalkenGhoul ( this ) ; } } class VedalkenGhoulTriggeredAbility extends TriggeredAbilityImpl { public VedalkenGhoulTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new LoseLifeTargetEffect ( 4 ) , false ) ; } public VedalkenGhoulTriggeredAbility ( final VedalkenGhoulTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . CREATURE_BLOCKED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( this . getSourceId (  )  )  )  { UUID defendingPlayer = game . getCombat (  )  . getDefenderId ( this . getSourceId (  )  ) ; if  ( defendingPlayer != null )  { for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( defendingPlayer )  ) ; } return true; } } return false; } @Override public String getRule (  )  { return "Whenever {this} becomes blocked, defending player loses 4 life . "; } @Override public VedalkenGhoulTriggeredAbility copy (  )  { return new VedalkenGhoulTriggeredAbility ( this ) ; } } 
public class VengefulRebirth extends CardImpl { public VengefulRebirth ( UUID ownerId )  { super ( ownerId, 62, "Vengeful Rebirth", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new VengefulRebirthEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( ExileSpellEffect . getInstance (  )  ) ; } public VengefulRebirth ( final VengefulRebirth card )  { super ( card ) ; } @Override public VengefulRebirth copy (  )  { return new VengefulRebirth ( this ) ; } } class VengefulRebirthEffect extends OneShotEffect { public VengefulRebirthEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Return target card from your graveyard to your hand .  If you return a nonland card to your hand this way, {this} deals damage equal to that card's converted mana cost to target creature or player"; } public VengefulRebirthEffect ( final VengefulRebirthEffect effect )  { super ( effect ) ; } @Override public VengefulRebirthEffect copy (  )  { return new VengefulRebirthEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Card card =  ( Card ) game . getObject ( source . getFirstTarget (  )  ) ; if  ( controller != null && card != null && controller . removeFromGraveyard ( card, game )  )  { controller . moveCards ( card, Zone . GRAVEYARD, Zone . HAND, source, game ) ; if  ( !card . getCardType (  )  . contains ( CardType . LAND )  )  { int damage = card . getManaCost (  )  . convertedManaCost (  ) ; Permanent permanent = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . damage ( damage, source . getSourceId (  ) , game, false, true ) ; } Player targetPlayer = game . getPlayer ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( targetPlayer != null )  { targetPlayer . damage ( damage, source . getSourceId (  ) , game, false, true ) ; } } return true; } return false; } } 
public class ViolentOutburst extends CardImpl { public ViolentOutburst ( UUID ownerId )  { super ( ownerId, 63, "Violent Outburst", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new CascadeAbility (  )  ) ; this . getSpellAbility (  )  . addEffect ( new BoostControlledEffect ( 1, 0, Duration . EndOfTurn )  ) ; } public ViolentOutburst ( final ViolentOutburst card )  { super ( card ) ; } @Override public ViolentOutburst copy (  )  { return new ViolentOutburst ( this ) ; } } 
public class VithianRenegades extends CardImpl { public VithianRenegades  ( UUID ownerId )  { super ( ownerId, 64, "Vithian Renegades", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DestroyTargetEffect (  )  ) ; ability . addTarget ( new TargetPermanent ( new FilterArtifactPermanent (  )  )  ) ; this . addAbility ( ability ) ; } public VithianRenegades  ( final VithianRenegades card )  { super ( card ) ; } @Override public VithianRenegades copy (  )  { return new VithianRenegades ( this ) ; } } 
public class WallOfDenial extends CardImpl { public WallOfDenial  ( UUID ownerId )  { super ( ownerId, 16, "Wall of Denial", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 8 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( ShroudAbility . getInstance (  )  ) ; } public WallOfDenial  ( final WallOfDenial card )  { super ( card ) ; } @Override public WallOfDenial copy (  )  { return new WallOfDenial ( this ) ; } } 
public class Wargate extends CardImpl { public Wargate ( UUID ownerId )  { super ( ownerId, 129, "Wargate", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new WargateEffect (  )  ) ; } public Wargate ( final Wargate card )  { super ( card ) ; } @Override public Wargate copy (  )  { return new Wargate ( this ) ; } } class WargateEffect extends OneShotEffect { WargateEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "Search your library for a permanent card with converted mana cost X or less, put it onto the battlefield, then shuffle your library"; } WargateEffect ( final WargateEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } FilterPermanentCard filter = new FilterPermanentCard ( "permanent card with converted mana cost X or less" ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, source . getManaCostsToPay (  )  . getX (  )  + 1 )  ) ; TargetCardInLibrary target = new TargetCardInLibrary ( filter ) ; if  ( controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { Card card = controller . getLibrary (  )  . getCard ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { controller . moveCards ( card, Zone . BATTLEFIELD, source, game ) ; } } } controller . shuffleLibrary ( game ) ; return false; } @Override public WargateEffect copy (  )  { return new WargateEffect ( this ) ; } } 
public class WildfieldBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public WildfieldBorderpost  ( UUID ownerId )  { super ( ownerId, 80, "Wildfield Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; this . addAbility ( new WhiteManaAbility (  )  ) ; } public WildfieldBorderpost  ( final WildfieldBorderpost card )  { super ( card ) ; } @Override public WildfieldBorderpost copy (  )  { return new WildfieldBorderpost ( this ) ; } } 
public class WingedCoatl extends CardImpl { public WingedCoatl  ( UUID ownerId )  { super ( ownerId, 105, "Winged Coatl", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( DeathtouchAbility . getInstance (  )  ) ; } public WingedCoatl  ( final WingedCoatl card )  { super ( card ) ; } @Override public WingedCoatl copy (  )  { return new WingedCoatl ( this ) ; } } 
public class ZealousPersecution extends CardImpl { public ZealousPersecution ( UUID ownerId )  { super ( ownerId, 85, "Zealous Persecution", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{W}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new BoostControlledEffect ( 1, 1, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new BoostOpponentsEffect ( -1, -1, Duration . EndOfTurn )  ) ; } public ZealousPersecution ( final ZealousPersecution card )  { super ( card ) ; } @Override public ZealousPersecution copy (  )  { return new ZealousPersecution ( this ) ; } } 
public class AesthirGlider1 extends CardImpl { public AesthirGlider1 ( UUID ownerId )  { super ( ownerId, 156, "Aesthir Glider", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new CantBlockAbility (  )  ) ; } public AesthirGlider1 ( final AesthirGlider1 card )  { super ( card ) ; } @Override public AesthirGlider1 copy (  )  { return new AesthirGlider1 ( this ) ; } } 
public class AgentOfStromgald1 extends CardImpl { public AgentOfStromgald1 ( UUID ownerId )  { super ( ownerId, 94, "Agent of Stromgald", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlackMana ( 1 ) , new ManaCostsImpl ( "{R}" )  )  ) ; } public AgentOfStromgald1 ( final AgentOfStromgald1 card )  { super ( card ) ; } @Override public AgentOfStromgald1 copy (  )  { return new AgentOfStromgald1 ( this ) ; } } 
public class BalduvianHorde extends CardImpl { public BalduvianHorde ( UUID ownerId )  { super ( ownerId, 96, "Balduvian Horde", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Barbarian" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new SacrificeSourceUnlessPaysEffect ( new DiscardCardCost ( true )  )  )  ) ; } public BalduvianHorde ( final BalduvianHorde card )  { super ( card ) ; } @Override public BalduvianHorde copy (  )  { return new BalduvianHorde ( this ) ; } } 
public class BalduvianTradingPost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an untapped Mountain" ) ; static { filter . add ( new SubtypePredicate ( "Mountain" )  ) ; filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public BalduvianTradingPost ( UUID ownerId )  { super ( ownerId, 182, "Balduvian Trading Post", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, new Mana ( 1, 0, 0, 0, 0, 0, 0, 1 ) , new TapSourceCost (  )  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetAttackingCreature (  )  ) ; this . addAbility ( ability ) ; } public BalduvianTradingPost ( final BalduvianTradingPost card )  { super ( card ) ; } @Override public BalduvianTradingPost copy (  )  { return new BalduvianTradingPost ( this ) ; } } 
public class BalduvianWarMakers1 extends CardImpl { public BalduvianWarMakers1 ( UUID ownerId )  { super ( ownerId, 97, "Balduvian War-Makers", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Barbarian" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new RampageAbility ( 1 )  ) ; } public BalduvianWarMakers1 ( final BalduvianWarMakers1 card )  { super ( card ) ; } @Override public BalduvianWarMakers1 copy (  )  { return new BalduvianWarMakers1 ( this ) ; } } 
public class Browse extends CardImpl { public Browse ( UUID ownerId )  { super ( ownerId, 38, "Browse", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{U}{U}" ) ; this . expansionSetCode = "ALL"; SimpleActivatedAbility ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BrowseEffect (  ) , new ManaCostsImpl ( "{2}{U}{U}" )  ) ; this . addAbility ( ability ) ; } public Browse ( final Browse card )  { super ( card ) ; } @Override public Browse copy (  )  { return new Browse ( this ) ; } } class BrowseEffect extends OneShotEffect { public BrowseEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Look at the top five cards of your library, put one of them into your hand, and exile the rest"; } public BrowseEffect ( final BrowseEffect effect )  { super ( effect ) ; } @Override public BrowseEffect copy (  )  { return new BrowseEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { Cards cards = new CardsImpl (  ) ; int cardsCount = Math . min ( 5, player . getLibrary (  )  . size (  )  ) ; for  ( int i = 0; i < cardsCount; i++ )  { Card card = player . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { cards . add ( card ) ; } } if  ( cards . size (  )  > 0 )  { player . lookAtCards ( "Browse", cards, game ) ; TargetCard target = new TargetCard ( Zone . LIBRARY, new FilterCard ( "card to put in your hand" )  ) ; if  ( player . choose ( Outcome . Benefit, cards, target, game )  )  { Card card = cards . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { card . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; cards . remove ( card ) ; } } for  ( Card card : cards . getCards ( game )  )  { card . moveToExile ( null, null, source . getSourceId (  ) , game ) ; } } return true; } return false; } } 
public class Burnout extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant spell" ) ; static { filter . add ( new CardTypePredicate ( CardType . INSTANT )  ) ; } public Burnout ( UUID ownerId )  { super ( ownerId, 101, "Burnout", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "ALL"; Effect effect = new BurnoutCounterTargetEffect (  ) ; effect . setText ( "Counter target instant spell if it's blue" ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addEffect ( new CreateDelayedTriggeredAbilityEffect (  new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , Duration . OneUse ) , false )  ) ; } public Burnout ( final Burnout card )  { super ( card ) ; } @Override public Burnout copy (  )  { return new Burnout ( this ) ; } } class BurnoutCounterTargetEffect extends OneShotEffect { public BurnoutCounterTargetEffect (  )  { super ( Outcome . Detriment ) ; } public BurnoutCounterTargetEffect ( final BurnoutCounterTargetEffect effect )  { super ( effect ) ; } @Override public BurnoutCounterTargetEffect copy (  )  { return new BurnoutCounterTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Spell targetSpell = game . getStack (  )  . getSpell ( source . getFirstTarget (  )  ) ; if ( targetSpell != null && targetSpell . getColor ( game )  . isBlue (  )  ) { game . getStack (  )  . counter ( source . getFirstTarget (  ) , source . getSourceId (  ) , game ) ; } return true; } } 
public class CarrierPigeons1 extends CardImpl { public CarrierPigeons1 ( UUID ownerId )  { super ( ownerId, 125, "Carrier Pigeons", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new CreateDelayedTriggeredAbilityEffect (  new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , Duration . OneUse ) , false )  )  ) ; } public CarrierPigeons1 ( final CarrierPigeons1 card )  { super ( card ) ; } @Override public CarrierPigeons1 copy (  )  { return new CarrierPigeons1 ( this ) ; } } 
public class Contagion extends CardImpl { public Contagion ( UUID ownerId )  { super ( ownerId, 4, "Contagion", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{B}{B}" ) ; this . expansionSetCode = "ALL"; FilterOwnedCard filter = new FilterOwnedCard ( "black card from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . BLACK )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class DiminishingReturns extends CardImpl { public DiminishingReturns ( UUID ownerId )  { super ( ownerId, 39, "Diminishing Returns", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{U}{U}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . addEffect ( new DiminishingReturnsEffect (  )  ) ; } public DiminishingReturns ( final DiminishingReturns card )  { super ( card ) ; } @Override public DiminishingReturns copy (  )  { return new DiminishingReturns ( this ) ; } } class DiminishingReturnsEffect extends OneShotEffect { public DiminishingReturnsEffect (  )  { super ( Outcome . Neutral ) ; staticText = "Each player shuffles his or her hand and graveyard into his or her library .  You exile the top ten cards of your library .  Then each player draws up to seven cards . "; } public DiminishingReturnsEffect ( final DiminishingReturnsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { for  ( Card card: player . getHand (  )  . getCards ( game )  )  { card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true ) ; } for  ( Card card: player . getGraveyard (  )  . getCards ( game )  )  { card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true ) ; } player . shuffleLibrary ( game ) ; } } for  ( Card card: controller . getLibrary (  )  . getTopCards ( game, 10 )  )  { controller . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . LIBRARY, true ) ; } for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { int cardsToDrawCount = player . getAmount ( 0, 7, "How many cards to draw  ( up to 7 ) ?", game ) ; player . drawCards ( cardsToDrawCount, game ) ; } } } return true; } @Override public DiminishingReturnsEffect copy (  )  { return new DiminishingReturnsEffect ( this ) ; } } 
public class EnslavedScout1 extends CardImpl { public EnslavedScout1 ( UUID ownerId )  { super ( ownerId, 104, "Enslaved Scout", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( new MountainwalkAbility ( false ) , Duration . EndOfTurn ) , new GenericManaCost ( 2 )  )  ) ; } public EnslavedScout1 ( final EnslavedScout1 card )  { super ( card ) ; } @Override public EnslavedScout1 copy (  )  { return new EnslavedScout1 ( this ) ; } } 
public class Exile extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonwhite attacking creature" ) ; static { filter . add ( new AttackingPredicate (  )  ) ; filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . WHITE )  )  ) ; } public Exile ( UUID ownerId )  { super ( ownerId, 129, "Exile", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{2}{W}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileEffect (  )  ) ; } public Exile ( final Exile card )  { super ( card ) ; } @Override public Exile copy (  )  { return new Exile ( this ) ; } } class ExileEffect extends OneShotEffect { public ExileEffect (  )  { super ( Outcome . GainLife ) ; staticText = "You gain life equal to its toughness"; } public ExileEffect ( final ExileEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent =  ( Permanent )  game . getLastKnownInformation ( source . getFirstTarget (  ) , Zone . BATTLEFIELD ) ; if  ( permanent != null )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . gainLife ( permanent . getToughness (  )  . getValue (  ) , game ) ; } } return false; } @Override public ExileEffect copy (  )  { return new ExileEffect ( this ) ; } } 
public class FeveredStrength1 extends CardImpl { public FeveredStrength1 ( UUID ownerId )  { super ( ownerId, 10, "Fevered Strength", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{B}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( 2, 0, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CreateDelayedTriggeredAbilityEffect (  new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , Duration . OneUse ) , false )  ) ; } public FeveredStrength1 ( final FeveredStrength1 card )  { super ( card ) ; } @Override public FeveredStrength1 copy (  )  { return new FeveredStrength1 ( this ) ; } } 
public class ForceOfWill extends CardImpl { public ForceOfWill ( UUID ownerId )  { super ( ownerId, 42, "Force of Will", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{U}{U}" ) ; this . expansionSetCode = "ALL"; FilterOwnedCard filter = new FilterOwnedCard ( "a blue card from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class GorillaBerserkers1 extends CardImpl { public GorillaBerserkers1 ( UUID ownerId )  { super ( ownerId, 75, "Gorilla Berserkers", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Ape" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new RampageAbility ( 2 )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeBlockedByOneEffect ( 3 )  )  ) ; } public GorillaBerserkers1 ( final GorillaBerserkers1 card )  { super ( card ) ; } @Override public GorillaBerserkers1 copy (  )  { return new GorillaBerserkers1 ( this ) ; } } 
public class GorillaShaman1 extends CardImpl { private final UUID originalId; public GorillaShaman1 ( UUID ownerId )  { super ( ownerId, 106, "Gorilla Shaman", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Ape" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new ManaCostsImpl ( "{X}{X}{1}" )  ) ; ability . addTarget ( new TargetPermanent ( new FilterArtifactPermanent ( "noncreature artifact with converted mana cost X" )  )  ) ; originalId = ability . getOriginalId (  ) ; this . addAbility ( ability ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability . getOriginalId (  )  . equals ( originalId )  )  { int xValue = ability . getManaCostsToPay (  )  . getX (  ) ; ability . getTargets (  )  . clear (  ) ; FilterArtifactPermanent filter = new FilterArtifactPermanent ( new StringBuilder ( "noncreature artifact with converted mana cost " )  . append ( xValue )  . toString (  )  ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . Equal, xValue )  ) ; filter . add ( Predicates . not ( new CardTypePredicate ( CardType . CREATURE )  )  ) ; Target target = new TargetPermanent ( filter ) ; ability . addTarget ( target ) ; } } public GorillaShaman1 ( final GorillaShaman1 card )  { super ( card ) ; this . originalId = card . originalId; } @Override public GorillaShaman1 copy (  )  { return new GorillaShaman1 ( this ) ; } } 
public class HeartOfYavimaya extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "a Forest" ) ; static { filter . add ( new SubtypePredicate ( "Forest" )  ) ; } public HeartOfYavimaya ( UUID ownerId )  { super ( ownerId, 183, "Heart of Yavimaya", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 1,1,Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public HeartOfYavimaya ( final HeartOfYavimaya card )  { super ( card ) ; } @Override public HeartOfYavimaya copy (  )  { return new HeartOfYavimaya ( this ) ; } } 
public class HelmOfObedience extends CardImpl { public HelmOfObedience ( UUID ownerId )  { super ( ownerId, 163, "Helm of Obedience", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "ALL"; VariableManaCost xCosts = new VariableManaCost (  ) ; xCosts . setMinX ( 1 ) ; SimpleActivatedAbility abilitiy = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new HelmOfObedienceEffect (  ) , xCosts ) ; abilitiy . addCost ( new TapSourceCost (  )  ) ; abilitiy . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( abilitiy ) ; } public HelmOfObedience ( final HelmOfObedience card )  { super ( card ) ; } @Override public HelmOfObedience copy (  )  { return new HelmOfObedience ( this ) ; } } class HelmOfObedienceEffect extends OneShotEffect { private static final ManacostVariableValue amount = new ManacostVariableValue (  ) ; public HelmOfObedienceEffect (  )  { super ( Outcome . Detriment ) ; staticText = "Target opponent puts cards from the top of his or her library into his or her graveyard until a creature card or X cards are put into that graveyard this way, whichever comes first .  If a creature card is put into that graveyard this way, sacrifice Helm of Obedience and put that card onto the battlefield under your control .  X can't be 0"; } public HelmOfObedienceEffect ( final HelmOfObedienceEffect effect )  { super ( effect ) ; } @Override public HelmOfObedienceEffect copy (  )  { return new HelmOfObedienceEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player targetOpponent = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( targetOpponent != null )  { int max = amount . calculate ( game, source, this ) ; if ( max != 0 ) { int numberOfCard = 0; while ( targetOpponent . getLibrary (  )  . size (  )  > 0 )  { Card card = targetOpponent . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null ) { if  ( targetOpponent . moveCards ( card, Zone . LIBRARY, Zone . GRAVEYARD, source, game )  )  { if ( card . getCardType (  )  . contains ( CardType . CREATURE )  ) { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { sourcePermanent . sacrifice ( source . getSourceId (  ) , game ) ; } if  ( game . getState (  )  . getZone ( card . getId (  )  )  . equals ( Zone . GRAVEYARD )  )  { card . putOntoBattlefield ( game, Zone . GRAVEYARD, source . getSourceId (  ) , source . getControllerId (  )  ) ; } break; } else{ numberOfCard++; if ( numberOfCard >= max ) { break; } } } } else{ return false; } } } return true; } return false; } } 
public class Inheritance extends CardImpl { public Inheritance ( UUID ownerId )  { super ( ownerId, 130, "Inheritance", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{W}" ) ; this . expansionSetCode = "ALL"; Ability ability = new DiesCreatureTriggeredAbility ( new DoIfCostPaid ( new DrawCardSourceControllerEffect ( 1 ) , new ManaCostsImpl ( "{3}" )  ) , false ) ; this . addAbility ( ability ) ; } public Inheritance ( final Inheritance card )  { super ( card ) ; } @Override public Inheritance copy (  )  { return new Inheritance ( this ) ; } } 
public class InsidiousBookworms1 extends CardImpl { public InsidiousBookworms1 ( UUID ownerId )  { super ( ownerId, 12, "Insidious Bookworms", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Worm" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new DiesTriggeredAbility ( new DoIfCostPaid ( new DiscardTargetEffect ( 1, true ) , new ManaCostsImpl ( "{1}{B}" )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public InsidiousBookworms1 ( final InsidiousBookworms1 card )  { super ( card ) ; } @Override public InsidiousBookworms1 copy (  )  { return new InsidiousBookworms1 ( this ) ; } } 
public class JuniperOrderAdvocate extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "green creatures you control" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public JuniperOrderAdvocate ( UUID ownerId )  { super ( ownerId, 132, "Juniper Order Advocate", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostAllEffect ( 1, 1, Duration . WhileOnBattlefield, filter, false ) , new InvertCondition ( new SourceTappedCondition (  )  ) , "As long as {this} is untapped, green creatures you control get +1/+1 . " )  )  ) ; } public JuniperOrderAdvocate ( final JuniperOrderAdvocate card )  { super ( card ) ; } @Override public JuniperOrderAdvocate copy (  )  { return new JuniperOrderAdvocate ( this ) ; } } 
public class Kaysa extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Green creatures" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; } public Kaysa ( UUID ownerId )  { super ( ownerId, 80, "Kaysa", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "ALL"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1,1, Duration . WhileOnBattlefield, filter )  )  ) ; } public Kaysa ( final Kaysa card )  { super ( card ) ; } @Override public Kaysa copy (  )  { return new Kaysa ( this ) ; } } 
public class KeeperOfTresserhorn extends CardImpl { public KeeperOfTresserhorn ( UUID ownerId )  { super ( ownerId, 14, "Keeper of Tresserhorn", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Avatar" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; Effect effect = new AssignNoCombatDamageSourceEffect ( Duration . EndOfTurn ) ; effect . setText ( "it assigns no combat damage this turn" ) ; Ability ability = new AttacksAndIsNotBlockedTriggeredAbility ( effect, false, true ) ; effect = new LoseLifeTargetEffect ( 2 ) ; effect . setText ( "and defending player loses 2 life" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public KeeperOfTresserhorn ( final KeeperOfTresserhorn card )  { super ( card ) ; } @Override public KeeperOfTresserhorn copy (  )  { return new KeeperOfTresserhorn ( this ) ; } } 
public class LibraryOfLatNam extends CardImpl { public LibraryOfLatNam ( UUID ownerId )  { super ( ownerId, 47, "Library of Lat-Nam", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{4}{U}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . getModes (  )  . setModeChooser ( TargetController . OPPONENT ) ; this . getSpellAbility (  )  . addEffect ( new CreateDelayedTriggeredAbilityEffect ( new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 3 )  ) , false )  ) ; Mode mode = new Mode (  ) ; Effect effect = new SearchLibraryPutInHandEffect ( new TargetCardInLibrary (  ) , false, true ) ; mode . getEffects (  )  . add ( effect ) ; this . getSpellAbility (  )  . addMode ( mode ) ; } public LibraryOfLatNam ( final LibraryOfLatNam card )  { super ( card ) ; } @Override public LibraryOfLatNam copy (  )  { return new LibraryOfLatNam ( this ) ; } } 
public class LimDulsHighGuard1 extends CardImpl { public LimDulsHighGuard1 ( UUID ownerId )  { super ( ownerId, 17, "Lim-Dul's High Guard", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Skeleton" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{1}{B}" )  )  ) ; } public LimDulsHighGuard1 ( final LimDulsHighGuard1 card )  { super ( card ) ; } @Override public LimDulsHighGuard1 copy (  )  { return new LimDulsHighGuard1 ( this ) ; } } 
public class LimDulsPaladin extends CardImpl { public LimDulsPaladin ( UUID ownerId )  { super ( ownerId, 191, "Lim-Dul's Paladin", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new LimDulsPaladinEffect (  ) , TargetController . YOU, false )  ) ; this . addAbility ( new BecomesBlockedTriggeredAbility ( new BoostSourceEffect ( 6, 3, Duration . EndOfTurn ) , false )  ) ; Effect effect = new AssignNoCombatDamageSourceEffect ( Duration . EndOfTurn ) ; effect . setText ( "it assigns no combat damage this turn" ) ; Ability ability = new AttacksAndIsNotBlockedTriggeredAbility ( effect, false, true ) ; effect = new LoseLifeTargetEffect ( 4 ) ; effect . setText ( "and defending player loses 4 life" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public LimDulsPaladin ( final LimDulsPaladin card )  { super ( card ) ; } @Override public LimDulsPaladin copy (  )  { return new LimDulsPaladin ( this ) ; } } class LimDulsPaladinEffect extends SacrificeSourceUnlessPaysEffect { public LimDulsPaladinEffect (  )  { super ( new DiscardTargetCost ( new TargetCardInHand (  )  )  ) ; staticText = "you may discard a card .  If you don't, sacrifice {this} and draw a card . "; } public LimDulsPaladinEffect ( final LimDulsPaladinEffect effect )  { super ( effect ) ; } @Override public LimDulsPaladinEffect copy (  )  { return new LimDulsPaladinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if ( permanent != null )  { super . apply ( game, source ) ; if ( game . getPermanent ( source . getSourceId (  )  )  == null )  { return new DrawCardSourceControllerEffect ( 1 )  . apply ( game, source ) ; } return true; } return false; } } 
public class LordOfTresserhorn extends CardImpl { public LordOfTresserhorn ( UUID ownerId )  { super ( ownerId, 193, "Lord of Tresserhorn", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}{B}{R}" ) ; this . expansionSetCode = "ALL"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 10 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new LoseLifeSourceControllerEffect ( 2 ) , false ) ; ability . addEffect ( new SacrificeControllerEffect ( new FilterControlledCreaturePermanent ( "creatures" ) , 2, "you" )  ) ; Effect effect = new DrawCardTargetEffect ( 2 ) ; effect . setText ( ", and target opponent draws two cards" ) ; ability . addEffect ( effect ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; } public LordOfTresserhorn ( final LordOfTresserhorn card )  { super ( card ) ; } @Override public LordOfTresserhorn copy (  )  { return new LordOfTresserhorn ( this ) ; } } 
public class MysticCompass extends CardImpl { public MysticCompass ( UUID ownerId )  { super ( ownerId, 166, "Mystic Compass", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "ALL"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesBasicLandTargetEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{1}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; Target target = new TargetLandPermanent (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public MysticCompass ( final MysticCompass card )  { super ( card ) ; } @Override public MysticCompass copy (  )  { return new MysticCompass ( this ) ; } } 
public class PhyrexianWarBeast1 extends CardImpl { public PhyrexianWarBeast1 ( UUID ownerId )  { super ( ownerId, 169, "Phyrexian War Beast", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new LeavesBattlefieldTriggeredAbility ( new SacrificeControllerEffect ( new FilterControlledLandPermanent (  ) , 1, "" ) , false ) ; Effect effect = new DamageControllerEffect ( 1 ) ; effect . setText ( "and {this} deals 1 damage to you" ) ; ability . addEffect ( effect ) ; ability . addTarget ( new TargetControlledPermanent ( new FilterControlledLandPermanent (  )  )  ) ; this . addAbility ( ability ) ; } public PhyrexianWarBeast1 ( final PhyrexianWarBeast1 card )  { super ( card ) ; } @Override public PhyrexianWarBeast1 copy (  )  { return new PhyrexianWarBeast1 ( this ) ; } } 
public class Pyrokinesis extends CardImpl { public Pyrokinesis ( UUID ownerId )  { super ( ownerId, 115, "Pyrokinesis", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{R}{R}" ) ; this . expansionSetCode = "ALL"; FilterOwnedCard filter = new FilterOwnedCard ( "a red card from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . RED )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class RoyalHerbalist1 extends CardImpl { public RoyalHerbalist1 ( UUID ownerId )  { super ( ownerId, 147, "Royal Herbalist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 1 ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addCost ( new ExileFromTopOfLibraryCost ( 1 )  ) ; this . addAbility ( ability ) ; } public RoyalHerbalist1 ( final RoyalHerbalist1 card )  { super ( card ) ; } @Override public RoyalHerbalist1 copy (  )  { return new RoyalHerbalist1 ( this ) ; } } 
public class SchoolOfTheUnseen extends CardImpl { public SchoolOfTheUnseen ( UUID ownerId )  { super ( ownerId, 186, "School of the Unseen", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new AnyColorManaAbility ( new GenericManaCost ( 2 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public SchoolOfTheUnseen ( final SchoolOfTheUnseen card )  { super ( card ) ; } @Override public SchoolOfTheUnseen copy (  )  { return new SchoolOfTheUnseen ( this ) ; } } 
public class SeasonedTactician extends CardImpl { public SeasonedTactician ( UUID ownerId )  { super ( ownerId, 150, "Seasoned Tactician", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Advisor" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventNextDamageFromChosenSourceToYouEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}" )  ) ; ability . addCost ( new ExileFromTopOfLibraryCost ( 4 )  ) ; this . addAbility ( ability ) ; } public SeasonedTactician ( final SeasonedTactician card )  { super ( card ) ; } @Override public SeasonedTactician copy (  )  { return new SeasonedTactician ( this ) ; } } 
public class ShelteredValley extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; private static final FilterPermanent filterShelteredValley = new FilterPermanent ( "permanent named Sheltered Valley" ) ; static { filterShelteredValley . add ( new NamePredicate ( "Sheltered Valley" )  ) ; } public ShelteredValley ( UUID ownerId )  { super ( ownerId, 187, "Sheltered Valley", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; Effect effect = new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeAllCost ( filterShelteredValley )  ) ; effect . setText ( "If {this} would enter the battlefield, instead sacrifice each other permanent named {this} you control, then put {this} onto the battlefield . " ) ; Ability ability = new SimpleStaticAbility ( Zone . ALL, effect ) ; this . addAbility ( ability ) ; Condition controls = new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . FEWER_THAN, 4 ) ; effect = new ConditionalOneShotEffect ( new GainLifeEffect ( 1 ) , controls ) ; effect . setText ( "if you control three or fewer lands, you gain 1 life" ) ; ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, effect, TargetController . YOU, false ) ; this . addAbility ( ability ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; } public ShelteredValley ( final ShelteredValley card )  { super ( card ) ; } @Override public ShelteredValley copy (  )  { return new ShelteredValley ( this ) ; } } 
public class ShieldSphere extends CardImpl { public ShieldSphere ( UUID ownerId )  { super ( ownerId, 172, "Shield Sphere", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{0}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( new BlocksTriggeredAbility ( new AddCountersSourceEffect ( new BoostCounter ( 0, -1 )  ) , false )  ) ; } public ShieldSphere ( final ShieldSphere card )  { super ( card ) ; } @Override public ShieldSphere copy (  )  { return new ShieldSphere ( this ) ; } } 
public class SoldeviAdnate1 extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "black or artifact creature" ) ; static { filter . add ( Predicates . or ( new ColorPredicate ( ObjectColor . BLACK ) , new CardTypePredicate ( CardType . ARTIFACT )  )  ) ; } public SoldeviAdnate1 ( UUID ownerId )  { super ( ownerId, 25, "Soldevi Adnate", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new DynamicManaAbility ( Mana . BlackMana ( 1 ) , new SacrificeCostConvertedMana ( "creature" ) , new TapSourceCost (  ) , "add to your mana pool an amount of {B} equal to the sacrificed creature's converted mana cost" ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public SoldeviAdnate1 ( final SoldeviAdnate1 card )  { super ( card ) ; } @Override public SoldeviAdnate1 copy (  )  { return new SoldeviAdnate1 ( this ) ; } } 
public class SoldeviDigger extends CardImpl { public SoldeviDigger ( UUID ownerId )  { super ( ownerId, 174, "Soldevi Digger", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SoldeviDiggerEffect (  ) , new ManaCostsImpl ( "{2}" )  )  ) ; } public SoldeviDigger ( final SoldeviDigger card )  { super ( card ) ; } @Override public SoldeviDigger copy (  )  { return new SoldeviDigger ( this ) ; } } class SoldeviDiggerEffect extends OneShotEffect { public SoldeviDiggerEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "put the top card of your graveyard on the bottom of your library"; } public SoldeviDiggerEffect ( final SoldeviDiggerEffect effect )  { super ( effect ) ; } @Override public SoldeviDiggerEffect copy (  )  { return new SoldeviDiggerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Card topCard = null; for  ( Card card :controller . getGraveyard (  )  . getCards ( game )  )  { topCard = card; } if  ( topCard != null )  { return controller . moveCardToLibraryWithInfo ( topCard, source . getSourceId (  ) , game, Zone . GRAVEYARD, false, true ) ; } return true; } return false; } } 
public class SoldeviExcavations extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an untapped Island" ) ; static { filter . add ( new SubtypePredicate ( "Island" )  ) ; filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public SoldeviExcavations ( UUID ownerId )  { super ( ownerId, 188, "Soldevi Excavations", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, new Mana ( 0, 0, 1, 0, 0, 0, 0, 1 ) , new TapSourceCost (  )  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ScryEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public SoldeviExcavations ( final SoldeviExcavations card )  { super ( card ) ; } @Override public SoldeviExcavations copy (  )  { return new SoldeviExcavations ( this ) ; } } 
public class SoldeviSage1 extends CardImpl { public SoldeviSage1 ( UUID ownerId )  { super ( ownerId, 51, "Soldevi Sage", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SoldeviSageEffect (  ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( 2, 2, new FilterControlledLandPermanent ( "two lands" ) , true )  )  ) ; this . addAbility ( ability ) ; } public SoldeviSage1 ( final SoldeviSage1 card )  { super ( card ) ; } @Override public SoldeviSage1 copy (  )  { return new SoldeviSage1 ( this ) ; } } class SoldeviSageEffect extends OneShotEffect { public SoldeviSageEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Draw three cards, then discard one of them"; } public SoldeviSageEffect ( final SoldeviSageEffect effect )  { super ( effect ) ; } @Override public SoldeviSageEffect copy (  )  { return new SoldeviSageEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { Cards initialHand = player . getHand (  )  . copy (  ) ; player . drawCards ( 3, game ) ; Cards drawnCards = new CardsImpl (  ) ; for  ( UUID cardId : player . getHand (  )  )  { if  ( !initialHand . contains ( cardId )  )  { drawnCards . add ( cardId ) ; } } if  ( drawnCards . size (  )  > 0 )  { TargetCard cardToDiscard = new TargetCard ( Zone . HAND, new FilterCard ( "card to discard" )  ) ; cardToDiscard . setNotTarget ( true ) ; if  ( player . choose ( Outcome . Discard, drawnCards, cardToDiscard, game )  )  { Card card = player . getHand (  )  . get ( cardToDiscard . getFirstTarget (  ) , game ) ; if  ( card != null )  { return player . discard ( card, source, game ) ; } } } return true; } return false; } } 
public class SoldierOfFortune extends CardImpl { public SoldierOfFortune ( UUID ownerId )  { super ( ownerId, 117, "Soldier of Fortune", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Mercenary" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ShuffleLibraryTargetEffect (  ) , new TapSourceCost (  )  ) ; ability . addManaCost ( new ManaCostsImpl ( "{R}" )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public SoldierOfFortune ( final SoldierOfFortune card )  { super ( card ) ; } @Override public SoldierOfFortune copy (  )  { return new SoldierOfFortune ( this ) ; } } 
public class SolGrail extends CardImpl { public SolGrail ( UUID ownerId )  { super ( ownerId, 173, "Sol Grail", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new EntersBattlefieldAbility ( new ChooseColorEffect ( Outcome . Neutral )  )  ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, new SolGrailManaEffect (  ) , new TapSourceCost (  )  )  ) ; } public SolGrail ( final SolGrail card )  { super ( card ) ; } @Override public SolGrail copy (  )  { return new SolGrail ( this ) ; } } class SolGrailManaEffect extends ManaEffect { public SolGrailManaEffect (  )  { super (  ) ; staticText = "Add one mana of the chosen color to your mana pool"; } public SolGrailManaEffect ( final SolGrailManaEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . getManaPool (  )  . addMana ( getMana ( game, source ) , game, source ) ; } return true; } @Override public Mana getMana ( Game game, Ability source )  { ObjectColor color =  ( ObjectColor )  game . getState (  )  . getValue ( source . getSourceId (  )  + "_color" ) ; if  ( color != null )  { return new Mana ( ColoredManaSymbol . lookup ( color . toString (  )  . charAt ( 0 )  )  ) ; } else { return null; } } @Override public SolGrailManaEffect copy (  )  { return new SolGrailManaEffect ( this ) ; } } 
public class StormShaman1 extends CardImpl { public StormShaman1 ( UUID ownerId )  { super ( ownerId, 118, "Storm Shaman", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1,0, Duration . EndOfTurn ) , new ManaCostsImpl ( "{R}" )  )  ) ; } public StormShaman1 ( final StormShaman1 card )  { super ( card ) ; } @Override public StormShaman1 copy (  )  { return new StormShaman1 ( this ) ; } } 
public class SustainingSpirit extends CardImpl { public SustainingSpirit ( UUID ownerId )  { super ( ownerId, 151, "Sustaining Spirit", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Angel" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new CumulativeUpkeepAbility ( new ManaCostsImpl ( "{1}{W}" )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SustainingSpiritReplacementEffect (  )  )  ) ; } public SustainingSpirit ( final SustainingSpirit card )  { super ( card ) ; } @Override public SustainingSpirit copy (  )  { return new SustainingSpirit ( this ) ; } } class SustainingSpiritReplacementEffect extends ReplacementEffectImpl { public SustainingSpiritReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Damage that would reduce your life total to less than 1 reduces it to 1 instead"; } public SustainingSpiritReplacementEffect ( final SustainingSpiritReplacementEffect effect )  { super ( effect ) ; } @Override public SustainingSpiritReplacementEffect copy (  )  { return new SustainingSpiritReplacementEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DAMAGE_CAUSES_LIFE_LOSS; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null &&  ( controller . getLife (  )  > 0 )  && ( controller . getLife (  )  - event . getAmount (  )  )  < 1 && event . getPlayerId (  )  . equals ( controller . getId (  )  )   )  { event . setAmount ( controller . getLife (  )  - 1 ) ; } } return false; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { return false; } } 
public class SwampMosquito1 extends CardImpl { public SwampMosquito1 ( UUID ownerId )  { super ( ownerId, 30, "Swamp Mosquito", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Insect" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Effect effect = new AddPoisonCounterTargetEffect ( 1 ) ; effect . setText ( "defending player gets a poison counter" ) ; this . addAbility ( new AttacksAndIsNotBlockedTriggeredAbility ( effect, false, true )  ) ; } public SwampMosquito1 ( final SwampMosquito1 card )  { super ( card ) ; } @Override public SwampMosquito1 copy (  )  { return new SwampMosquito1 ( this ) ; } } 
public class Tornado extends CardImpl { public Tornado ( UUID ownerId )  { super ( ownerId, 86, "Tornado", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{4}{G}" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new CumulativeUpkeepAbility ( new ManaCostsImpl ( "{G}" )  )  ) ; Ability ability = new LimitedTimesPerTurnActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new ManaCostsImpl ( "{2}{G}" )  ) ; DynamicValue lifeToPayAmount = new MultipliedValue ( new CountersCount ( CounterType . VELOCITY ) , 3 ) ; ability . addCost ( new PayLifeCost ( lifeToPayAmount, "3 life for each velocity counter on {source}" )  ) ; ability . addTarget ( new TargetPermanent (  )  ) ; Effect effect = new AddCountersSourceEffect ( CounterType . VELOCITY . createInstance (  )  ) ; effect . setText ( "and put a velocity counter on {source}" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public Tornado ( final Tornado card )  { super ( card ) ; } @Override public Tornado copy (  )  { return new Tornado ( this ) ; } } 
public class WhipVine1 extends CardImpl { public WhipVine1 ( UUID ownerId )  { super ( ownerId, 89, "Whip Vine", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Plant" ) ; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new TapSourceCost (  )  ) ; FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying blocked by {this}" ) ; filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; filter . add ( new BlockedByIdPredicate ( this . getId (  )  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; ability . addEffect ( new DontUntapAsLongAsSourceTappedEffect (  )  ) ; this . addAbility ( ability ) ; } public WhipVine1 ( final WhipVine1 card )  { super ( card ) ; } @Override public WhipVine1 copy (  )  { return new WhipVine1 ( this ) ; } } 
public class VoidmageApprentice extends CardImpl { public VoidmageApprentice ( UUID ownerId )  { super ( ownerId, 4, "Voidmage Apprentice", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "DD3D"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{2}{U}{U}" )  )  ) ; Ability ability = new TurnedFaceUpSourceTriggeredAbility ( new CounterTargetEffect (  ) , false ) ; ability . addTarget ( new TargetSpell (  )  ) ; this . addAbility ( ability ) ; } public VoidmageApprentice ( final VoidmageApprentice card )  { super ( card ) ; } @Override public VoidmageApprentice copy (  )  { return new VoidmageApprentice ( this ) ; } } 
public class WallOfDeceit extends CardImpl { public WallOfDeceit ( UUID ownerId )  { super ( ownerId, 5, "Wall of Deceit", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "DD3D"; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; Effect effect = new BecomesFaceDownCreatureEffect ( Duration . Custom, BecomesFaceDownCreatureEffect . FaceDownType . MANIFESTED ) ; effect . setText ( "Turn Wall of Deceit face down .  <i> ( It becomes a 2/2 creature .  ) </i>" ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{3}" )  )  ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{U}" )  )  ) ; } public WallOfDeceit ( final WallOfDeceit card )  { super ( card ) ; } @Override public WallOfDeceit copy (  )  { return new WallOfDeceit ( this ) ; } } 
public class ArgivianArchaeologist extends CardImpl { private static final FilterArtifactCard filter = new FilterArtifactCard ( "artifact card from your graveyard" ) ; public ArgivianArchaeologist ( UUID ownerId )  { super ( ownerId, 94, "Argivian Archaeologist", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Artificer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ReturnToHandTargetEffect (  ) , new ManaCostsImpl ( "{W}{W}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; Target target = new TargetCardInYourGraveyard ( filter ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public ArgivianArchaeologist ( final ArgivianArchaeologist card )  { super ( card ) ; } @Override public ArgivianArchaeologist copy (  )  { return new ArgivianArchaeologist ( this ) ; } } 
public class ArgivianBlacksmith extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "artifact creature" ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public ArgivianBlacksmith ( UUID ownerId )  { super ( ownerId, 95, "Argivian Blacksmith", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Artificer" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 2 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public ArgivianBlacksmith ( final ArgivianBlacksmith card )  { super ( card ) ; } @Override public ArgivianBlacksmith copy (  )  { return new ArgivianBlacksmith ( this ) ; } } 
public class ArtifactBlast extends CardImpl { public ArtifactBlast ( UUID ownerId )  { super ( ownerId, 87, "Artifact Blast", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{R}" ) ; this . expansionSetCode = "ATQ"; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( new FilterArtifactSpell (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; } public ArtifactBlast ( final ArtifactBlast card )  { super ( card ) ; } @Override public ArtifactBlast copy (  )  { return new ArtifactBlast ( this ) ; } } 
public class AshnodsBattleGear extends CardImpl { public AshnodsBattleGear ( UUID ownerId )  { super ( ownerId, 4, "Ashnod's Battle Gear", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostTargetEffect ( 2, -2, Duration . Custom ) , SourceTappedCondition . getInstance (  ) , "target creature you control gets +2/-2 for as long as {this} remains tapped" ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public AshnodsBattleGear ( final AshnodsBattleGear card )  { super ( card ) ; } @Override public AshnodsBattleGear copy (  )  { return new AshnodsBattleGear ( this ) ; } } 
public class CandelabraOfTawnos extends CardImpl { private final UUID originalId; public CandelabraOfTawnos ( UUID ownerId )  { super ( ownerId, 8, "Candelabra of Tawnos", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "ATQ"; Effect effect = new UntapTargetEffect (  ) ; effect . setText ( "untap X target lands" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{X}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; originalId = ability . getOriginalId (  ) ; this . addAbility ( ability ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability . getOriginalId (  )  . equals ( originalId )  ) { int xValue = ability . getManaCostsToPay (  )  . getX (  ) ; ability . getTargets (  )  . clear (  ) ; ability . addTarget ( new TargetLandPermanent ( xValue, xValue, new FilterLandPermanent (  ) , false )  ) ; } } public CandelabraOfTawnos ( final CandelabraOfTawnos card )  { super ( card ) ; this . originalId = card . originalId; } @Override public CandelabraOfTawnos copy (  )  { return new CandelabraOfTawnos ( this ) ; } } 
public class CitanulDruid extends CardImpl { private static final FilterArtifactSpell filter = new FilterArtifactSpell (  ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public CitanulDruid ( UUID ownerId )  { super ( ownerId, 61, "Citanul Druid", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SpellCastOpponentTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , filter, false )  ) ; } public CitanulDruid ( final CitanulDruid card )  { super ( card ) ; } @Override public CitanulDruid copy (  )  { return new CitanulDruid ( this ) ; } } 
public class ClayStatue extends CardImpl { public ClayStatue ( UUID ownerId )  { super ( ownerId, 9, "Clay Statue", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{2}" )  )  ) ; } public ClayStatue ( final ClayStatue card )  { super ( card ) ; } @Override public ClayStatue copy (  )  { return new ClayStatue ( this ) ; } } 
public class DampingField extends CardImpl { public DampingField ( UUID ownerId )  { super ( ownerId, 98, "Damping Field", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{W}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DampingFieldEffect (  )  )  ) ; } public DampingField ( final DampingField card )  { super ( card ) ; } @Override public DampingField copy (  )  { return new DampingField ( this ) ; } } class DampingFieldEffect extends RestrictionUntapNotMoreThanEffect { private static final FilterControlledPermanent filter = new FilterControlledArtifactPermanent ( "an artifact" ) ; public DampingFieldEffect (  )  { super ( Duration . WhileOnBattlefield, 1, filter ) ; staticText = "Players can't untap more than one artifact during their untap steps"; } public DampingFieldEffect ( final DampingFieldEffect effect )  { super ( effect ) ; } @Override public boolean applies ( Player player, Ability source, Game game )  { return true; } @Override public DampingFieldEffect copy (  )  { return new DampingFieldEffect ( this ) ; } } 
public class DrafnasRestoration extends CardImpl { public DrafnasRestoration ( UUID ownerId )  { super ( ownerId, 52, "Drafna's Restoration", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{U}" ) ; this . expansionSetCode = "ATQ"; this . getSpellAbility (  )  . addEffect ( new DrafnasRestorationEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addTarget ( new DrafnasRestorationTarget (  )  ) ; } public DrafnasRestoration ( final DrafnasRestoration card )  { super ( card ) ; } @Override public DrafnasRestoration copy (  )  { return new DrafnasRestoration ( this ) ; } } class DrafnasRestorationTarget extends TargetCardInGraveyard { DrafnasRestorationTarget (  )  { super ( 0, Integer . MAX_VALUE, new FilterArtifactCard ( "any number of artifact cards from that player's graveyard" )  ) ; } DrafnasRestorationTarget ( final DrafnasRestorationTarget target )  { super ( target ) ; } @Override public boolean canTarget ( UUID id, Ability source, Game game )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; return targetPlayer != null && targetPlayer . getGraveyard (  )  . contains ( id )  && super . canTarget ( id, source, game ) ; } @Override public Set<UUID> possibleTargets ( UUID sourceId, UUID sourceControllerId, Game game )  { Set<UUID> possibleTargets = new HashSet<> (  ) ; MageObject object = game . getObject ( sourceId ) ; if  ( object != null && object instanceof StackObject )  { Player targetPlayer = game . getPlayer (  (  ( StackObject )  object )  . getStackAbility (  )  . getFirstTarget (  )  ) ; if  ( targetPlayer != null )  { for  ( Card card : targetPlayer . getGraveyard (  )  . getCards ( filter, sourceId, sourceControllerId, game )  )  { if  ( !game . replaceEvent ( GameEvent . getEvent ( GameEvent . EventType . TARGET, card . getId (  ) , sourceId, sourceControllerId )  )  )  { possibleTargets . add ( card . getId (  )  ) ; } } } } return possibleTargets; } @Override public DrafnasRestorationTarget copy (  )  { return new DrafnasRestorationTarget ( this ) ; } } class DrafnasRestorationEffect extends OneShotEffect { DrafnasRestorationEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "Return any number of target artifact cards from target player's graveyard to the top of his or her library in any order"; } DrafnasRestorationEffect ( final DrafnasRestorationEffect effect )  { super ( effect ) ; } @Override public DrafnasRestorationEffect copy (  )  { return new DrafnasRestorationEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Cards cards = new CardsImpl ( source . getTargets (  )  . get ( 1 )  . getTargets (  )  ) ; controller . putCardsOnTopOfLibrary ( cards, game, source, true ) ; return true; } return false; } } 
public class EnergyFlux extends CardImpl { public EnergyFlux ( UUID ownerId )  { super ( ownerId, 53, "Energy Flux", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{U}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility (  Zone . BATTLEFIELD, new GainAbilityAllEffect (  new BeginningOfUpkeepTriggeredAbility (  new SacrificeSourceUnlessPaysEffect ( new GenericManaCost ( 2 )  ) , TargetController . YOU, false ) , Duration . WhileOnBattlefield, new FilterArtifactPermanent (  ) , "All artifacts have \"At the beginning of your upkeep, sacrifice this artifact unless you pay {2} . \"" )  )  ) ; } public EnergyFlux ( final EnergyFlux card )  { super ( card ) ; } @Override public EnergyFlux copy (  )  { return new EnergyFlux ( this ) ; } } 
public class GateToPhyrexia extends CardImpl { public GateToPhyrexia ( UUID ownerId )  { super ( ownerId, 46, "Gate to Phyrexia", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}{B}" ) ; this . expansionSetCode = "ATQ"; Ability ability = new GateToPhyrexiaAbility ( new DestroyTargetEffect (  ) , new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; ability . addTarget ( new TargetArtifactPermanent (  )  ) ; this . addAbility ( ability ) ; } public GateToPhyrexia ( final GateToPhyrexia card )  { super ( card ) ; } @Override public GateToPhyrexia copy (  )  { return new GateToPhyrexia ( this ) ; } } class GateToPhyrexiaAbility extends LimitedTimesPerTurnActivatedAbility { public GateToPhyrexiaAbility ( Effect effect, Cost cost )  { super ( Zone . BATTLEFIELD, effect, cost ) ; } public GateToPhyrexiaAbility ( final GateToPhyrexiaAbility ability )  { super ( ability ) ; } @Override public GateToPhyrexiaAbility copy (  )  { return new GateToPhyrexiaAbility ( this ) ; } @Override public boolean canActivate ( UUID playerId, Game game )  { if  ( !game . getActivePlayerId (  )  . equals ( controllerId )  || !PhaseStep . UPKEEP . equals ( game . getStep (  )  . getType (  )  )  )  { return false; } return super . canActivate ( playerId, game ) ; } @Override public String getRule (  )  { return "Sacrifice a creature: Destroy target artifact .  Activate this ability only during your upkeep and only once each turn . "; } } 
public class IvoryTower extends CardImpl { public IvoryTower ( UUID ownerId )  { super ( ownerId, 18, "Ivory Tower", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new IvoryTowerEffect (  ) , TargetController . YOU, false )  ) ; } public IvoryTower ( final IvoryTower card )  { super ( card ) ; } @Override public IvoryTower copy (  )  { return new IvoryTower ( this ) ; } } class IvoryTowerEffect extends OneShotEffect { public IvoryTowerEffect (  )  { super ( Outcome . GainLife ) ; this . staticText = "you gain X life, where X is the number of cards in your hand minus 4 . "; } public IvoryTowerEffect ( IvoryTowerEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if ( player != null )  { int amount = player . getHand (  )  . size (  )  - 4; if ( amount > 0 )  { player . gainLife ( amount, game ) ; } return true; } return false; } @Override public IvoryTowerEffect copy (  )  { return new IvoryTowerEffect ( this ) ; } } 
public class Mightstone extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "attacking creatures" ) ; static { filter . add ( new AttackingPredicate (  )  ) ; } public Mightstone ( UUID ownerId )  { super ( ownerId, 20, "Mightstone", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostAllEffect (  1, 0, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public Mightstone ( final Mightstone card )  { super ( card ) ; } @Override public Mightstone copy (  )  { return new Mightstone ( this ) ; } } 
public class OrcishMechanics extends CardImpl { public OrcishMechanics ( UUID ownerId )  { super ( ownerId, 92, "Orcish Mechanics", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Orc" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 2 ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( new FilterControlledArtifactPermanent ( "an artifact" )  )  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public OrcishMechanics ( final OrcishMechanics card )  { super ( card ) ; } @Override public OrcishMechanics copy (  )  { return new OrcishMechanics ( this ) ; } } 
public class PhyrexianGremlins extends CardImpl { public PhyrexianGremlins ( UUID ownerId )  { super ( ownerId, 48, "Phyrexian Gremlins", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Gremlin" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetArtifactPermanent (  )  ) ; ability . addEffect ( new DontUntapAsLongAsSourceTappedEffect (  )  ) ; this . addAbility ( ability ) ; } public PhyrexianGremlins ( final PhyrexianGremlins card )  { super ( card ) ; } @Override public PhyrexianGremlins copy (  )  { return new PhyrexianGremlins ( this ) ; } } 
public class PowerArtifact extends CardImpl { public PowerArtifact ( UUID ownerId )  { super ( ownerId, 55, "Power Artifact", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{U}{U}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetArtifactPermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Benefit )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new PowerArtifactCostModificationEffect (  )  )  ) ; } public PowerArtifact ( final PowerArtifact card )  { super ( card ) ; } @Override public PowerArtifact copy (  )  { return new PowerArtifact ( this ) ; } } class PowerArtifactCostModificationEffect extends CostModificationEffectImpl { PowerArtifactCostModificationEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "The activation cost of target artifact is reduced by {2} .  If this would reduce target artifact's activation cost below {1}, target artifact's activation cost becomes {1} .  Power artifact has no effect on artifacts that have no activation cost or whose activation cost is {0} . "; } PowerArtifactCostModificationEffect ( PowerArtifactCostModificationEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { Player controller = game . getPlayer ( abilityToModify . getControllerId (  )  ) ; if  ( controller != null )  { Mana mana = abilityToModify . getManaCostsToPay (  )  . getMana (  ) ; int reduce = mana . getGeneric (  ) ; if  ( reduce > 0 && mana . count (  )  == mana . getGeneric (  )  )  { reduce--; } if  ( reduce > 2 )  { reduce = 2; } CardUtil . reduceCost ( abilityToModify, reduce ) ; } return true; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { Permanent artifact = game . getPermanent ( abilityToModify . getSourceId (  )  ) ; if  ( artifact != null && artifact . getAttachments (  )  . contains ( source . getSourceId (  )  )  )  { if  ( abilityToModify . getAbilityType (  )  . equals ( AbilityType . ACTIVATED )  ||  ( abilityToModify . getAbilityType (  )  . equals ( AbilityType . MANA )  &&  ( abilityToModify instanceof ActivatedAbility )  )  )  { return true; } } return false; } @Override public PowerArtifactCostModificationEffect copy (  )  { return new PowerArtifactCostModificationEffect ( this ) ; } } 
public class SageOfLatNam extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an Artifact" ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; } public SageOfLatNam ( UUID ownerId )  { super ( ownerId, 57, "Sage of Lat-Nam", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Artificer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public SageOfLatNam ( final SageOfLatNam card )  { super ( card ) ; } @Override public SageOfLatNam copy (  )  { return new SageOfLatNam ( this ) ; } } 
public class TransmuteArtifact extends CardImpl { public TransmuteArtifact ( UUID ownerId )  { super ( ownerId, 58, "Transmute Artifact", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{U}{U}" ) ; this . expansionSetCode = "ATQ"; this . getSpellAbility (  )  . addEffect ( new TransmuteArtifactEffect (  )  ) ; } public TransmuteArtifact ( final TransmuteArtifact card )  { super ( card ) ; } @Override public TransmuteArtifact copy (  )  { return new TransmuteArtifact ( this ) ; } } class TransmuteArtifactEffect extends SearchEffect { public TransmuteArtifactEffect (  )  { super ( new TargetCardInLibrary ( new FilterArtifactCard (  )  ) , Outcome . PutCardInPlay ) ; staticText = "Sacrifice an artifact .  If you do, search your library for an artifact card .  If that card's converted mana cost is less than or equal to the sacrificed artifact's converted mana cost, put it onto the battlefield .  If it's greater, you may pay {X}, where X is the difference .  If you do, put it onto the battlefield .  If you don't, put it into its owner's graveyard .  Then shuffle your library"; } public TransmuteArtifactEffect ( final TransmuteArtifactEffect effect )  { super ( effect ) ; } @Override public TransmuteArtifactEffect copy (  )  { return new TransmuteArtifactEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } int convertedManaCost = 0; boolean sacrifice = false; TargetControlledPermanent targetArtifact = new TargetControlledPermanent ( new FilterControlledArtifactPermanent (  )  ) ; if  ( controller . chooseTarget ( Outcome . Sacrifice, targetArtifact, source, game )  )  { Permanent permanent = game . getPermanent ( targetArtifact . getFirstTarget (  )  ) ; if  ( permanent != null )  { convertedManaCost = permanent . getManaCost (  )  . convertedManaCost (  ) ; sacrifice = permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } else { return true; } if  ( sacrifice && controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { for  ( UUID cardId : target . getTargets (  )  )  { Card card = controller . getLibrary (  )  . getCard ( cardId, game ) ; if  ( card != null )  { if  ( card . getManaCost (  )  . convertedManaCost (  )  <= convertedManaCost )  { controller . moveCards ( card, Zone . BATTLEFIELD, source, game ) ; } else { GenericManaCost cost = new GenericManaCost ( card . getManaCost (  )  . convertedManaCost (  )  - convertedManaCost ) ; if  ( cost . pay ( source, game, source . getSourceId (  ) , source . getControllerId (  ) , false )  )  { controller . moveCards ( card, Zone . BATTLEFIELD, source, game ) ; } else { controller . moveCards ( card, Zone . GRAVEYARD, source, game ) ; } } } } } controller . shuffleLibrary ( game ) ; return true; } controller . shuffleLibrary ( game ) ; return false; } } 
public class Weakstone extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "attacking creatures" ) ; static { filter . add ( new AttackingPredicate (  )  ) ; } public Weakstone ( UUID ownerId )  { super ( ownerId, 43, "Weakstone", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostAllEffect (  -1, 0, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public Weakstone ( final Weakstone card )  { super ( card ) ; } @Override public Weakstone copy (  )  { return new Weakstone ( this ) ; } } 
public class AEtherMutation extends CardImpl { public AEtherMutation ( UUID ownerId )  { super ( ownerId, 91, "AEther Mutation", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{G}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new SaprolingToken (  ) , new TargetConvertedManaCost (  )  )  ) ; } public AEtherMutation ( final AEtherMutation card )  { super ( card ) ; } @Override public AEtherMutation copy (  )  { return new AEtherMutation ( this ) ; } } 
public class AnaDisciple extends CardImpl { public AnaDisciple ( UUID ownerId )  { super ( ownerId, 73, "Ana Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilityTargetEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . U )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . B )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( secondAbility ) ; } public AnaDisciple ( final AnaDisciple card )  { super ( card ) ; } @Override public AnaDisciple copy (  )  { return new AnaDisciple ( this ) ; } } 
public class Anavolver extends CardImpl { public Anavolver ( UUID ownerId )  { super ( ownerId, 75, "Anavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{U}" ) ; kickerAbility . addKickerCost ( "{B}" ) ; this . addAbility ( kickerAbility ) ; EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) ,false ) , new KickedCostCondition ( "{1}{U}" ) , "If {this} was kicked with its {1}{U} kicker, it enters the battlefield with two +1/+1 counters on it and with flying . ", "{this} enters the battlefield with two +1/+1 counters on it and with flying" ) ;  (  ( EntersBattlefieldEffect ) ability1 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability1 ) ; EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 ) ,false ) , new KickedCostCondition ( "{B}" ) , "If {this} was kicked with its {B} kicker, it enters the battlefield with a +1/+1 counter on it and with \"Pay 3 life: Regenerate Anavolver . \"", "{this} enters the battlefield with a +1/+1 counter on it and with \"Pay 3 life: Regenerate Anavolver . \"" ) ;  (  ( EntersBattlefieldEffect ) ability2 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new PayLifeCost ( 3 )  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability2 ) ; } public Anavolver ( final Anavolver card )  { super ( card ) ; } @Override public Anavolver copy (  )  { return new Anavolver ( this ) ; } } 
public class AngelfireCrusader extends CardImpl { public AngelfireCrusader ( UUID ownerId )  { super ( ownerId, 1, "Angelfire Crusader", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  )  ) ; } public AngelfireCrusader ( final AngelfireCrusader card )  { super ( card ) ; } @Override public AngelfireCrusader copy (  )  { return new AngelfireCrusader ( this ) ; } } 
public class BattlefieldForge extends CardImpl { public BattlefieldForge ( UUID ownerId )  { super ( ownerId, 139, "Battlefield Forge", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability redManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . RedMana ( 1 ) , new TapSourceCost (  )  ) ; redManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( redManaAbility ) ; Ability whiteManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . WhiteMana ( 1 ) , new TapSourceCost (  )  ) ; whiteManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( whiteManaAbility ) ; } public BattlefieldForge ( final BattlefieldForge card )  { super ( card ) ; } @Override public BattlefieldForge copy (  )  { return new BattlefieldForge ( this ) ; } } 
public class BloodfireColossus extends CardImpl { public BloodfireColossus ( UUID ownerId )  { super ( ownerId, 55, "Bloodfire Colossus", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{R}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Giant" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageEverythingEffect ( 6 ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BloodfireColossus ( final BloodfireColossus card )  { super ( card ) ; } @Override public BloodfireColossus copy (  )  { return new BloodfireColossus ( this ) ; } } 
public class BloodfireDwarf extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature without flying" ) ; static { filter . add ( Predicates . not ( new AbilityPredicate ( FlyingAbility . class )  )  ) ; } public BloodfireDwarf ( UUID ownerId )  { super ( ownerId, 56, "Bloodfire Dwarf", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Dwarf" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageAllEffect ( 1, filter ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BloodfireDwarf ( final BloodfireDwarf card )  { super ( card ) ; } @Override public BloodfireDwarf copy (  )  { return new BloodfireDwarf ( this ) ; } } 
public class BloodfireKavu extends CardImpl { public BloodfireKavu ( UUID ownerId )  { super ( ownerId, 58, "Bloodfire Kavu", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageAllEffect ( 2, new FilterCreaturePermanent (  )  ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BloodfireKavu ( final BloodfireKavu card )  { super ( card ) ; } @Override public BloodfireKavu copy (  )  { return new BloodfireKavu ( this ) ; } } 
public class BogGnarr extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "a black spell" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . BLACK )  ) ; } public BogGnarr ( UUID ownerId )  { super ( ownerId, 76, "Bog Gnarr", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SpellCastAllTriggeredAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , filter, false )  ) ; } public BogGnarr ( final BogGnarr card )  { super ( card ) ; } @Override public BogGnarr copy (  )  { return new BogGnarr ( this ) ; } } 
public class BrassHerald extends CardImpl { public BrassHerald ( UUID ownerId )  { super ( ownerId, 133, "Brass Herald", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{6}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new ChooseCreatureTypeEffect ( Outcome . BoostCreature )  )  ) ; FilterCard filter = new FilterCard ( "creature cards of the chosen type" ) ; filter . add ( new ChosenSubtypePredicate ( this . getId (  )  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; FilterCreaturePermanent filter2 = new FilterCreaturePermanent ( "creatures of the chosen type" ) ; filter2 . add ( new ChosenSubtypePredicate ( this . getId (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostAllEffect ( 1, 1, Duration . WhileOnBattlefield, filter2, false )  )  ) ; } public BrassHerald ( final BrassHerald card )  { super ( card ) ; } @Override public BrassHerald copy (  )  { return new BrassHerald ( this ) ; } } 
public class CavesOfKoilos extends CardImpl { public CavesOfKoilos ( UUID ownerId )  { super ( ownerId, 140, "Caves of Koilos", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability whiteManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . WhiteMana ( 1 ) , new TapSourceCost (  )  ) ; whiteManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( whiteManaAbility ) ; Ability blackManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlackMana ( 1 ) , new TapSourceCost (  )  ) ; blackManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blackManaAbility ) ; } public CavesOfKoilos ( final CavesOfKoilos card )  { super ( card ) ; } @Override public CavesOfKoilos copy (  )  { return new CavesOfKoilos ( this ) ; } } 
public class CetaDisciple extends CardImpl { public CetaDisciple ( UUID ownerId )  { super ( ownerId, 19, "Ceta Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new AnyColorManaAbility ( new ColoredManaCost ( ColoredManaSymbol . G )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( secondAbility ) ; } public CetaDisciple ( final CetaDisciple card )  { super ( card ) ; } @Override public CetaDisciple copy (  )  { return new CetaDisciple ( this ) ; } } 
public class Cetavolver extends CardImpl { public Cetavolver ( UUID ownerId )  { super ( ownerId, 21, "Cetavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{R}" ) ; kickerAbility . addKickerCost ( "{G}" ) ; this . addAbility ( kickerAbility ) ; EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) ,false ) , new KickedCostCondition ( "{1}{R}" ) , "If Cetavolver was kicked with its {1}{R} kicker, it enters the battlefield with two +1/+1 counters on it and with first strike . ", "{this} enters the battlefield with two +1/+1 counters on it and with first strike" ) ;  (  ( EntersBattlefieldEffect ) ability1 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( FirstStrikeAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability1 ) ; EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 ) ,false ) , new KickedCostCondition ( "{G}" ) , "If Cetavolver was kicked with its {G} kicker, it enters the battlefield with a +1/+1 counter on it and with trample . ", "{this} enters the battlefield with a +1/+1 counter on it and with trample" ) ;  (  ( EntersBattlefieldEffect ) ability2 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( TrampleAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability2 ) ; } public Cetavolver ( final Cetavolver card )  { super ( card ) ; } @Override public Cetavolver copy (  )  { return new Cetavolver ( this ) ; } } 
public class CoastalDrake extends CardImpl { public CoastalDrake ( UUID ownerId )  { super ( ownerId, 22, "Coastal Drake", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ReturnToHandTargetEffect ( true ) , new ManaCostsImpl ( "{1}{U}" )  ) ; ability . addTarget ( new TargetCreaturePermanent ( new FilterCreaturePermanent ( "Kavu", "Kavu" )  )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public CoastalDrake ( final CoastalDrake card )  { super ( card ) ; } @Override public CoastalDrake copy (  )  { return new CoastalDrake ( this ) ; } } 
public class ConsumeStrength extends CardImpl { public ConsumeStrength ( UUID ownerId )  { super ( ownerId, 93, "Consume Strength", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{B}{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new ConsumeStrengthEffect (  )  ) ; FilterCreaturePermanent filter1 = new FilterCreaturePermanent ( "creature to get +2/+2" ) ; TargetCreaturePermanent target1 = new TargetCreaturePermanent ( filter1 ) ; target1 . setTargetTag ( 1 ) ; this . getSpellAbility (  )  . addTarget ( target1 ) ; FilterCreaturePermanent filter2 = new FilterCreaturePermanent ( "another creature to get -2/-2" ) ; filter2 . add ( new AnotherTargetPredicate ( 2 )  ) ; TargetCreaturePermanent target2 = new TargetCreaturePermanent ( filter2 ) ; target2 . setTargetTag ( 2 ) ; this . getSpellAbility (  )  . addTarget ( target2 ) ; } public ConsumeStrength ( final ConsumeStrength card )  { super ( card ) ; } @Override public ConsumeStrength copy (  )  { return new ConsumeStrength ( this ) ; } } class ConsumeStrengthEffect extends ContinuousEffectImpl { public ConsumeStrengthEffect (  )  { super ( Duration . EndOfTurn, Layer . PTChangingEffects_7, SubLayer . ModifyPT_7c, Outcome . BoostCreature ) ; this . staticText = "Target creature gets +2/+2 until end of turn .  Another target creature gets -2/-2 until end of turn"; } public ConsumeStrengthEffect ( final ConsumeStrengthEffect effect )  { super ( effect ) ; } @Override public ConsumeStrengthEffect copy (  )  { return new ConsumeStrengthEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . addPower ( 2 ) ; permanent . addToughness ( 2 ) ; } permanent = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . addPower ( -2 ) ; permanent . addToughness ( -2 ) ; } return true; } } 
public class DeathGrasp extends CardImpl { public DeathGrasp  ( UUID ownerId )  { super ( ownerId, 95, "Death Grasp", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{W}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public DeathGrasp  ( final DeathGrasp card )  { super ( card ) ; } @Override public DeathGrasp copy (  )  { return new DeathGrasp ( this ) ; } } 
public class DeathMutation extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonblack creature" ) ; static { filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public DeathMutation ( UUID ownerId )  { super ( ownerId, 96, "Death Mutation", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{6}{B}{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new SaprolingToken (  ) , new TargetConvertedManaCost (  )  )  ) ; } public DeathMutation ( final DeathMutation card )  { super ( card ) ; } @Override public DeathMutation copy (  )  { return new DeathMutation ( this ) ; } } 
public class DegaDisciple extends CardImpl { public DegaDisciple ( UUID ownerId )  { super ( ownerId, 4, "Dega Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . B )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( secondAbility ) ; } public DegaDisciple ( final DegaDisciple card )  { super ( card ) ; } @Override public DegaDisciple copy (  )  { return new DegaDisciple ( this ) ; } } 
public class Degavolver extends CardImpl { public Degavolver ( UUID ownerId )  { super ( ownerId, 6, "Degavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{B}" ) ; kickerAbility . addKickerCost ( "{R}" ) ; this . addAbility ( kickerAbility ) ; EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) ,false ) , new KickedCostCondition ( "{1}{B}" ) , "If Degavolver was kicked with its {1}{B} kicker, it enters the battlefield with two +1/+1 counters on it and with \"Pay 3 life: Regenerate Degavolver . \"", "{this} enters the battlefield with two +1/+1 counters on it and with \"Pay 3 life: Regenerate Degavolver . \"" ) ;  (  ( EntersBattlefieldEffect ) ability1 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new PayLifeCost ( 3 )  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability1 ) ; EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 ) ,false ) , new KickedCostCondition ( "{R}" ) , "If Degavolver was kicked with its {R} kicker, it enters the battlefield with a +1/+1 counter on it and with first strike . ", "{this} enters the battlefield with a +1/+1 counter on it and with first strike" ) ;  (  ( EntersBattlefieldEffect ) ability2 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( FirstStrikeAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability2 ) ; } public Degavolver ( final Degavolver card )  { super ( card ) ; } @Override public Degavolver copy (  )  { return new Degavolver ( this ) ; } } 
public class DesolationAngel extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent ( "lands" ) ; private static final FilterLandPermanent filter2 = new FilterLandPermanent ( "lands you control" ) ; static { filter2 . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DesolationAngel ( UUID ownerId )  { super ( ownerId, 38, "Desolation Angel", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new KickerAbility ( "{W}{W}" )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ConditionalOneShotEffect ( new DestroyAllEffect ( filter ) , new DestroyAllEffect ( filter2 ) , KickedCondition . getInstance (  ) , "destroy all lands you control .  If it was kicked, destroy all lands instead . " )  )  ) ; } public DesolationAngel ( final DesolationAngel card )  { super ( card ) ; } @Override public DesolationAngel copy (  )  { return new DesolationAngel ( this ) ; } } 
public class DesolationGiant extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "other creatures" ) ; private static final FilterCreaturePermanent filter2 = new FilterCreaturePermanent ( "other creatures you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter2 . add ( new AnotherPredicate (  )  ) ; filter2 . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DesolationGiant ( UUID ownerId )  { super ( ownerId, 59, "Desolation Giant", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Giant" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new KickerAbility ( "{W}{W}" )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ConditionalOneShotEffect ( new DestroyAllEffect ( filter ) , new DestroyAllEffect ( filter2 ) , KickedCondition . getInstance (  ) , "destroy all other creatures you control .  If it was kicked, destroy all other creatures instead . " )  )  ) ; } public DesolationGiant ( final DesolationGiant card )  { super ( card ) ; } @Override public DesolationGiant copy (  )  { return new DesolationGiant ( this ) ; } } 
public class DiversionaryTactics extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creatures you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public DiversionaryTactics ( UUID ownerId )  { super ( ownerId, 7, "Diversionary Tactics", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new TapTargetCost ( new TargetControlledCreaturePermanent ( 2, 2, filter, false )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public DiversionaryTactics ( final DiversionaryTactics card )  { super ( card ) ; } @Override public DiversionaryTactics copy (  )  { return new DiversionaryTactics ( this ) ; } } 
public class DivineLight extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creatures you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DivineLight ( UUID ownerId )  { super ( ownerId, 8, "Divine Light", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{W}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new PreventAllDamageToAllEffect ( Duration . EndOfTurn, filter )  ) ; } public DivineLight ( final DivineLight card )  { super ( card ) ; } @Override public DivineLight copy (  )  { return new DivineLight ( this ) ; } } 
public class Dodecapod extends CardImpl { public Dodecapod ( UUID ownerId )  { super ( ownerId, 134, "Dodecapod", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . HAND, new DodecapodEffect (  )  )  ) ; } public Dodecapod ( final Dodecapod card )  { super ( card ) ; } @Override public Dodecapod copy (  )  { return new Dodecapod ( this ) ; } } class DodecapodEffect extends DiscardOntoBattlefieldEffect { public DodecapodEffect (  )  { super (  ) ; staticText = "If a spell or ability an opponent controls causes you to discard {this}, put it onto the battlefield with two +1/+1 counters on it instead of putting it into your graveyard"; } public DodecapodEffect ( final DodecapodEffect effect )  { super ( effect ) ; } @Override public DodecapodEffect copy (  )  { return new DodecapodEffect ( this ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { if ( super . replaceEvent ( event, source, game )  )  { new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  )  . apply ( game, source ) ; return true; } return false; } } 
public class DragonArch extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "a multicolored creature card" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public DragonArch ( UUID ownerId )  { super ( ownerId, 135, "Dragon Arch", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{5}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PutPermanentOnBattlefieldEffect ( filter ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public DragonArch ( final DragonArch card )  { super ( card ) ; } @Override public DragonArch copy (  )  { return new DragonArch ( this ) ; } } 
public class DwarvenLandslide extends CardImpl { public DwarvenLandslide ( UUID ownerId )  { super ( ownerId, 60, "Dwarven Landslide", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{R}" ) ; this . expansionSetCode = "APC"; Costs<Cost> kickerCosts = new CostsImpl<> (  ) ; kickerCosts . add ( new ManaCostsImpl<> ( "{2}{R}" )  ) ; kickerCosts . add ( new SacrificeTargetCost ( new TargetControlledPermanent ( new FilterControlledLandPermanent ( "a land" )  )  )  ) ; this . addAbility ( new KickerAbility ( kickerCosts )  ) ; getSpellAbility (  )  . addEffect ( new DestroyTargetEffect ( "Destroy target land .  If {this} was kicked, destroy another target land" )  ) ; getSpellAbility (  )  . addTarget ( new TargetLandPermanent (  )  ) ; } public DwarvenLandslide ( final DwarvenLandslide card )  { super ( card ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SpellAbility )  { if  ( KickedCondition . getInstance (  )  . apply ( game, ability )  )  { getSpellAbility (  )  . addTarget ( new TargetLandPermanent ( new FilterLandPermanent ( "land  ( Kicker ) " )  )  ) ; } } } @Override public DwarvenLandslide copy (  )  { return new DwarvenLandslide ( this ) ; } } 
public class DwarvenPatrol extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "nonred spell" ) ; static { filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . RED )  )  ) ; } public DwarvenPatrol ( UUID ownerId )  { super ( ownerId, 61, "Dwarven Patrol", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Dwarf" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DontUntapInControllersUntapStepSourceEffect (  )  )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new UntapSourceEffect (  ) , filter, false )  ) ; } public DwarvenPatrol ( final DwarvenPatrol card )  { super ( card ) ; } @Override public DwarvenPatrol copy (  )  { return new DwarvenPatrol ( this ) ; } } 
public class EbonyTreefolk extends CardImpl { public EbonyTreefolk ( UUID ownerId )  { super ( ownerId, 97, "Ebony Treefolk", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Treefolk" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , new ManaCostsImpl ( "{B}{G}" )  )  ) ; } public EbonyTreefolk ( final EbonyTreefolk card )  { super ( card ) ; } @Override public EbonyTreefolk copy (  )  { return new EbonyTreefolk ( this ) ; } } 
public class EnlistmentOfficer extends CardImpl { private static final FilterCard filter = new FilterCard ( "Soldier cards" ) ; static { filter . add ( new SubtypePredicate ( "Soldier" )  ) ; } public EnlistmentOfficer ( UUID ownerId )  { super ( ownerId, 9, "Enlistment Officer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public EnlistmentOfficer ( final EnlistmentOfficer card )  { super ( card ) ; } @Override public EnlistmentOfficer copy (  )  { return new EnlistmentOfficer ( this ) ; } } 
public class EvasiveAction extends CardImpl { public EvasiveAction ( UUID ownerId )  { super ( ownerId, 23, "Evasive Action", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new CounterUnlessPaysEffect ( new DomainValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell (  )  ) ; } public EvasiveAction ( final EvasiveAction card )  { super ( card ) ; } @Override public EvasiveAction copy (  )  { return new EvasiveAction ( this ) ; } } 
public class FerventCharge extends CardImpl { public FerventCharge ( UUID ownerId )  { super ( ownerId, 98, "Fervent Charge", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{B}{R}" ) ; this . expansionSetCode = "APC"; Effect effect = new BoostTargetEffect ( 2, 2, Duration . EndOfTurn ) ; effect . setText ( "it gets +2/+2 until end of turn" ) ; this . addAbility ( new AttacksCreatureYouControlTriggeredAbility ( effect, false, true )  ) ; } public FerventCharge ( final FerventCharge card )  { super ( card ) ; } @Override public FerventCharge copy (  )  { return new FerventCharge ( this ) ; } } 
public class FlowstoneCharger extends CardImpl { public FlowstoneCharger ( UUID ownerId )  { super ( ownerId, 99, "Flowstone Charger", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( 3, -3, Duration . EndOfTurn ) , false )  ) ; } public FlowstoneCharger ( final FlowstoneCharger card )  { super ( card ) ; } @Override public FlowstoneCharger copy (  )  { return new FlowstoneCharger ( this ) ; } } 
public class FoulPresence extends CardImpl { public FoulPresence ( UUID ownerId )  { super ( ownerId, 39, "Foul Presence", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . UnboostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( -1, -1, Duration . WhileOnBattlefield )  ) ; Ability gainedAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -1, -1, Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; gainedAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA, Duration . WhileOnBattlefield ) ; effect . setText ( "and has \"{T}: Target creature gets -1/-1 until end of turn . \"" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public FoulPresence ( final FoulPresence card )  { super ( card ) ; } @Override public FoulPresence copy (  )  { return new FoulPresence ( this ) ; } } 
public class GerrardCapashen extends CardImpl { public GerrardCapashen ( UUID ownerId )  { super ( ownerId, 11, "Gerrard Capashen", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{W}{W}" ) ; this . expansionSetCode = "APC"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability1 = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new GerrardCapashenEffect (  ) , TargetController . YOU, false, true ) ; ability1 . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability1 ) ; Ability ability2 = new ActivateIfConditionActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new ManaCostsImpl ( "{3}{W}" ) , new SourceAttackingCondition (  )  ) ; ability2 . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability2 ) ; } public GerrardCapashen ( final GerrardCapashen card )  { super ( card ) ; } @Override public GerrardCapashen copy (  )  { return new GerrardCapashen ( this ) ; } } class GerrardCapashenEffect extends OneShotEffect { public GerrardCapashenEffect (  )  { super ( Outcome . GainLife ) ; staticText = "you gain 1 life for each card in target opponent's hand . "; } public GerrardCapashenEffect ( final GerrardCapashenEffect effect )  { super ( effect ) ; } @Override public GerrardCapashenEffect copy (  )  { return new GerrardCapashenEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetOpponent = game . getPlayer ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && targetOpponent != null )  { int cardsInHand = targetOpponent . getHand (  )  . size (  ) ; if  ( cardsInHand > 0 )  { controller . gainLife ( cardsInHand, game ) ; } return true; } return false; } } 
public class GerrardsVerdict extends CardImpl { public GerrardsVerdict ( UUID ownerId )  { super ( ownerId, 102, "Gerrard's Verdict", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{W}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new GerrardsVerdictEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public GerrardsVerdict ( final GerrardsVerdict card )  { super ( card ) ; } @Override public GerrardsVerdict copy (  )  { return new GerrardsVerdict ( this ) ; } } class GerrardsVerdictEffect extends OneShotEffect { public GerrardsVerdictEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "Target player discards two cards .  You gain 3 life for each land card discarded this way"; } public GerrardsVerdictEffect ( final GerrardsVerdictEffect effect )  { super ( effect ) ; } @Override public GerrardsVerdictEffect copy (  )  { return new GerrardsVerdictEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && targetPlayer != null )  { controller . gainLife ( targetPlayer . discard ( 2, false, source, game )  . count ( new FilterLandCard (  ) , game )  * 3, game ) ; return true; } return false; } } 
public class GladeGnarr extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "a blue spell" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; } public GladeGnarr ( UUID ownerId )  { super ( ownerId, 78, "Glade Gnarr", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SpellCastAllTriggeredAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , filter, false )  ) ; } public GladeGnarr ( final GladeGnarr card )  { super ( card ) ; } @Override public GladeGnarr copy (  )  { return new GladeGnarr ( this ) ; } } 
public class GoblinLegionnaire extends CardImpl { public GoblinLegionnaire ( UUID ownerId )  { super ( ownerId, 103, "Goblin Legionnaire", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 2 ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; firstAbility . addCost ( new SacrificeSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 2 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; secondAbility . addCost ( new SacrificeSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( secondAbility ) ; } public GoblinLegionnaire ( final GoblinLegionnaire card )  { super ( card ) ; } @Override public GoblinLegionnaire copy (  )  { return new GoblinLegionnaire ( this ) ; } } 
public class GoblinRingleader extends CardImpl { private static final FilterCard filter = new FilterCard ( "Goblin cards" ) ; static { filter . add ( new SubtypePredicate ( "Goblin" )  ) ; } public GoblinRingleader ( UUID ownerId )  { super ( ownerId, 62, "Goblin Ringleader", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Goblin" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public GoblinRingleader ( final GoblinRingleader card )  { super ( card ) ; } @Override public GoblinRingleader copy (  )  { return new GoblinRingleader ( this ) ; } } 
public class GoblinTrenches extends CardImpl { final static FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a land" ) ; public GoblinTrenches ( UUID ownerId )  { super ( ownerId, 104, "Goblin Trenches", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}{W}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new GoblinTrenchesToken (  ) , 2 ) , new GenericManaCost ( 2 )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public GoblinTrenches ( final GoblinTrenches card )  { super ( card ) ; } @Override public GoblinTrenches copy (  )  { return new GoblinTrenches ( this ) ; } } class GoblinTrenchesToken extends Token { GoblinTrenchesToken (  )  { super ( "Goblin Soldier", "1/1 red and white Goblin Soldier creature tokens" ) ; cardType . add ( CardType . CREATURE ) ; color . setRed ( true ) ; color . setWhite ( true ) ; subtype . add ( "Goblin" ) ; subtype . add ( "Soldier" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; } } 
public class GraveDefiler extends CardImpl { private static final FilterCard filter = new FilterCard ( "Zombie cards" ) ; static { filter . add ( new SubtypePredicate ( "Zombie" )  ) ; } public GraveDefiler ( UUID ownerId )  { super ( ownerId, 40, "Grave Defiler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{1}{B}" )  )  ) ; } public GraveDefiler ( final GraveDefiler card )  { super ( card ) ; } @Override public GraveDefiler copy (  )  { return new GraveDefiler ( this ) ; } } 
public class HauntedAngel extends CardImpl { public HauntedAngel ( UUID ownerId )  { super ( ownerId, 12, "Haunted Angel", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new DiesTriggeredAbility ( new ExileSourceEffect (  )  ) ; ability . addEffect ( new HauntedAngelEffect (  )  ) ; this . addAbility ( ability ) ; } public HauntedAngel ( final HauntedAngel card )  { super ( card ) ; } @Override public HauntedAngel copy (  )  { return new HauntedAngel ( this ) ; } } class HauntedAngelEffect extends OneShotEffect { public HauntedAngelEffect (  )  { super ( Outcome . Detriment ) ; staticText = "and each other player puts a 3/3 black Angel creature token with flying onto the battlefield . "; } public HauntedAngelEffect ( HauntedAngelEffect copy )  { super ( copy ) ; } @Override public HauntedAngelEffect copy (  )  { return new HauntedAngelEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID controllerId = source . getControllerId (  ) ; HauntedAngelToken token = new HauntedAngelToken (  ) ; for ( UUID playerId: game . getState (  )  . getPlayersInRange ( controllerId, game )  )  { if ( !playerId . equals ( controllerId )  )  { token . putOntoBattlefield ( 1, game, source . getSourceId (  ) , playerId ) ; } } return true; } } class HauntedAngelToken extends Token { public HauntedAngelToken (  )  { super ( "Angel", "3/3 black Angel creature token with flying" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Angel" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class Helionaut extends CardImpl { public Helionaut ( UUID ownerId )  { super ( ownerId, 13, "Helionaut", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new AnyColorManaAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public Helionaut ( final Helionaut card )  { super ( card ) ; } @Override public Helionaut copy (  )  { return new Helionaut ( this ) ; } } 
public class Illuminate extends CardImpl { public Illuminate ( UUID ownerId )  { super ( ownerId, 63, "Illuminate", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{X}{R}" ) ; this . expansionSetCode = "APC"; KickerAbility kickerAbility = new KickerAbility ( "{2}{R}" ) ; kickerAbility . addKickerCost ( "{3}{U}" ) ; this . addAbility ( kickerAbility ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new DamageTargetControllerEffect ( new ManacostVariableValue (  )  ) , new KickedCostCondition ( "{2}{R}" ) , "If {this} was kicked with its {2}{R} kicker, it deals X damage to that creature's controller . " )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new DrawCardSourceControllerEffect ( new ManacostVariableValue (  )  ) , new KickedCostCondition ( "{3}{U}" ) , "If {this} was kicked with its {3}{U} kicker, you draw X cards . " )  ) ; } public Illuminate ( final Illuminate card )  { super ( card ) ; } @Override public Illuminate copy (  )  { return new Illuminate ( this ) ; } } 
public class Index extends CardImpl { public Index ( UUID ownerId )  { super ( ownerId, 25, "Index", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new LookLibraryControllerEffect ( 5 )  ) ; } public Index ( final Index card )  { super ( card ) ; } @Override public Index copy (  )  { return new Index ( this ) ; } } 
public class Jilt extends CardImpl { public Jilt ( UUID ownerId )  { super ( ownerId, 27, "Jilt", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new KickerAbility ( "{1}{R}" )  ) ; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; Effect effect = new ConditionalOneShotEffect (  new DamageTargetEffect ( 2 ) , KickedCondition . getInstance (  ) , "If {this} was kicked, it deals 2 damage to another target creature" ) ; effect . setTargetPointer ( new SecondTargetPointer (  )  ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SpellAbility && KickedCondition . getInstance (  )  . apply ( game, ability )  )  { ability . addTarget ( new TargetOtherCreaturePermanent ( new FilterCreaturePermanent ( "another target creature" )  )  ) ; } } public Jilt ( final Jilt card )  { super ( card ) ; } @Override public Jilt copy (  )  { return new Jilt ( this ) ; } } class TargetOtherCreaturePermanent extends TargetCreaturePermanent { public TargetOtherCreaturePermanent ( FilterCreaturePermanent filter )  { super ( filter ) ; } public TargetOtherCreaturePermanent ( final TargetOtherCreaturePermanent target )  { super ( target ) ; } @Override public boolean canTarget ( UUID controllerId, UUID id, Ability source, Game game )  { if  ( source . getTargets (  )  . get ( 0 )  . getTargets (  )  . contains ( id )  )  { return false; } return super . canTarget ( controllerId, id, source, game ) ; } @Override public TargetOtherCreaturePermanent copy (  )  { return new TargetOtherCreaturePermanent ( this ) ; } } 
public class JungleBarrier extends CardImpl { public JungleBarrier ( UUID ownerId )  { super ( ownerId, 106, "Jungle Barrier", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Plant" ) ; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; } public JungleBarrier ( final JungleBarrier card )  { super ( card ) ; } @Override public JungleBarrier copy (  )  { return new JungleBarrier ( this ) ; } } 
public class KavuGlider extends CardImpl { public KavuGlider ( UUID ownerId )  { super ( ownerId, 64, "Kavu Glider", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 0, 1, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . W )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . U )  )  ) ; } public KavuGlider ( final KavuGlider card )  { super ( card ) ; } @Override public KavuGlider copy (  )  { return new KavuGlider ( this ) ; } } 
public class KavuHowler extends CardImpl { private static final FilterCard filter = new FilterCard ( "Kavu cards" ) ; static { filter . add ( new SubtypePredicate ( "Kavu" )  ) ; } public KavuHowler ( UUID ownerId )  { super ( ownerId, 79, "Kavu Howler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public KavuHowler ( final KavuHowler card )  { super ( card ) ; } @Override public KavuHowler copy (  )  { return new KavuHowler ( this ) ; } } 
public class KavuMauler extends CardImpl { private static final FilterAttackingCreature filter = new FilterAttackingCreature ( "other attacking Kavu" ) ; static { filter . add ( new SubtypePredicate ( "Kavu" )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public KavuMauler ( UUID ownerId )  { super ( ownerId, 80, "Kavu Mauler", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount ( filter ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( value, value, Duration . EndOfTurn, true ) , false )  ) ; } public KavuMauler ( final KavuMauler card )  { super ( card ) ; } @Override public KavuMauler copy (  )  { return new KavuMauler ( this ) ; } } 
public class LastCaress extends CardImpl { public LastCaress ( UUID ownerId )  { super ( ownerId, 41, "Last Caress", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new LoseLifeTargetEffect ( 1 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 1 )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public LastCaress ( final LastCaress card )  { super ( card ) ; } @Override public LastCaress copy (  )  { return new LastCaress ( this ) ; } } 
public class LayOfTheLand extends CardImpl { private static final FilterBasicLandCard filter = new FilterBasicLandCard (  ) ; public LayOfTheLand ( UUID ownerId )  { super ( ownerId, 81, "Lay of the Land", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( 1, 1, filter ) , true )  ) ; } public LayOfTheLand ( final LayOfTheLand card )  { super ( card ) ; } @Override public LayOfTheLand copy (  )  { return new LayOfTheLand ( this ) ; } } 
public class LivingAirship extends CardImpl { public LivingAirship ( UUID ownerId )  { super ( ownerId, 28, "Living Airship", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Metathran" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{2}{G}" )  )  ) ; } public LivingAirship ( final LivingAirship card )  { super ( card ) ; } @Override public LivingAirship copy (  )  { return new LivingAirship ( this ) ; } } 
public class LlanowarDead extends CardImpl { public LlanowarDead ( UUID ownerId )  { super ( ownerId, 109, "Llanowar Dead", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Elf" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public LlanowarDead ( final LlanowarDead card )  { super ( card ) ; } @Override public LlanowarDead copy (  )  { return new LlanowarDead ( this ) ; } } 
public class LlanowarWastes extends CardImpl { public LlanowarWastes ( UUID ownerId )  { super ( ownerId, 141, "Llanowar Wastes", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability blackManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlackMana ( 1 ) , new TapSourceCost (  )  ) ; blackManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blackManaAbility ) ; Ability greenManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . GreenMana ( 1 ) , new TapSourceCost (  )  ) ; greenManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( greenManaAbility ) ; } public LlanowarWastes ( final LlanowarWastes card )  { super ( card ) ; } @Override public LlanowarWastes copy (  )  { return new LlanowarWastes ( this ) ; } } 
public class ManaclesOfDecay extends CardImpl { public ManaclesOfDecay ( UUID ownerId )  { super ( ownerId, 14, "Manacles of Decay", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantAttackAttachedEffect ( AttachmentType . AURA )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( -1, -1, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . B )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBlockAttachedEffect ( AttachmentType . AURA, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  )  ) ; } public ManaclesOfDecay ( final ManaclesOfDecay card )  { super ( card ) ; } @Override public ManaclesOfDecay copy (  )  { return new ManaclesOfDecay ( this ) ; } } 
public class MartyrsTomb extends CardImpl { public MartyrsTomb ( UUID ownerId )  { super ( ownerId, 110, "Martyrs' Tomb", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{W}{B}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 1 ) , new PayLifeCost ( 2 )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MartyrsTomb ( final MartyrsTomb card )  { super ( card ) ; } @Override public MartyrsTomb copy (  )  { return new MartyrsTomb ( this ) ; } } 
public class MaskOfIntolerance extends CardImpl { public MaskOfIntolerance ( UUID ownerId )  { super ( ownerId, 138, "Mask of Intolerance", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "APC"; TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 3 ) , TargetController . ANY, false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, new MaskOfIntoleranceCondition (  ) , "At the beginning of each player's upkeep, if there are four or more basic land types among lands that player controls, {this} deals 3 damage to him or her . " )  ) ; } public MaskOfIntolerance ( final MaskOfIntolerance card )  { super ( card ) ; } @Override public MaskOfIntolerance copy (  )  { return new MaskOfIntolerance ( this ) ; } } class MaskOfIntoleranceCondition extends IntCompareCondition { public MaskOfIntoleranceCondition (  )  { super ( ComparisonType . GreaterThan, 3 ) ; } @Override protected int getInputValue ( Game game, Ability source )  { return new DomainValue ( 1, game . getActivePlayerId (  )  )  . calculate ( game, source, null ) ; } } 
public class MinotaurIllusionist extends CardImpl { public MinotaurIllusionist ( UUID ownerId )  { super ( ownerId, 111, "Minotaur Illusionist", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( ShroudAbility . getInstance (  ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{1}{U}" )  )  ) ; Effect effect = new DamageTargetEffect ( new SourcePermanentPowerCount (  )  ) ; effect . setText ( "{this} deals damage equal to its power to target creature . " ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{R}" )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MinotaurIllusionist ( final MinotaurIllusionist card )  { super ( card ) ; } @Override public MinotaurIllusionist copy (  )  { return new MinotaurIllusionist ( this ) ; } } 
public class MinotaurTactician extends CardImpl { private static final FilterControlledCreaturePermanent filterWhite = new FilterControlledCreaturePermanent (  ) ; private static final FilterControlledCreaturePermanent filterBlue = new FilterControlledCreaturePermanent (  ) ; static { filterWhite . add ( new ColorPredicate ( ObjectColor . WHITE )  ) ; filterBlue . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; } final private String ruleWhite = "{this} gets +1/+1 as long as you control another white creature"; final private String ruleBlue = "{this} gets +1/+1 as long as you control another white creature"; public MinotaurTactician ( UUID ownerId )  { super ( ownerId, 65, "Minotaur Tactician", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Minotaur" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Condition conditionWhite = new PermanentsOnTheBattlefieldCondition ( filterWhite, CountType . MORE_THAN, 0 ) ; Effect effectWhite = new ConditionalContinuousEffect ( new BoostSourceEffect ( 1, 1, Duration . WhileOnBattlefield ) , conditionWhite, ruleWhite ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effectWhite )  ) ; Condition conditionBlue = new PermanentsOnTheBattlefieldCondition ( filterBlue, CountType . MORE_THAN, 0 ) ; Effect effectBlue = new ConditionalContinuousEffect ( new BoostSourceEffect ( 1, 1, Duration . WhileOnBattlefield ) , conditionBlue, ruleBlue ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effectBlue )  ) ; } public MinotaurTactician ( final MinotaurTactician card )  { super ( card ) ; } @Override public MinotaurTactician copy (  )  { return new MinotaurTactician ( this ) ; } } 
public class MournfulZombie extends CardImpl { public MournfulZombie ( UUID ownerId )  { super ( ownerId, 43, "Mournful Zombie", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeTargetEffect ( 1 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPlayer ( 1 )  ) ; this . addAbility ( ability ) ; } public MournfulZombie ( final MournfulZombie card )  { super ( card ) ; } @Override public MournfulZombie copy (  )  { return new MournfulZombie ( this ) ; } } 
public class MysticSnake extends CardImpl { public MysticSnake ( UUID ownerId )  { super ( ownerId, 112, "Mystic Snake", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{U}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new CounterTargetEffect (  )  ) ; ability . addTarget ( new TargetSpell (  )  ) ; this . addAbility ( ability ) ; } public MysticSnake ( final MysticSnake card )  { super ( card ) ; } @Override public MysticSnake copy (  )  { return new MysticSnake ( this ) ; } } 
public class NecraDisciple extends CardImpl { public NecraDisciple ( UUID ownerId )  { super ( ownerId, 44, "Necra Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new AnyColorManaAbility ( new ColoredManaCost ( ColoredManaSymbol . G )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 1 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( secondAbility ) ; } public NecraDisciple ( final NecraDisciple card )  { super ( card ) ; } @Override public NecraDisciple copy (  )  { return new NecraDisciple ( this ) ; } } 
public class Necravolver extends CardImpl { public Necravolver ( UUID ownerId )  { super ( ownerId, 46, "Necravolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{G}" ) ; kickerAbility . addKickerCost ( "{W}" ) ; this . addAbility ( kickerAbility ) ; Ability ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  ) , new KickedCostCondition ( "{1}{G}" ) , "If {this} was kicked with its {1}{G} kicker, it enters the battlefield with two +1/+1 counters on it and with trample . ", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( TrampleAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 )  ) , new KickedCostCondition ( "{W}" ) , "If {this} was kicked with its {W} kicker, it enters the battlefield with a +1/+1 counter on it and with \"Whenever {this} deals damage, you gain that much life . \"", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( new DealsDamageGainLifeSourceTriggeredAbility (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; } public Necravolver ( final Necravolver card )  { super ( card ) ; } @Override public Necravolver copy (  )  { return new Necravolver ( this ) ; } } 
public class OrimsThunder extends CardImpl { public OrimsThunder ( UUID ownerId )  { super ( ownerId, 15, "Orim's Thunder", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{W}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new KickerAbility ( "{R}" )  ) ; this . getSpellAbility (  )  . addEffect ( new OrimsThunderEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( new FilterArtifactOrEnchantmentPermanent (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new OrimsThunderEffect2 (  ) , KickedCondition . getInstance (  ) , "If Orim's Thunder was kicked, it deals damage equal to that permanent's converted mana cost to target creature" )  ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SpellAbility )  { if  ( KickedCondition . getInstance (  )  . apply ( game, ability )  )  { ability . addTarget ( new TargetCreaturePermanent (  )  ) ; } } } public OrimsThunder ( final OrimsThunder card )  { super ( card ) ; } @Override public OrimsThunder copy (  )  { return new OrimsThunder ( this ) ; } } class OrimsThunderEffect2 extends OneShotEffect { OrimsThunderEffect2 (  )  { super ( Outcome . Damage ) ; } OrimsThunderEffect2 ( final OrimsThunderEffect2 effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { int damage = 0; MageObject firstTarget = game . getLastKnownInformation ( source . getFirstTarget (  ) , Zone . BATTLEFIELD ) ; Permanent secondTarget = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( firstTarget != null )  { damage = firstTarget . getManaCost (  )  . convertedManaCost (  ) ; } boolean kicked = KickedCondition . getInstance (  )  . apply ( game, source ) ; if  ( kicked && secondTarget != null )  { secondTarget . damage ( damage, source . getSourceId (  ) , game, false, true ) ; return true; } return false; } @Override public OrimsThunderEffect2 copy (  )  { return new OrimsThunderEffect2 ( this ) ; } } class OrimsThunderEffect extends OneShotEffect { OrimsThunderEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy target artifact or enchantment"; } OrimsThunderEffect ( final OrimsThunderEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent target = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( target != null )  { return target . destroy ( source . getSourceId (  ) , game, false ) ; } return false; } @Override public OrimsThunderEffect copy (  )  { return new OrimsThunderEffect ( this ) ; } } 
public class OvergrownEstate extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a land" ) ; public OvergrownEstate ( UUID ownerId )  { super ( ownerId, 113, "Overgrown Estate", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{B}{G}{W}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 3 ) , new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  ) ; } public OvergrownEstate ( final OvergrownEstate card )  { super ( card ) ; } @Override public OvergrownEstate copy (  )  { return new OvergrownEstate ( this ) ; } } 
public class PenumbraBobcat extends CardImpl { public PenumbraBobcat ( UUID ownerId )  { super ( ownerId, 82, "Penumbra Bobcat", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Cat" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new PenumbraBobcatToken (  ) , 1 ) , false )  ) ; } public PenumbraBobcat ( final PenumbraBobcat card )  { super ( card ) ; } @Override public PenumbraBobcat copy (  )  { return new PenumbraBobcat ( this ) ; } } class PenumbraBobcatToken extends Token { PenumbraBobcatToken (  )  { super ( "Cat", "2/1 black Cat creature token" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Cat" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 1 ) ; } } 
public class PenumbraKavu extends CardImpl { public PenumbraKavu ( UUID ownerId )  { super ( ownerId, 83, "Penumbra Kavu", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new PenumbraKavuToken (  ) , 1 ) , false )  ) ; } public PenumbraKavu ( final PenumbraKavu card )  { super ( card ) ; } @Override public PenumbraKavu copy (  )  { return new PenumbraKavu ( this ) ; } } class PenumbraKavuToken extends Token { PenumbraKavuToken (  )  { super ( "Kavu", "3/3 black Kavu creature token" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Kavu" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; } } 
public class PenumbraWurm extends CardImpl { public PenumbraWurm ( UUID ownerId )  { super ( ownerId, 84, "Penumbra Wurm", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{G}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new PenumbraWurmToken (  ) , 1 ) , false )  ) ; } public PenumbraWurm ( final PenumbraWurm card )  { super ( card ) ; } @Override public PenumbraWurm copy (  )  { return new PenumbraWurm ( this ) ; } } class PenumbraWurmToken extends Token { PenumbraWurmToken (  )  { super ( "Wurm", "6/6 black Wurm creature token with trample" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Wurm" ) ; power = new MageInt ( 6 ) ; toughness = new MageInt ( 6 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; } } 
public class PerniciousDeed extends CardImpl { public PerniciousDeed ( UUID ownerId )  { super ( ownerId, 114, "Pernicious Deed", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{B}{G}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PerniciousDeedEffect (  ) , new VariableManaCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public PerniciousDeed ( final PerniciousDeed card )  { super ( card ) ; } @Override public PerniciousDeed copy (  )  { return new PerniciousDeed ( this ) ; } } class PerniciousDeedEffect extends OneShotEffect { public PerniciousDeedEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy each artifact, creature, and enchantment with converted mana cost X or less"; } public PerniciousDeedEffect ( final PerniciousDeedEffect effect )  { super ( effect ) ; } @Override public PerniciousDeedEffect copy (  )  { return new PerniciousDeedEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { FilterPermanent filter = new FilterPermanent ( "artifacts, creatures, and enchantments" ) ; filter . add ( Predicates . or (  new CardTypePredicate ( CardType . ARTIFACT ) , new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . ENCHANTMENT )  )  ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, source . getManaCostsToPay (  )  . getX (  )  + 1 )  ) ; for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . destroy ( source . getSourceId (  ) , game, false ) ; } return true; } } 
public class PlanarDespair extends CardImpl { public PlanarDespair ( UUID ownerId )  { super ( ownerId, 50, "Planar Despair", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{B}{B}" ) ; this . expansionSetCode = "APC"; DynamicValue dv = new SignInversionDynamicValue ( new DomainValue (  )  ) ; Effect effect = new BoostAllEffect ( dv, dv, Duration . EndOfTurn ) ; effect . setText ( "Domain - All creatures get -1/-1 until end of turn for each basic land type among lands you control . " ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public PlanarDespair ( final PlanarDespair card )  { super ( card ) ; } @Override public PlanarDespair copy (  )  { return new PlanarDespair ( this ) ; } } 
public class PutridWarrior extends CardImpl { public PutridWarrior ( UUID ownerId )  { super ( ownerId, 117, "Putrid Warrior", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Soldier" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new PutridWarriorDealsDamageTriggeredAbility ( new LoseLifeAllPlayersEffect ( 1 )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new PutridWarriorGainLifeEffect (  )  ) ; ability . addMode ( mode ) ; this . addAbility ( ability ) ; } public PutridWarrior ( final PutridWarrior card )  { super ( card ) ; } @Override public PutridWarrior copy (  )  { return new PutridWarrior ( this ) ; } } class PutridWarriorDealsDamageTriggeredAbility extends TriggeredAbilityImpl { public PutridWarriorDealsDamageTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect, false ) ; } public PutridWarriorDealsDamageTriggeredAbility ( final PutridWarriorDealsDamageTriggeredAbility ability )  { super ( ability ) ; } @Override public PutridWarriorDealsDamageTriggeredAbility copy (  )  { return new PutridWarriorDealsDamageTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER || event . getType (  )  == EventType . DAMAGED_CREATURE || event . getType (  )  == EventType . DAMAGED_PLANESWALKER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { return event . getSourceId (  )  . equals ( this . sourceId ) ; } @Override public String getRule (  )  { return "Whenever {this} deals damage, " + super . getRule (  ) ; } } class PutridWarriorGainLifeEffect extends OneShotEffect { public PutridWarriorGainLifeEffect (  )  { super ( Outcome . GainLife ) ; staticText = "Each player gains 1 life . "; } public PutridWarriorGainLifeEffect ( final PutridWarriorGainLifeEffect effect )  { super ( effect ) ; } @Override public PutridWarriorGainLifeEffect copy (  )  { return new PutridWarriorGainLifeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for ( UUID playerId: game . getState (  )  . getPlayersInRange ( source . getControllerId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if ( player != null )  { player . gainLife ( 1, game ) ; } } return true; } } 
public class QuagmireDruid extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "enchantment" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public QuagmireDruid ( UUID ownerId )  { super ( ownerId, 51, "Quagmire Druid", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect ( false ) , new ColoredManaCost ( ColoredManaSymbol . G )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public QuagmireDruid ( final QuagmireDruid card )  { super ( card ) ; } @Override public QuagmireDruid copy (  )  { return new QuagmireDruid ( this ) ; } } 
public class QuicksilverDagger extends CardImpl { public QuicksilverDagger ( UUID ownerId )  { super ( ownerId, 118, "Quicksilver Dagger", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability gainAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; gainAbility . addTarget ( new TargetPlayer (  )  ) ; gainAbility . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( gainAbility, AttachmentType . AURA )  )  ) ; } public QuicksilverDagger ( final QuicksilverDagger card )  { super ( card ) ; } @Override public QuicksilverDagger copy (  )  { return new QuicksilverDagger ( this ) ; } } 
public class RakaDisciple extends CardImpl { public RakaDisciple ( UUID ownerId )  { super ( ownerId, 66, "Raka Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 1 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilityTargetEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . U )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( secondAbility ) ; } public RakaDisciple ( final RakaDisciple card )  { super ( card ) ; } @Override public RakaDisciple copy (  )  { return new RakaDisciple ( this ) ; } } 
public class Rakavolver extends CardImpl { public Rakavolver ( UUID ownerId )  { super ( ownerId, 68, "Rakavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{W}" ) ; kickerAbility . addKickerCost ( "{U}" ) ; this . addAbility ( kickerAbility ) ; Ability ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  ) , new KickedCostCondition ( "{1}{W}" ) , "If {this} was kicked with its {1}{W} kicker, it enters the battlefield with two +1/+1 counters on it and with \"Whenever {this} deals damage, you gain that much life . \"", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( new DealsDamageGainLifeSourceTriggeredAbility (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 )  ) , new KickedCostCondition ( "{U}" ) , "If {this} was kicked with its {U} kicker, it enters the battlefield with a +1/+1 counter on it and with flying . ", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; } public Rakavolver ( final Rakavolver card )  { super ( card ) ; } @Override public Rakavolver copy (  )  { return new Rakavolver ( this ) ; } } 
public class RazorfinHunter extends CardImpl { public RazorfinHunter ( UUID ownerId )  { super ( ownerId, 119, "Razorfin Hunter", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Goblin" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public RazorfinHunter ( final RazorfinHunter card )  { super ( card ) ; } @Override public RazorfinHunter copy (  )  { return new RazorfinHunter ( this ) ; } } 
public class ReefShaman extends CardImpl { public ReefShaman ( UUID ownerId )  { super ( ownerId, 29, "Reef Shaman", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesBasicLandTargetEffect ( Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetLandPermanent (  )  ) ; this . addAbility ( ability ) ; } public ReefShaman ( final ReefShaman card )  { super ( card ) ; } @Override public ReefShaman copy (  )  { return new ReefShaman ( this ) ; } } 
public class SavageGorilla extends CardImpl { public SavageGorilla ( UUID ownerId )  { super ( ownerId, 85, "Savage Gorilla", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Ape" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -3, -3, Duration . EndOfTurn ) , new ManaCostsImpl ( "{U}{B}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public SavageGorilla ( final SavageGorilla card )  { super ( card ) ; } @Override public SavageGorilla copy (  )  { return new SavageGorilla ( this ) ; } } 
public class ShieldOfDutyAndReason extends CardImpl { private static final FilterCard filter = new FilterCard ( "green and from blue" ) ; static { filter . add ( Predicates . or ( new ColorPredicate ( ObjectColor . GREEN ) , new ColorPredicate ( ObjectColor . BLUE )  )  ) ; } public ShieldOfDutyAndReason ( UUID ownerId )  { super ( ownerId, 16, "Shield of Duty and Reason", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( new ProtectionAbility ( filter ) , AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public ShieldOfDutyAndReason ( final ShieldOfDutyAndReason card )  { super ( card ) ; } @Override public ShieldOfDutyAndReason copy (  )  { return new ShieldOfDutyAndReason ( this ) ; } } 
public class ShimmeringMirage extends CardImpl { public ShimmeringMirage ( UUID ownerId )  { super ( ownerId, 30, "Shimmering Mirage", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new BecomesBasicLandTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetLandPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public ShimmeringMirage ( final ShimmeringMirage card )  { super ( card ) ; } @Override public ShimmeringMirage copy (  )  { return new ShimmeringMirage ( this ) ; } } 
public class ShivanReef extends CardImpl { public ShivanReef ( UUID ownerId )  { super ( ownerId, 142, "Shivan Reef", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability blueManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlueMana ( 1 ) , new TapSourceCost (  )  ) ; blueManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blueManaAbility ) ; Ability redManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . RedMana ( 1 ) , new TapSourceCost (  )  ) ; redManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( redManaAbility ) ; } public ShivanReef ( final ShivanReef card )  { super ( card ) ; } @Override public ShivanReef copy (  )  { return new ShivanReef ( this ) ; } } 
public class Smash extends CardImpl { public Smash ( UUID ownerId )  { super ( ownerId, 69, "Smash", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( new FilterArtifactPermanent (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public Smash ( final Smash card )  { super ( card ) ; } @Override public Smash copy (  )  { return new Smash ( this ) ; } } 
public class SoulLink extends CardImpl { public SoulLink ( UUID ownerId )  { super ( ownerId, 120, "Soul Link", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new DealsDamageAttachedTriggeredAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( new NumericSetToEffectValues ( "that much", "damage" )  ) , false )  ) ; this . addAbility ( new DamageDealtToAttachedTriggeredAbility ( new GainLifeEffect ( new NumericSetToEffectValues ( "that much", "damage" )  ) , false )  ) ; } public SoulLink ( final SoulLink card )  { super ( card ) ; } @Override public SoulLink copy (  )  { return new SoulLink ( this ) ; } } 
public class SpectralLynx extends CardImpl { private static final FilterCard filter = new FilterCard ( "green" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; } public SpectralLynx ( UUID ownerId )  { super ( ownerId, 17, "Spectral Lynx", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Cat" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new ProtectionAbility ( filter )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; } public SpectralLynx ( final SpectralLynx card )  { super ( card ) ; } @Override public SpectralLynx copy (  )  { return new SpectralLynx ( this ) ; } } 
public class Spiritmonger extends CardImpl { public Spiritmonger ( UUID ownerId )  { super ( ownerId, 121, "Spiritmonger", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( new DealsDamageToACreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  ) , true ) , false, false, false )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesColorSourceEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{G}" )  )  ) ; } public Spiritmonger ( final Spiritmonger card )  { super ( card ) ; } @Override public Spiritmonger copy (  )  { return new Spiritmonger ( this ) ; } } 
public class SqueesEmbrace extends CardImpl { public SqueesEmbrace ( UUID ownerId )  { super ( ownerId, 122, "Squee's Embrace", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{R}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 2, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new DiesAttachedTriggeredAbility ( new ReturnToHandAttachedEffect (  ) , "enchanted creature" )  ) ; } public SqueesEmbrace ( final SqueesEmbrace card )  { super ( card ) ; } @Override public SqueesEmbrace copy (  )  { return new SqueesEmbrace ( this ) ; } } 
public class SqueesRevenge extends CardImpl { public SqueesRevenge ( UUID ownerId )  { super ( ownerId, 123, "Squee's Revenge", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{U}{R}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new SqueesRevengeEffect (  )  ) ; } public SqueesRevenge ( final SqueesRevenge card )  { super ( card ) ; } @Override public SqueesRevenge copy (  )  { return new SqueesRevenge ( this ) ; } } class SqueesRevengeEffect extends OneShotEffect { public SqueesRevengeEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Choose a number .  Flip a coin that many times or until you lose a flip, whichever comes first .  If you win all the flips, draw two cards for each flip . "; } public SqueesRevengeEffect ( final SqueesRevengeEffect effect )  { super ( effect ) ; } public SqueesRevengeEffect copy (  )  { return new SqueesRevengeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if ( player != null )  { int number = player . announceXMana ( 0, Integer . MAX_VALUE, "Choose how many times to flip a coin", game, source ) ; game . informPlayers ( player . getLogName (  )  + " chooses " + number + " . " ) ; for ( int i = 0; i < number; i++ )  { if ( !player . flipCoin ( game )  )  { return true; } } player . drawCards ( 2 * number, game ) ; return true; } return false; } } 
public class SylvanMessenger extends CardImpl { private static final FilterCard filter = new FilterCard ( "Elf cards" ) ; static { filter . add ( new SubtypePredicate ( "Elf" )  ) ; } public SylvanMessenger ( UUID ownerId )  { super ( ownerId, 87, "Sylvan Messenger", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Elf" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public SylvanMessenger ( final SylvanMessenger card )  { super ( card ) ; } @Override public SylvanMessenger copy (  )  { return new SylvanMessenger ( this ) ; } } 
public class SymbioticDeployment extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creatures you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public SymbioticDeployment ( UUID ownerId )  { super ( ownerId, 88, "Symbiotic Deployment", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SkipDrawStepEffect (  )  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new ManaCostsImpl ( "{1}" )  ) ; ability . addCost ( new TapTargetCost ( new TargetControlledCreaturePermanent ( 2, 2, filter, false )  )  ) ; this . addAbility ( ability ) ; } public SymbioticDeployment ( final SymbioticDeployment card )  { super ( card ) ; } @Override public SymbioticDeployment copy (  )  { return new SymbioticDeployment ( this ) ; } } 
public class TemporalSpring extends CardImpl { public TemporalSpring ( UUID ownerId )  { super ( ownerId, 125, "Temporal Spring", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{G}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; } public TemporalSpring ( final TemporalSpring card )  { super ( card ) ; } @Override public TemporalSpring copy (  )  { return new TemporalSpring ( this ) ; } } 
public class TidalCourier extends CardImpl { private static final FilterCard filter = new FilterCard ( "Merfolk cards" ) ; static { filter . add ( new SubtypePredicate ( "Merfolk" )  ) ; } public TidalCourier ( UUID ownerId )  { super ( ownerId, 31, "Tidal Courier", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}{U}" )  )  ) ; } public TidalCourier ( final TidalCourier card )  { super ( card ) ; } @Override public TidalCourier copy (  )  { return new TidalCourier ( this ) ; } } 
public class TranquilPath extends CardImpl { public TranquilPath ( UUID ownerId )  { super ( ownerId, 89, "Tranquil Path", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new TranquilPathEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public TranquilPath ( final TranquilPath card )  { super ( card ) ; } @Override public TranquilPath copy (  )  { return new TranquilPath ( this ) ; } } class TranquilPathEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterPermanent ( "" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public TranquilPathEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy all enchantments"; } public TranquilPathEffect ( final TranquilPathEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . destroy ( source . getSourceId (  ) , game, false ) ; } return true; } @Override public TranquilPathEffect copy (  )  { return new TranquilPathEffect ( this ) ; } } 
public class TundraKavu extends CardImpl { public TundraKavu ( UUID ownerId )  { super ( ownerId, 71, "Tundra Kavu", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TundraKavuEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetLandPermanent (  )  ) ; this . addAbility ( ability ) ; } public TundraKavu ( final TundraKavu card )  { super ( card ) ; } @Override public TundraKavu copy (  )  { return new TundraKavu ( this ) ; } } class TundraKavuEffect extends BecomesBasicLandTargetEffect { public TundraKavuEffect (  )  { super ( Duration . EndOfTurn, false, true, "" ) ; staticText = "Target land becomes a Plains or an Island until end of turn . "; } public TundraKavuEffect ( final TundraKavuEffect effect )  { super ( effect ) ; } public TundraKavuEffect copy (  )  { return new TundraKavuEffect ( this ) ; } @Override public void init ( Ability source, Game game )  { landTypes . clear (  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if ( controller != null )  { Set<String> choiceSet = new LinkedHashSet<> (  ) ; choiceSet . add ( "Island" ) ; choiceSet . add ( "Plains" ) ; ChoiceImpl choice = new ChoiceImpl ( true ) ; choice . setChoices ( choiceSet ) ; choice . setMessage ( "Choose a basic land type" ) ; controller . choose ( outcome, choice, game ) ; landTypes . add ( choice . getChoice (  )  ) ; } else { this . discard (  ) ; } super . init ( source, game ) ; } } 
public class UnnaturalSelection extends CardImpl { public UnnaturalSelection ( UUID ownerId )  { super ( ownerId, 32, "Unnatural Selection", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesChosenCreatureTypeTargetEffect ( true ) , new GenericManaCost ( 1 )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public UnnaturalSelection ( final UnnaturalSelection card )  { super ( card ) ; } @Override public UnnaturalSelection copy (  )  { return new UnnaturalSelection ( this ) ; } } 
public class UrborgElf extends CardImpl { public UrborgElf ( UUID ownerId )  { super ( ownerId, 90, "Urborg Elf", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new GreenManaAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public UrborgElf ( final UrborgElf card )  { super ( card ) ; } @Override public UrborgElf copy (  )  { return new UrborgElf ( this ) ; } } 
public class UrborgUprising extends CardImpl { public UrborgUprising ( UUID ownerId )  { super ( ownerId, 53, "Urborg Uprising", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( 0, 2, new FilterCreatureCard ( "creature cards from your graveyard" )  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public UrborgUprising ( final UrborgUprising card )  { super ( card ) ; } @Override public UrborgUprising copy (  )  { return new UrborgUprising ( this ) ; } } 
public class Vindicate extends CardImpl { public Vindicate  ( UUID ownerId )  { super ( ownerId, 126, "Vindicate", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{1}{W}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; } public Vindicate  ( final Vindicate card )  { super ( card ) ; } @Override public Vindicate copy (  )  { return new Vindicate ( this ) ; } } 
public class VodalianMystic extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant or sorcery spell" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . INSTANT ) , new CardTypePredicate ( CardType . SORCERY )  )  ) ; } public VodalianMystic ( UUID ownerId )  { super ( ownerId, 33, "Vodalian Mystic", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesColorTargetEffect ( Duration . WhileOnStack ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetSpell ( filter )  ) ; this . addAbility ( ability ) ; } public VodalianMystic ( final VodalianMystic card )  { super ( card ) ; } @Override public VodalianMystic copy (  )  { return new VodalianMystic ( this ) ; } } 
public class WhirlpoolDrake extends CardImpl { public WhirlpoolDrake ( UUID ownerId )  { super ( ownerId, 34, "Whirlpool Drake", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ShuffleHandIntoLibraryDrawThatManySourceEffect (  ) , false )  ) ; this . addAbility ( new DiesTriggeredAbility ( new ShuffleHandIntoLibraryDrawThatManySourceEffect (  ) , false )  ) ; } public WhirlpoolDrake ( final WhirlpoolDrake card )  { super ( card ) ; } @Override public WhirlpoolDrake copy (  )  { return new WhirlpoolDrake ( this ) ; } } 
public class WhirlpoolRider extends CardImpl { public WhirlpoolRider ( UUID ownerId )  { super ( ownerId, 35, "Whirlpool Rider", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ShuffleHandIntoLibraryDrawThatManySourceEffect (  )  )  ) ; } public WhirlpoolRider ( final WhirlpoolRider card )  { super ( card ) ; } @Override public WhirlpoolRider copy (  )  { return new WhirlpoolRider ( this ) ; } } 
public class WildResearch extends CardImpl { private static final FilterCard filterEnchantment = new FilterCard ( "enchantment card" ) ; private static final FilterCard filterInstant = new FilterCard ( "instant card" ) ; static { filterEnchantment . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filterInstant . add ( new CardTypePredicate ( CardType . INSTANT )  ) ; } public WildResearch ( UUID ownerId )  { super ( ownerId, 72, "Wild Research", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new WildResearchEffect ( filterEnchantment ) , new ManaCostsImpl<> ( "{1}{W}" )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new WildResearchEffect ( filterInstant ) , new ManaCostsImpl<> ( "{1}{U}" )  )  ) ; } public WildResearch ( final WildResearch card )  { super ( card ) ; } @Override public WildResearch copy (  )  { return new WildResearch ( this ) ; } } class WildResearchEffect extends OneShotEffect { protected final FilterCard filter; WildResearchEffect ( FilterCard filter )  { super ( Outcome . DrawCard ) ; this . staticText = "Search your library for an " + filter . getMessage (  )  + " and reveal that card .  Put it into your hand, then discard a card at random .  Then shuffle your library . "; this . filter = filter; } WildResearchEffect ( final WildResearchEffect effect )  { super ( effect ) ; this . filter = effect . filter; } @Override public WildResearchEffect copy (  )  { return new WildResearchEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller != null && sourceObject != null )  { TargetCardInLibrary target = new TargetCardInLibrary ( filter ) ; if  ( controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { Card card = controller . getLibrary (  )  . remove ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { controller . moveCards ( card, null, Zone . HAND, source, game ) ; Cards cards = new CardsImpl (  ) ; cards . add ( card ) ; controller . revealCards ( sourceObject . getIdName (  ) , cards, game, true ) ; } } } controller . discardOne ( true, source, game ) ; controller . shuffleLibrary ( game ) ; return true; } return false; } } 
public class YavimayaCoast extends CardImpl { public YavimayaCoast ( UUID ownerId )  { super ( ownerId, 143, "Yavimaya Coast", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability greenManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . GreenMana ( 1 ) , new TapSourceCost (  )  ) ; greenManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( greenManaAbility ) ; Ability blueManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlueMana ( 1 ) , new TapSourceCost (  )  ) ; blueManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blueManaAbility ) ; } public YavimayaCoast ( final YavimayaCoast card )  { super ( card ) ; } @Override public YavimayaCoast copy (  )  { return new YavimayaCoast ( this ) ; } } 
public class YavimayasEmbrace extends CardImpl { public YavimayasEmbrace ( UUID ownerId )  { super ( ownerId, 127, "Yavimaya's Embrace", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{5}{G}{U}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Detriment )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ControlEnchantedEffect (  )  )  ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 2, Duration . WhileOnBattlefield )  ) ; Effect effect = new GainAbilityAttachedEffect ( TrampleAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( "and has trample" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public YavimayasEmbrace ( final YavimayasEmbrace card )  { super ( card ) ; } @Override public YavimayasEmbrace copy (  )  { return new YavimayasEmbrace ( this ) ; } } 
public class AliBaba extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Wall" ) ; static { filter . add ( new SubtypePredicate ( "Wall" )  ) ; } public AliBaba ( UUID ownerId )  { super ( ownerId, 43, "Ali Baba", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new ManaCostsImpl ( "{R}" )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public AliBaba ( final AliBaba card )  { super ( card ) ; } @Override public AliBaba copy (  )  { return new AliBaba ( this ) ; } } 
public class AliFromCairo extends CardImpl { public AliFromCairo ( UUID ownerId )  { super ( ownerId, 44, "Ali from Cairo", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AliFromCairoReplacementEffect (  )  )  ) ; } public AliFromCairo ( final AliFromCairo card )  { super ( card ) ; } @Override public AliFromCairo copy (  )  { return new AliFromCairo ( this ) ; } } class AliFromCairoReplacementEffect extends ReplacementEffectImpl { public AliFromCairoReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Damage that would reduce your life total to less than 1 reduces it to 1 instead"; } public AliFromCairoReplacementEffect ( final AliFromCairoReplacementEffect effect )  { super ( effect ) ; } @Override public AliFromCairoReplacementEffect copy (  )  { return new AliFromCairoReplacementEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DAMAGE_CAUSES_LIFE_LOSS; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null &&  ( controller . getLife (  )  > 0 )  && ( controller . getLife (  )  - event . getAmount (  )  )  < 1 && event . getPlayerId (  )  . equals ( controller . getId (  )  )   )  { return true; } } return false; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { event . setAmount ( controller . getLife (  )  - 1 ) ; } return false; } } 
public class DiamondValley extends CardImpl { public DiamondValley ( UUID ownerId )  { super ( ownerId, 87, "Diamond Valley", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ARN"; Effect effect = new GainLifeEffect ( new SacrificeCostCreaturesToughness (  )  ) ; effect . setText ( "You gain life equal to the sacrificed creature's toughness" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; this . addAbility ( ability ) ; } public DiamondValley ( final DiamondValley card )  { super ( card ) ; } @Override public DiamondValley copy (  )  { return new DiamondValley ( this ) ; } } 
public class ElHajjaj extends CardImpl { public ElHajjaj ( UUID ownerId )  { super ( ownerId, 2, "El-Hajjaj", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DealsDamageGainLifeSourceTriggeredAbility (  )  ) ; } public ElHajjaj ( final ElHajjaj card )  { super ( card ) ; } @Override public ElHajjaj copy (  )  { return new ElHajjaj ( this ) ; } } 
public class FishliverOil1 extends CardImpl { public FishliverOil1 ( UUID ownerId )  { super ( ownerId, 17, "Fishliver Oil", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( new IslandwalkAbility (  ) , AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public FishliverOil1 ( final FishliverOil1 card )  { super ( card ) ; } @Override public FishliverOil1 copy (  )  { return new FishliverOil1 ( this ) ; } } 
public class IslandOfWakWak extends CardImpl { private static final FilterCreaturePermanent filterWithFlying = new FilterCreaturePermanent ( "creature with flying" ) ; static { filterWithFlying . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public IslandOfWakWak ( UUID ownerId )  { super ( ownerId, 89, "Island of Wak-Wak", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ARN"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new IslandOfWakWakEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filterWithFlying )  ) ; this . addAbility ( ability ) ; } public IslandOfWakWak ( final IslandOfWakWak card )  { super ( card ) ; } @Override public IslandOfWakWak copy (  )  { return new IslandOfWakWak ( this ) ; } } class IslandOfWakWakEffect extends OneShotEffect { public IslandOfWakWakEffect (  )  { super ( Outcome . Detriment ) ; staticText = "The power of target creature with flying becomes 0 until end of turn"; } public IslandOfWakWakEffect ( final IslandOfWakWakEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent targetCreature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( targetCreature != null )  { MageInt toughness = targetCreature . getToughness (  ) ; game . addEffect ( new SetPowerToughnessTargetEffect ( 0, toughness . getValue (  ) , Duration . EndOfTurn ) , source ) ; return true; } return false; } @Override public Effect copy (  )  { return new IslandOfWakWakEffect ( this ) ; } } 
public class JuzamDjinn extends CardImpl { public JuzamDjinn ( UUID ownerId )  { super ( ownerId, 9, "Juzam Djinn", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}{B}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Djinn" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new DamageControllerEffect ( 1 ) , TargetController . YOU, false )  ) ; } public JuzamDjinn ( final JuzamDjinn card )  { super ( card ) ; } @Override public JuzamDjinn copy (  )  { return new JuzamDjinn ( this ) ; } } 
public class KingSuleiman extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Djinn or Efreet" ) ; static { filter . add (  Predicates . or (  new SubtypePredicate ( "Djinn" ) , new SubtypePredicate ( "Efreet" )  )  ) ; } public KingSuleiman ( UUID ownerId )  { super ( ownerId, 61, "King Suleiman", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public KingSuleiman ( final KingSuleiman card )  { super ( card ) ; } @Override public KingSuleiman copy (  )  { return new KingSuleiman ( this ) ; } } 
public class MerchantShip extends CardImpl { public MerchantShip ( UUID ownerId )  { super ( ownerId, 23, "Merchant Ship", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantAttackUnlessDefenderControllsPermanent ( new FilterLandPermanent ( "Island", "an Island" )  )  )  ) ; this . addAbility ( new AttacksAndIsNotBlockedTriggeredAbility ( new GainLifeEffect ( 2 )  )  ) ; this . addAbility ( new ControlsPermanentsControllerTriggeredAbility (  new FilterLandPermanent ( "Island", "no Islands" ) , Filter . ComparisonType . Equal, 0, new SacrificeSourceEffect (  )  )  ) ; } public MerchantShip ( final MerchantShip card )  { super ( card ) ; } @Override public MerchantShip copy (  )  { return new MerchantShip ( this ) ; } } 
public class NafsAsp extends CardImpl { public NafsAsp ( UUID ownerId )  { super ( ownerId, 36, "Nafs Asp", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DealsDamageToAPlayerTriggeredAbility ( new UnlessPaysDelayedEffect (  new ManaCostsImpl ( "{1}" ) , new LoseLifeTargetEffect ( 1 ) , PhaseStep . DRAW, true, "that player loses 1 life at the beginning of his or her next draw step unless he or she pays {1} before that draw step . " ) , false, true )  ) ; } public NafsAsp ( final NafsAsp card )  { super ( card ) ; } @Override public NafsAsp copy (  )  { return new NafsAsp ( this ) ; } } 
public class OldManOfTheSea extends CardImpl { public OldManOfTheSea ( UUID ownerId )  { super ( ownerId, 24, "Old Man of the Sea", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Djinn" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; FilterCreaturePermanent controllableCreatures = new FilterCreaturePermanent ( "creature with power less than or equal to Old Man of the Sea's power" ) ; controllableCreatures . add ( new PowerLowerEqualSourcePredicate ( this . getId (  )  )  ) ; ConditionalContinuousEffect effect = new ConditionalContinuousEffect (  new OldManOfTheSeaGainControlTargetEffect ( Duration . Custom, true ) , new CompoundCondition ( SourceTappedCondition . getInstance (  ) , new SourcePowerGreaterEqualTargetCondition (  )  ) , "Gain control of target creature with power less than or equal to {this}'s power for as long as {this} remains tapped and that creature's power remains less than or equal to {this}'s power" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( controllableCreatures )  ) ; this . addAbility ( ability ) ; this . addAbility ( new OldManOfTheSeaStateBasedTriggeredAbility (  )  ) ; } public OldManOfTheSea ( final OldManOfTheSea card )  { super ( card ) ; } @Override public OldManOfTheSea copy (  )  { return new OldManOfTheSea ( this ) ; } } class OldManOfTheSeaGainControlTargetEffect extends GainControlTargetEffect { public OldManOfTheSeaGainControlTargetEffect ( Duration duration, boolean fixedControl )  { super ( duration, fixedControl ) ; } public OldManOfTheSeaGainControlTargetEffect ( final OldManOfTheSeaGainControlTargetEffect effect )  { super ( effect ) ; } @Override public void init ( Ability source, Game game )  { super . init ( source, game ) ; game . getState (  )  . setValue ( "target" + source . getSourceId (  ) , getTargetPointer (  )  . getFirst ( game, source )  ) ; } @Override public OldManOfTheSeaGainControlTargetEffect copy (  )  { return new OldManOfTheSeaGainControlTargetEffect ( this ) ; } } /* used a state based triggered effect here  ( not going to stack, so running hidden )  to compare power of the controlled creature to Old Man of the seas power .  It's not possible to do this as condition of continuous effect, because the time the effect checks its condition, the layered effects that modify power are not applied yet .  result is save to a state value to be available for the condition of the continuous effect */ class OldManOfTheSeaStateBasedTriggeredAbility extends StateTriggeredAbility { public OldManOfTheSeaStateBasedTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new InfoEffect ( "" )  ) ; this . setRuleVisible ( false ) ; this . usesStack = false; } public OldManOfTheSeaStateBasedTriggeredAbility ( final OldManOfTheSeaStateBasedTriggeredAbility ability )  { super ( ability ) ; } @Override public OldManOfTheSeaStateBasedTriggeredAbility copy (  )  { return new OldManOfTheSeaStateBasedTriggeredAbility ( this ) ; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent sourcePermanent = game . getPermanent ( getSourceId (  )  ) ; if  ( sourcePermanent != null && sourcePermanent . isTapped (  )  )  { UUID controlledCreatureId =  ( UUID )  game . getState (  )  . getValue ( "target" + getSourceId (  )  ) ; if  ( controlledCreatureId != null )  { Permanent controlledCreature = game . getPermanent ( controlledCreatureId ) ; if  ( controlledCreature != null )  { if  ( controlledCreature . getPower (  )  . getValue (  )  > sourcePermanent . getPower (  )  . getValue (  )  )  { game . getState (  )  . setValue ( "powerCondition" + getSourceId (  ) , Boolean . TRUE ) ; } } } } return false; } } class SourcePowerGreaterEqualTargetCondition implements Condition { @Override public boolean apply ( Game game, Ability source )  { Object object = game . getState (  )  . getValue ( "powerCondition" + source . getSourceId (  )  ) ; if  ( object != null &&  ( Boolean )  object )  { game . getState (  )  . setValue ( "powerCondition" + source . getSourceId (  ) , Boolean . FALSE ) ; game . getState (  )  . setValue ( "target" + source . getSourceId (  ) , null ) ; return false; } return true; } } class PowerLowerEqualSourcePredicate implements ObjectPlayerPredicate<ObjectPlayer<Permanent>> { UUID sourceId; public PowerLowerEqualSourcePredicate ( UUID sourceId )  { this . sourceId = sourceId; } @Override public boolean apply ( ObjectPlayer<Permanent> input, Game game )  { Permanent sourcePermanent = game . getPermanent ( sourceId ) ; Permanent permanent = input . getObject (  ) ; if  ( permanent != null && sourcePermanent != null )  { if  ( permanent . getPower (  )  . getValue (  )  <= sourcePermanent . getPower (  )  . getValue (  )  )  { return true; } } return false; } @Override public String toString (  )  { return "creature with power less than or equal to {source}'s power"; } } 
public class RukhEgg1 extends CardImpl { public RukhEgg1 ( UUID ownerId )  { super ( ownerId, 52, "Rukh Egg", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 3 ) ; Effect effect = new CreateDelayedTriggeredAbilityEffect ( new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( new CreateTokenEffect ( new BirdToken (  )  )  )  ) ; effect . setText ( "put a 4/4 red Bird creature token with flying onto the battlefield at the beginning of the next end step" ) ; Ability ability = new DiesTriggeredAbility ( effect ) ; this . addAbility ( ability ) ; } public RukhEgg1 ( final RukhEgg1 card )  { super ( card ) ; } @Override public RukhEgg1 copy (  )  { return new RukhEgg1 ( this ) ; } } class BirdToken extends Token { public BirdToken (  )  { this ( "ARN" ) ;  
public class StoneThrowingDevils1 extends CardImpl { public StoneThrowingDevils1 ( UUID ownerId )  { super ( ownerId, 14, "Stone-Throwing Devils", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Devil" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; } public StoneThrowingDevils1 ( final StoneThrowingDevils1 card )  { super ( card ) ; } @Override public StoneThrowingDevils1 copy (  )  { return new StoneThrowingDevils1 ( this ) ; } } 
public class UnstableMutation extends CardImpl { public UnstableMutation ( UUID ownerId )  { super ( ownerId, 28, "Unstable Mutation", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 3, 3 )  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new AddCountersAttachedEffect ( CounterType . M1M1 . createInstance (  ) , "that creature" ) , TargetController . CONTROLLER_ATTACHED_TO, false )  ) ; } public UnstableMutation ( final UnstableMutation card )  { super ( card ) ; } @Override public UnstableMutation copy (  )  { return new UnstableMutation ( this ) ; } } 
public class AvatarOfWoe extends CardImpl { public AvatarOfWoe ( UUID ownerId )  { super ( ownerId, 9, "Avatar of Woe", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{B}{B}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Avatar" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . STACK, new AvatarOfWoeCostReductionEffect (  )  )  ) ; this . addAbility ( FearAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect ( true ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public AvatarOfWoe ( final AvatarOfWoe card )  { super ( card ) ; } @Override public AvatarOfWoe copy (  )  { return new AvatarOfWoe ( this ) ; } } class AvatarOfWoeCostReductionEffect extends CostModificationEffectImpl { AvatarOfWoeCostReductionEffect (  )  { super ( Duration . Custom, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "If there are ten or more creature cards total in all graveyards, {this} costs {6} less to cast"; } AvatarOfWoeCostReductionEffect ( final AvatarOfWoeCostReductionEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { SpellAbility spellAbility =  ( SpellAbility )  abilityToModify; Mana mana = spellAbility . getManaCostsToPay (  )  . getMana (  ) ; if  ( mana . getGeneric (  )  > 0 )  { int newCount = mana . getGeneric (  )  - 6; if  ( newCount < 0 )  { newCount = 0; } mana . setGeneric ( newCount ) ; spellAbility . getManaCostsToPay (  )  . load ( mana . toString (  )  ) ; return true; } return false; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { return abilityToModify . getSourceId (  )  . equals ( source . getSourceId (  )  )  &&  ( abilityToModify instanceof SpellAbility )  && new CardsInAllGraveyardsCount ( new FilterCreatureCard (  )  )  . calculate ( game, source, this )  >= 10; } @Override public AvatarOfWoeCostReductionEffect copy (  )  { return new AvatarOfWoeCostReductionEffect ( this ) ; } } 
public class BatteringCraghorn extends CardImpl { public BatteringCraghorn ( UUID ownerId )  { super ( ownerId, 30, "Battering Craghorn", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Goat" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{1}{R}{R}" )  )  ) ; } public BatteringCraghorn ( final BatteringCraghorn card )  { super ( card ) ; } @Override public BatteringCraghorn copy (  )  { return new BatteringCraghorn ( this ) ; } } 
public class DragonBreath extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "a creature with converted mana cost 6 or greater" ) ; static { filter . add ( new ConvertedManaCostPredicate ( ComparisonType . GreaterThan, 5 )  ) ; } public DragonBreath ( UUID ownerId )  { super ( ownerId, 33, "Dragon Breath", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( HasteAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  )  ) ; this . addAbility ( new EntersBattlefieldAllTriggeredAbility ( Zone . GRAVEYARD, new DragonBreathEffect (  ) , filter, true, SetTargetPointer . PERMANENT, null )  ) ; } public DragonBreath ( final DragonBreath card )  { super ( card ) ; } @Override public DragonBreath copy (  )  { return new DragonBreath ( this ) ; } } class DragonBreathEffect extends OneShotEffect { DragonBreathEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "return {this} from your graveyard to the battlefield attached to that creature"; } DragonBreathEffect ( final DragonBreathEffect effect )  { super ( effect ) ; } @Override public DragonBreathEffect copy (  )  { return new DragonBreathEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card sourceCard =  ( Card )  source . getSourceObjectIfItStillExists ( game ) ; Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( sourceCard != null && permanent != null && controller != null )  { game . getState (  )  . setValue ( "attachTo:" + sourceCard . getId (  ) , permanent ) ; if  ( controller . moveCards ( sourceCard, Zone . BATTLEFIELD, source, game )  )  { permanent . addAttachment ( sourceCard . getId (  ) , game ) ; } return true; } return false; } } 
public class ImperialHellkite extends CardImpl { public ImperialHellkite ( UUID ownerId )  { super ( ownerId, 42, "Imperial Hellkite", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{R}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{6}{R}{R}" )  )  ) ; Effect effect = new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( 0, 1, new FilterBySubtypeCard ( "Dragon" )  ) , true, true ) ; effect . setText ( "you may search your library for a Dragon card, reveal it, and put it into your hand .  If you do, shuffle your library" ) ; this . addAbility ( new TurnedFaceUpSourceTriggeredAbility ( effect )  ) ; } public ImperialHellkite ( final ImperialHellkite card )  { super ( card ) ; } @Override public ImperialHellkite copy (  )  { return new ImperialHellkite ( this ) ; } } 
public class MakeshiftMannequin extends CardImpl { public MakeshiftMannequin ( UUID ownerId )  { super ( ownerId, 20, "Makeshift Mannequin", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{B}" ) ; this . expansionSetCode = "ARC"; this . getSpellAbility (  )  . addEffect ( new MakeshiftMannequinEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "creature card from your graveyard" )  )  ) ; } public MakeshiftMannequin ( final MakeshiftMannequin card )  { super ( card ) ; } @Override public MakeshiftMannequin copy (  )  { return new MakeshiftMannequin ( this ) ; } } class MakeshiftMannequinEffect extends OneShotEffect { MakeshiftMannequinEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "Return target creature card from your graveyard to the battlefield with a mannequin counter on it .  For as long as that creature has a mannequin counter on it, it has \"When this creature becomes the target of a spell or ability, sacrifice it . \""; } MakeshiftMannequinEffect ( final MakeshiftMannequinEffect effect )  { super ( effect ) ; } @Override public MakeshiftMannequinEffect copy (  )  { return new MakeshiftMannequinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { UUID cardId = this . getTargetPointer (  )  . getFirst ( game, source ) ; Card card = controller . getGraveyard (  )  . get ( cardId, game ) ; if  ( card != null )  { Counters counters = new Counters (  ) ; counters . addCounter ( CounterType . MANNEQUIN . createInstance (  )  ) ; game . setEnterWithCounters ( cardId, counters ) ; if  ( controller . moveCards ( card, Zone . BATTLEFIELD, source, game )  )  { Permanent permanent = game . getPermanent ( cardId ) ; if  ( permanent != null )  { ContinuousEffect gainedEffect = new MakeshiftMannequinGainAbilityEffect (  ) ; gainedEffect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; game . addEffect ( gainedEffect, source ) ; } } return true; } } return false; } } class MakeshiftMannequinGainAbilityEffect extends ContinuousEffectImpl { MakeshiftMannequinGainAbilityEffect (  )  { super ( Duration . Custom, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; } MakeshiftMannequinGainAbilityEffect ( final MakeshiftMannequinGainAbilityEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( permanent != null )  { permanent . addAbility ( new BecomesTargetTriggeredAbility ( new SacrificeSourceEffect (  )  ) , source . getSourceId (  ) , game ) ; return true; } return false; } @Override public boolean isInactive ( Ability source, Game game )  { Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; return permanent == null || permanent . getCounters (  )  . getCount ( CounterType . MANNEQUIN )  < 1; } @Override public MakeshiftMannequinGainAbilityEffect copy (  )  { return new MakeshiftMannequinGainAbilityEffect ( this ) ; } } 
public class NantukoMonastery extends CardImpl { public NantukoMonastery ( UUID ownerId )  { super ( ownerId, 131, "Nantuko Monastery", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ARC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new ConditionalActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureSourceEffect (  new NantukoMonasteryToken (  ) , "land", Duration . EndOfTurn ) , new ManaCostsImpl<> ( "{G}{W}" ) , new CardsInControllerGraveCondition ( 7 )  ) ; ability . setAbilityWord ( AbilityWord . THRESHOLD ) ; this . addAbility ( ability ) ; } public NantukoMonastery ( final NantukoMonastery card )  { super ( card ) ; } @Override public NantukoMonastery copy (  )  { return new NantukoMonastery ( this ) ; } } class NantukoMonasteryToken extends Token { public NantukoMonasteryToken (  )  { super ( "", "4/4 green and white Insect Monk creature with first strike" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Insect" ) ; subtype . add ( "Monk" ) ; color . setGreen ( true ) ; color . setWhite ( true ) ; power = new MageInt ( 4 ) ; toughness = new MageInt ( 4 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; } } 
public class SpinIntoMyth extends CardImpl { public SpinIntoMyth ( UUID ownerId )  { super ( ownerId, 8, "Spin into Myth", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{U}" ) ; this . expansionSetCode = "ARC"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new FatesealEffect ( 2 ) ; effect . setText ( ", then fateseal 2 .  <i> ( To fateseal 2, look at the top two cards of an opponent's library, then put any number of them on the bottom of that player's library and the rest on top in any order .  ) </i>" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public SpinIntoMyth ( final SpinIntoMyth card )  { super ( card ) ; } @Override public SpinIntoMyth copy (  )  { return new SpinIntoMyth ( this ) ; } } 
public class VampiricDragon extends CardImpl { public VampiricDragon ( UUID ownerId )  { super ( ownerId, 99, "Vampiric Dragon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{B}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new DiesAndDealtDamageThisTurnTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new ManaCostsImpl ( "{1}{R}" )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public VampiricDragon ( final VampiricDragon card )  { super ( card ) ; } @Override public VampiricDragon copy (  )  { return new VampiricDragon ( this ) ; } } 
public class YavimayaDryad extends CardImpl { private static final FilterLandCard filter = new FilterLandCard ( "a Forest card" ) ; static { filter . add ( new SubtypePredicate ( "Forest" )  ) ; } public YavimayaDryad ( UUID ownerId )  { super ( ownerId, 75, "Yavimaya Dryad", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Dryad" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new ForestwalkAbility (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new YavimayaDryadEffect ( new TargetCardInLibrary ( filter )  ) , true ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public YavimayaDryad ( final YavimayaDryad card )  { super ( card ) ; } @Override public YavimayaDryad copy (  )  { return new YavimayaDryad ( this ) ; } } class YavimayaDryadEffect extends SearchEffect { public YavimayaDryadEffect ( TargetCardInLibrary target )  { super ( target, Outcome . PutLandInPlay ) ; staticText = "you may search your library for a Forest card and put it onto the battlefield tapped under target player's control .  If you do, shuffle your library"; } public YavimayaDryadEffect ( final YavimayaDryadEffect effect )  { super ( effect ) ; } @Override public YavimayaDryadEffect copy (  )  { return new YavimayaDryadEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller == null || targetPlayer == null )  { return false; } if  ( controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { targetPlayer . moveCards ( new CardsImpl ( target . getTargets (  )  )  . getCards ( game ) , Zone . BATTLEFIELD, source, game, true, false, false, null ) ; } controller . shuffleLibrary ( game ) ; return true; } return false; } } 
public class AbundantGrowth extends CardImpl { public AbundantGrowth ( UUID ownerId )  { super ( ownerId, 167, "Abundant Growth", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Benefit )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; Ability gainedAbility = new AnyColorManaAbility ( new TapSourceCost (  )  ) ; Effect effect = new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA ) ; effect . setText ( "Enchanted land has \"{T}: Add one mana of any color to your mana pool . \"" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public AbundantGrowth ( final AbundantGrowth card )  { super ( card ) ; } @Override public AbundantGrowth copy (  )  { return new AbundantGrowth ( this ) ; } } 
public class Aggravate extends CardImpl { public Aggravate ( UUID ownerId )  { super ( ownerId, 125, "Aggravate", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new AggravateEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new AggravateRequirementEffect (  )  ) ; this . getSpellAbility (  )  . addWatcher ( new DamagedByWatcher (  )  ) ; } public Aggravate ( final Aggravate card )  { super ( card ) ; } @Override public Aggravate copy (  )  { return new Aggravate ( this ) ; } } class AggravateEffect extends OneShotEffect { public AggravateEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "{this} deals 1 damage to each creature target player controls"; } public AggravateEffect ( final AggravateEffect effect )  { super ( effect ) ; } @Override public AggravateEffect copy (  )  { return new AggravateEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null )  { FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; filter . add ( new ControllerIdPredicate ( player . getId (  )  )  ) ; List<Permanent> creatures = game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game ) ; for  ( Permanent creature : creatures )  { creature . damage ( 1, source . getSourceId (  ) , game, false, true ) ; } return true; } return false; } } class AggravateRequirementEffect extends RequirementEffect { public AggravateRequirementEffect (  )  { super ( Duration . EndOfTurn ) ; this . staticText = "Each creature dealt damage this way attacks this turn if able"; } public AggravateRequirementEffect ( final AggravateRequirementEffect effect )  { super ( effect ) ; } @Override public AggravateRequirementEffect copy (  )  { return new AggravateRequirementEffect ( this ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { DamagedByWatcher watcher =  ( DamagedByWatcher )  game . getState (  )  . getWatchers (  )  . get ( "DamagedByWatcher", source . getSourceId (  )  ) ; if  ( watcher != null )  { return watcher . wasDamaged ( permanent, game ) ; } return false; } @Override public boolean mustAttack ( Game game )  { return true; } @Override public boolean mustBlock ( Game game )  { return false; } } 
public class AlchemistsApprentice extends CardImpl { public AlchemistsApprentice ( UUID ownerId )  { super ( ownerId, 42, "Alchemist's Apprentice", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new SacrificeSourceCost (  )  )  ) ; } public AlchemistsApprentice ( final AlchemistsApprentice card )  { super ( card ) ; } @Override public AlchemistsApprentice copy (  )  { return new AlchemistsApprentice ( this ) ; } } 
public class AlchemistsRefuge extends CardImpl { private static final FilterCard filter = new FilterCard ( "nonland cards" ) ; static { filter . add ( Predicates . not ( new CardTypePredicate ( CardType . LAND )  )  ) ; } public AlchemistsRefuge ( UUID ownerId )  { super ( ownerId, 225, "Alchemist's Refuge", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new ColorlessManaAbility (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddContinuousEffectToGame ( new CastAsThoughItHadFlashAllEffect ( Duration . EndOfTurn, filter )  ) , new CompositeCost ( new ManaCostsImpl ( "{G}{U}" ) , new TapSourceCost (  ) , "{G}{U}, {T}" )  )  ) ; } public AlchemistsRefuge ( final AlchemistsRefuge card )  { super ( card ) ; } @Override public AlchemistsRefuge copy (  )  { return new AlchemistsRefuge ( this ) ; } } 
public class AmassTheComponents extends CardImpl { public AmassTheComponents ( UUID ownerId )  { super ( ownerId, 43, "Amass the Components", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new AmassTheComponentsEffect (  )  ) ; } public AmassTheComponents ( final AmassTheComponents card )  { super ( card ) ; } @Override public AmassTheComponents copy (  )  { return new AmassTheComponents ( this ) ; } } class AmassTheComponentsEffect extends OneShotEffect { public AmassTheComponentsEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Draw three cards, then put a card from your hand on the bottom of your library"; } public AmassTheComponentsEffect ( final AmassTheComponentsEffect effect )  { super ( effect ) ; } @Override public AmassTheComponentsEffect copy (  )  { return new AmassTheComponentsEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player == null )  { return false; } player . drawCards ( 3, game ) ; if  ( player . getHand (  )  . size (  )  > 0 )  { FilterCard filter = new FilterCard ( "card from your hand to put on the bottom of your library" ) ; TargetCard target = new TargetCard ( Zone . HAND, filter ) ; if  ( player . choose ( Outcome . Detriment, player . getHand (  ) , target, game )  )  { Card card = player . getHand (  )  . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { player . removeFromHand ( card, game ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } } } return true; } } 
public class AngelicArmaments extends CardImpl { public AngelicArmaments ( UUID ownerId )  { super ( ownerId, 212, "Angelic Armaments", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 2, 2 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardColorAttachedEffect ( ObjectColor . WHITE, Duration . WhileOnBattlefield, AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardSubtypeAttachedEffect ( "Angel", Duration . WhileOnBattlefield, AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . BoostCreature, new GenericManaCost ( 4 )  )  ) ; } public AngelicArmaments ( final AngelicArmaments card )  { super ( card ) ; } @Override public AngelicArmaments copy (  )  { return new AngelicArmaments ( this ) ; } } 
public class AngelOfGlorysRise extends CardImpl { public AngelOfGlorysRise ( UUID ownerId )  { super ( ownerId, 1, "Angel of Glory's Rise", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new AngelOfGlorysRiseEffect (  )  ) ; this . addAbility ( ability ) ; } public AngelOfGlorysRise ( final AngelOfGlorysRise card )  { super ( card ) ; } @Override public AngelOfGlorysRise copy (  )  { return new AngelOfGlorysRise ( this ) ; } } class AngelOfGlorysRiseEffect extends OneShotEffect { private static final FilterCreatureCard filterHuman = new FilterCreatureCard (  ) ; private static final FilterCreaturePermanent filterZombie = new FilterCreaturePermanent (  ) ; static { filterZombie . add ( new SubtypePredicate ( "Zombie" )  ) ; filterHuman . add ( new SubtypePredicate ( "Human" )  ) ; } public AngelOfGlorysRiseEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "Exile all Zombies, then return all Human creature cards from your graveyard to the battlefield"; } public AngelOfGlorysRiseEffect ( final AngelOfGlorysRiseEffect effect )  { super ( effect ) ; } @Override public AngelOfGlorysRiseEffect copy (  )  { return new AngelOfGlorysRiseEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { for  ( Permanent zombie : game . getBattlefield (  )  . getActivePermanents ( filterZombie, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { zombie . moveToExile ( source . getSourceId (  ) , zombie . getName (  ) , source . getSourceId (  ) , game ) ; } for  ( Card human : player . getGraveyard (  )  . getCards ( filterHuman, game )  )  { human . putOntoBattlefield ( game, Zone . GRAVEYARD, source . getSourceId (  ) , source . getControllerId (  )  ) ; } } return true; } } 
public class AngelOfJubilation extends CardImpl { private static final FilterCreaturePermanent filterNonBlack = new FilterCreaturePermanent ( "nonblack creatures" ) ; static { filterNonBlack . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public AngelOfJubilation ( UUID ownerId )  { super ( ownerId, 2, "Angel of Jubilation", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1, 1, Duration . WhileOnBattlefield, filterNonBlack, true )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AngelOfJubilationEffect ( Duration . WhileOnBattlefield )  )  ) ; } public AngelOfJubilation ( final AngelOfJubilation card )  { super ( card ) ; } @Override public AngelOfJubilation copy (  )  { return new AngelOfJubilation ( this ) ; } } class AngelOfJubilationEffect extends ContinuousEffectImpl { public AngelOfJubilationEffect ( Duration duration )  { super ( duration, Layer . PlayerEffects, SubLayer . NA, Outcome . Detriment ) ; staticText = "Players can't pay life or sacrifice creatures to cast spells or activate abilities"; } public AngelOfJubilationEffect ( final AngelOfJubilationEffect effect )  { super ( effect ) ; } @Override public AngelOfJubilationEffect copy (  )  { return new AngelOfJubilationEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Player player : game . getPlayers (  )  . values (  )  )  { player . setCanPayLifeCost ( false ) ; player . setCanPaySacrificeCost ( false ) ; } return true; } } 
public class AngelsTomb extends CardImpl { public AngelsTomb ( UUID ownerId )  { super ( ownerId, 211, "Angel's Tomb", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new CreatureEntersBattlefieldTriggeredAbility ( new BecomesCreatureSourceEffect ( new AngelTombToken (  ) , "", Duration . EndOfTurn ) , true )  ) ; } public AngelsTomb ( final AngelsTomb card )  { super ( card ) ; } @Override public AngelsTomb copy (  )  { return new AngelsTomb ( this ) ; } } class AngelTombToken extends Token { public AngelTombToken (  )  { super ( "", "a 3/3 white Angel artifact creature with flying" ) ; cardType . add ( CardType . ARTIFACT ) ; cardType . add ( CardType . CREATURE ) ; color . setWhite ( true ) ; subtype . add ( "Angel" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class AppetiteForBrains extends CardImpl { private static final FilterCard filter = new FilterCard ( "a card from it with converted mana cost 4 or greater" ) ; static { filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . GreaterThan, 3 )  ) ; } public AppetiteForBrains ( UUID ownerId )  { super ( ownerId, 84, "Appetite for Brains", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ExileCardYouChooseTargetOpponentEffect ( filter )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public AppetiteForBrains ( final AppetiteForBrains card )  { super ( card ) ; } @Override public AppetiteForBrains copy (  )  { return new AppetiteForBrains ( this ) ; } } 
public class ArcaneMelee extends CardImpl { public ArcaneMelee ( UUID ownerId )  { super ( ownerId, 44, "Arcane Melee", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{4}{U}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ArcaneMeleeCostReductionEffect (  )  )  ) ; } public ArcaneMelee ( final ArcaneMelee card )  { super ( card ) ; } @Override public ArcaneMelee copy (  )  { return new ArcaneMelee ( this ) ; } } class ArcaneMeleeCostReductionEffect extends CostModificationEffectImpl { ArcaneMeleeCostReductionEffect  (   )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "Instant and sorcery spells cost {2} less to cast"; } ArcaneMeleeCostReductionEffect ( ArcaneMeleeCostReductionEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { SpellAbility spellAbility =  ( SpellAbility )  abilityToModify; CardUtil . adjustCost ( spellAbility, 2 ) ; return true; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { if  (  abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility )  { Card sourceCard = game . getCard (  (  ( SpellAbility ) abilityToModify )  . getSourceId (  )  ) ; if  (  sourceCard != null &&  ( sourceCard . getCardType (  )  . contains ( CardType . INSTANT )  || sourceCard . getCardType (  )  . contains ( CardType . SORCERY )  )  )  { return true; } } return false; } @Override public ArcaneMeleeCostReductionEffect copy (  )  { return new ArcaneMeleeCostReductionEffect ( this ) ; } } 
public class Archangel extends CardImpl { public Archangel ( UUID ownerId )  { super ( ownerId, 5, "Archangel", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; } public Archangel ( final Archangel card )  { super ( card ) ; } @Override public Archangel copy (  )  { return new Archangel ( this ) ; } } 
public class ArchwingDragon extends CardImpl { public ArchwingDragon ( UUID ownerId )  { super ( ownerId, 126, "Archwing Dragon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new OnEventTriggeredAbility ( GameEvent . EventType . END_TURN_STEP_PRE, "beginning of the end step", new ReturnToHandSourceEffect ( true ) , false )  ) ; } public ArchwingDragon ( final ArchwingDragon card )  { super ( card ) ; } @Override public ArchwingDragon copy (  )  { return new ArchwingDragon ( this ) ; } } 
public class AvacynAngelOfHope extends CardImpl { public AvacynAngelOfHope ( UUID ownerId )  { super ( ownerId, 6, "Avacyn, Angel of Hope", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{5}{W}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 8 ) ; this . toughness = new MageInt ( 8 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( IndestructibleAbility . getInstance (  )  ) ; FilterControlledPermanent filter = new FilterControlledPermanent ( "Other permanents you control" ) ; Effect effect = new GainAbilityAllEffect ( IndestructibleAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter, true ) ; effect . setText ( "Other permanents you control are indestructible" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public AvacynAngelOfHope ( final AvacynAngelOfHope card )  { super ( card ) ; } @Override public AvacynAngelOfHope copy (  )  { return new AvacynAngelOfHope ( this ) ; } } 
public class BanishingStroke extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "artifact, creature, or enchantment" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . ARTIFACT ) , new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . ENCHANTMENT )  )  ) ; } public BanishingStroke ( UUID ownerId )  { super ( ownerId, 7, "Banishing Stroke", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{5}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( false )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{W}" )  )  ) ; } public BanishingStroke ( final BanishingStroke card )  { super ( card ) ; } @Override public BanishingStroke copy (  )  { return new BanishingStroke ( this ) ; } } 
public class BattleHymn extends CardImpl { public BattleHymn ( UUID ownerId )  { super ( ownerId, 128, "Battle Hymn", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DynamicManaEffect ( Mana . RedMana ( 1 ) , new PermanentsOnBattlefieldCount ( new FilterControlledCreaturePermanent (  )  )  )  ) ; } public BattleHymn ( final BattleHymn card )  { super ( card ) ; } @Override public BattleHymn copy (  )  { return new BattleHymn ( this ) ; } } 
public class BladedBracers extends CardImpl { private static final String ruleText = "As long as equipped creature is a Human or an Angel, it has vigilance"; public BladedBracers ( UUID ownerId )  { super ( ownerId, 213, "Bladed Bracers", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 1, 1 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new GainAbilityAttachedEffect ( VigilanceAbility . getInstance (  ) , AttachmentType . EQUIPMENT ) , new EquippedHasSubtypeCondition ( "Human", "Angel" ) , ruleText )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . BoostCreature, new GenericManaCost ( 2 )  )  ) ; } public BladedBracers ( final BladedBracers card )  { super ( card ) ; } @Override public BladedBracers copy (  )  { return new BladedBracers ( this ) ; } } 
public class BlessingsOfNature extends CardImpl { public BlessingsOfNature ( UUID ownerId )  { super ( ownerId, 168, "Blessings of Nature", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DistributeCountersEffect ( CounterType . P1P1, 4, false, "any number of target creatures" )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanentAmount ( 4 )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{G}" )  )  ) ; } public BlessingsOfNature ( final BlessingsOfNature card )  { super ( card ) ; } @Override public BlessingsOfNature copy (  )  { return new BlessingsOfNature ( this ) ; } } 
public class BloodArtist extends CardImpl { public BloodArtist ( UUID ownerId )  { super ( ownerId, 86, "Blood Artist", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new DiesThisOrAnotherCreatureTriggeredAbility ( new LoseLifeTargetEffect ( 1 ) , false ) ; ability . addEffect ( new GainLifeEffect ( 1 )  ) ; Target target = new TargetPlayer (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public BloodArtist ( final BloodArtist card )  { super ( card ) ; } @Override public BloodArtist copy (  )  { return new BloodArtist ( this ) ; } } 
public class BloodflowConnoisseur extends CardImpl { public BloodflowConnoisseur ( UUID ownerId )  { super ( ownerId, 87, "Bloodflow Connoisseur", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , new ManaCostsImpl (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; this . addAbility ( ability ) ; } public BloodflowConnoisseur ( final BloodflowConnoisseur card )  { super ( card ) ; } @Override public BloodflowConnoisseur copy (  )  { return new BloodflowConnoisseur ( this ) ; } } 
public class BonfireOfTheDamned extends CardImpl { public BonfireOfTheDamned ( UUID ownerId )  { super ( ownerId, 129, "Bonfire of the Damned", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{X}{X}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new BonfireOfTheDamnedEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{X}{R}" )  )  ) ; } public BonfireOfTheDamned ( final BonfireOfTheDamned card )  { super ( card ) ; } @Override public BonfireOfTheDamned copy (  )  { return new BonfireOfTheDamned ( this ) ; } } class BonfireOfTheDamnedEffect extends OneShotEffect { private static FilterPermanent filter = new FilterCreaturePermanent (  ) ; public BonfireOfTheDamnedEffect (  )  { super ( Outcome . Damage ) ; staticText = "{this} deals X damage to target player and each creature he or she controls"; } public BonfireOfTheDamnedEffect ( final BonfireOfTheDamnedEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null )  { int damage = source . getManaCostsToPay (  )  . getX (  ) ; if  ( damage > 0 )  { player . damage ( damage, source . getSourceId (  ) , game, false, true ) ; for  ( Permanent perm: game . getBattlefield (  )  . getAllActivePermanents ( filter, player . getId (  ) , game )  )  { perm . damage ( damage, source . getSourceId (  ) , game, false, true ) ; } } return true; } return false; } @Override public BonfireOfTheDamnedEffect copy (  )  { return new BonfireOfTheDamnedEffect ( this ) ; } } 
public class BowerPassage extends CardImpl { public BowerPassage ( UUID ownerId )  { super ( ownerId, 170, "Bower Passage", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BowerPassageEffect (  )  )  ) ; } public BowerPassage ( final BowerPassage card )  { super ( card ) ; } @Override public BowerPassage copy (  )  { return new BowerPassage ( this ) ; } } class BowerPassageEffect extends RestrictionEffect { BowerPassageEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "Creatures with flying can't block creatures you control"; } BowerPassageEffect ( final BowerPassageEffect effect )  { super ( effect ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { return true; } @Override public BowerPassageEffect copy (  )  { return new BowerPassageEffect ( this ) ; } @Override public boolean canBlock ( Permanent attacker, Permanent blocker, Ability source, Game game )  { if  ( attacker != null && attacker . getControllerId (  )  . equals ( source . getControllerId (  )  )  && blocker . getAbilities (  )  . contains ( FlyingAbility . getInstance (  )  )  )  { return false; } return true; } } 
public class BrunaLightOfAlabaster extends CardImpl { public BrunaLightOfAlabaster ( UUID ownerId )  { super ( ownerId, 208, "Bruna, Light of Alabaster", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{W}{W}{U}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( new AttacksOrBlocksTriggeredAbility ( new BrunaLightOfAlabasterEffect (  ) , true )  ) ; } public BrunaLightOfAlabaster ( final BrunaLightOfAlabaster card )  { super ( card ) ; } @Override public BrunaLightOfAlabaster copy (  )  { return new BrunaLightOfAlabaster ( this ) ; } } class BrunaLightOfAlabasterEffect extends OneShotEffect { public BrunaLightOfAlabasterEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "attach to it any number of Auras on the battlefield and you may put onto the battlefield attached to it any number of Aura cards that could enchant it from your graveyard and/or hand"; } public BrunaLightOfAlabasterEffect ( final BrunaLightOfAlabasterEffect effect )  { super ( effect ) ; } @Override public BrunaLightOfAlabasterEffect copy (  )  { return new BrunaLightOfAlabasterEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID bruna = source . getSourceId (  ) ; Player player = game . getPlayer ( source . getControllerId (  )  ) ; FilterPermanent filterAura = new FilterPermanent ( "Aura" ) ; FilterCard filterAuraCard = new FilterCard ( "Aura card" ) ; filterAura . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filterAura . add ( new SubtypePredicate ( "Aura" )  ) ; filterAura . add ( new AuraPermanentCanAttachToPermanentId ( bruna )  ) ; filterAuraCard . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filterAuraCard . add ( new SubtypePredicate ( "Aura" )  ) ; filterAuraCard . add ( new AuraCardCanAttachToPermanentId ( bruna )  ) ; if  ( player == null )  { return false; } Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent == null )  { return false; } while  ( player . canRespond (  )  && player . chooseUse ( Outcome . Benefit, "Attach an Aura from the battlefield?", source, game )  )  { Target targetAura = new TargetPermanent ( filterAura ) ; if  ( player . choose ( Outcome . Benefit, targetAura, source . getSourceId (  ) , game )  )  { Permanent aura = game . getPermanent ( targetAura . getFirstTarget (  )  ) ; if  ( aura != null )  { Permanent attachedTo = game . getPermanent ( aura . getAttachedTo (  )  ) ; if  ( attachedTo != null )  { attachedTo . removeAttachment ( aura . getId (  ) , game ) ; } permanent . addAttachment ( aura . getId (  ) , game ) ; } } } int count = player . getHand (  )  . count ( filterAuraCard, game ) ; while  ( player . canRespond (  )  && count > 0 && player . chooseUse ( Outcome . Benefit, "Attach an Aura from your hand?", source, game )  )  { TargetCard targetAura = new TargetCard ( Zone . HAND, filterAuraCard ) ; if  ( player . choose ( Outcome . Benefit, player . getHand (  ) , targetAura, game )  )  { Card aura = game . getCard ( targetAura . getFirstTarget (  )  ) ; if  ( aura != null )  { game . getState (  )  . setValue ( "attachTo:" + aura . getId (  ) , permanent ) ; aura . putOntoBattlefield ( game, Zone . HAND, source . getSourceId (  ) , player . getId (  )  ) ; permanent . addAttachment ( aura . getId (  ) , game ) ; } } count = player . getHand (  )  . count ( filterAuraCard, game ) ; } count = player . getGraveyard (  )  . count ( filterAuraCard, game ) ; while  ( player . canRespond (  )  && count > 0 && player . chooseUse ( Outcome . Benefit, "Attach an Aura from your graveyard?", source, game )  )  { TargetCard targetAura = new TargetCard ( Zone . GRAVEYARD, filterAuraCard ) ; if  ( player . choose ( Outcome . Benefit, player . getGraveyard (  ) , targetAura, game )  )  { Card aura = game . getCard ( targetAura . getFirstTarget (  )  ) ; if  ( aura != null )  { game . getState (  )  . setValue ( "attachTo:" + aura . getId (  ) , permanent ) ; aura . putOntoBattlefield ( game, Zone . GRAVEYARD, source . getSourceId (  ) , player . getId (  )  ) ; permanent . addAttachment ( aura . getId (  ) , game ) ; } } count = player . getGraveyard (  )  . count ( filterAuraCard, game ) ; } return true; } } 
public class BuildersBlessing extends CardImpl { public BuildersBlessing ( UUID ownerId )  { super ( ownerId, 8, "Builder's Blessing", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 0, 2, Duration . WhileOnBattlefield, new FilterUntappedCreature (  )  )  )  ) ; } public BuildersBlessing ( final BuildersBlessing card )  { super ( card ) ; } @Override public BuildersBlessing copy (  )  { return new BuildersBlessing ( this ) ; } } 
public class BurnAtTheStake extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creatures you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public BurnAtTheStake ( UUID ownerId )  { super ( ownerId, 130, "Burn at the Stake", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{R}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addCost ( new TapVariableTargetCost ( filter, true, "any number of" )  ) ; this . getSpellAbility (  )  . addEffect ( new BurnAtTheStakeEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public BurnAtTheStake ( final BurnAtTheStake card )  { super ( card ) ; } @Override public BurnAtTheStake copy (  )  { return new BurnAtTheStake ( this ) ; } } class BurnAtTheStakeEffect extends OneShotEffect { public BurnAtTheStakeEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "{this} deals damage to target creature or player equal to three times the number of creatures tapped this way"; } public BurnAtTheStakeEffect ( final BurnAtTheStakeEffect effect )  { super ( effect ) ; } @Override public BurnAtTheStakeEffect copy (  )  { return new BurnAtTheStakeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int amount =  ( new GetXValue (  )  )  . calculate ( game, source, this )  * 3; Permanent permanent = game . getPermanent ( targetPointer . getFirst ( game, source )  ) ; if  ( permanent != null )  { permanent . damage ( amount, source . getSourceId (  ) , game, false, true ) ; return true; } Player player = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( player != null )  { player . damage ( amount, source . getSourceId (  ) , game, false, true ) ; return true; } return false; } } 
public class ButcherGhoul extends CardImpl { public ButcherGhoul ( UUID ownerId )  { super ( ownerId, 89, "Butcher Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public ButcherGhoul ( final ButcherGhoul card )  { super ( card ) ; } @Override public ButcherGhoul copy (  )  { return new ButcherGhoul ( this ) ; } } 
public class CallToServe extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonblack creature" ) ; static { filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public CallToServe ( UUID ownerId )  { super ( ownerId, 9, "Call to Serve", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent ( filter ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1, 2, Duration . WhileOnBattlefield )  ) ; Effect effect = new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( ", has flying" ) ; ability . addEffect ( effect ) ; effect = new AddCardSubtypeAttachedEffect ( "Angel", Duration . WhileOnBattlefield, AttachmentType . AURA ) ; effect . setText ( ", and is an Angel in addition to its other types" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public CallToServe ( final CallToServe card )  { super ( card ) ; } @Override public CallToServe copy (  )  { return new CallToServe ( this ) ; } } 
public class CaptainOfTheMists extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "another Human" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new SubtypePredicate ( "Human" )  ) ; } public CaptainOfTheMists ( UUID ownerId )  { super ( ownerId, 45, "Captain of the Mists", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( new UntapSourceEffect (  ) , filter )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new MayTapOrUntapTargetEffect (  ) , new ManaCostsImpl ( "{1}{U}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( ability ) ; } public CaptainOfTheMists ( final CaptainOfTheMists card )  { super ( card ) ; } @Override public CaptainOfTheMists copy (  )  { return new CaptainOfTheMists ( this ) ; } } 
public class CatharsCrusade extends CardImpl { public CatharsCrusade ( UUID ownerId )  { super ( ownerId, 10, "Cathars' Crusade", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new CreatureEntersBattlefieldTriggeredAbility ( new AddCountersAllEffect ( CounterType . P1P1 . createInstance (  ) , new FilterControlledCreaturePermanent (  )  )  )  ) ; } public CatharsCrusade ( final CatharsCrusade card )  { super ( card ) ; } @Override public CatharsCrusade copy (  )  { return new CatharsCrusade ( this ) ; } } 
public class CathedralSanctifier extends CardImpl { public CathedralSanctifier ( UUID ownerId )  { super ( ownerId, 11, "Cathedral Sanctifier", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( 3 )  )  ) ; } public CathedralSanctifier ( final CathedralSanctifier card )  { super ( card ) ; } @Override public CathedralSanctifier copy (  )  { return new CathedralSanctifier ( this ) ; } } 
public class CavernOfSouls extends CardImpl { public CavernOfSouls ( UUID ownerId )  { super ( ownerId, 226, "Cavern of Souls", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new AsEntersBattlefieldAbility ( new ChooseCreatureTypeEffect ( Outcome . BoostCreature )  )  ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new ConditionalAnyColorManaAbility ( new TapSourceCost (  ) , 1, new CavernOfSoulsManaBuilder (  ) , true ) ; this . addAbility ( ability, new CavernOfSoulsWatcher ( ability . getOriginalId (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new CavernOfSoulsCantCounterEffect (  )  )  ) ; } public CavernOfSouls ( final CavernOfSouls card )  { super ( card ) ; } @Override public CavernOfSouls copy (  )  { return new CavernOfSouls ( this ) ; } } class CavernOfSoulsManaBuilder extends ConditionalManaBuilder { String creatureType; @Override public ConditionalManaBuilder setMana ( Mana mana, Ability source, Game game )  { Object value = game . getState (  )  . getValue ( source . getSourceId (  )  + "_type" ) ; if  ( value != null && value instanceof String )  { creatureType =  ( String )  value; } Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller != null && sourceObject != null )  { game . informPlayers ( controller . getLogName (  )  + " produces " + mana . toString (  )  + " with " + sourceObject . getLogName (  )  + "  ( can only be spend to cast for creatures of type " + creatureType + " and that spell can't be countered ) " ) ; } return super . setMana ( mana, source, game ) ; } @Override public ConditionalMana build ( Object .  options )  { return new CavernOfSoulsConditionalMana ( this . mana, creatureType ) ; } @Override public String getRule (  )  { return "Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered"; } } class CavernOfSoulsConditionalMana extends ConditionalMana { public CavernOfSoulsConditionalMana ( Mana mana, String creatureType )  { super ( mana ) ; staticText = "Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered"; addCondition ( new CavernOfSoulsManaCondition ( creatureType )  ) ; } } class CavernOfSoulsManaCondition extends CreatureCastManaCondition { String creatureType; CavernOfSoulsManaCondition ( String creatureType )  { this . creatureType = creatureType; } @Override public boolean apply ( Game game, Ability source, UUID originalId, Cost costToPay )  { if  ( super . apply ( game, source )  )  { MageObject object = game . getObject ( source . getSourceId (  )  ) ; if  ( creatureType != null && object . hasSubtype ( creatureType )  )  { return true; } } return false; } } class CavernOfSoulsWatcher extends Watcher { private List<UUID> spells = new ArrayList<> (  ) ; private final String originalId; public CavernOfSoulsWatcher ( UUID originalId )  { super ( "ManaPaidFromCavernOfSoulsWatcher", WatcherScope . CARD ) ; this . originalId = originalId . toString (  ) ; } public CavernOfSoulsWatcher ( final CavernOfSoulsWatcher watcher )  { super ( watcher ) ; this . spells . addAll ( watcher . spells ) ; this . originalId = watcher . originalId; } @Override public CavernOfSoulsWatcher copy (  )  { return new CavernOfSoulsWatcher ( this ) ; } @Override public void watch ( GameEvent event, Game game )  { if  ( event . getType (  )  == GameEvent . EventType . MANA_PAYED )  { if  ( event . getData (  )  != null && event . getData (  )  . equals ( originalId )  )  { spells . add ( event . getTargetId (  )  ) ; } } } public boolean spellCantBeCountered ( UUID spellId )  { return spells . contains ( spellId ) ; } @Override public void reset (  )  { super . reset (  ) ; spells . clear (  ) ; } } class CavernOfSoulsCantCounterEffect extends ContinuousRuleModifyingEffectImpl { public CavernOfSoulsCantCounterEffect (  )  { super ( Duration . EndOfGame, Outcome . Benefit ) ; staticText = null; } public CavernOfSoulsCantCounterEffect ( final CavernOfSoulsCantCounterEffect effect )  { super ( effect ) ; } @Override public CavernOfSoulsCantCounterEffect copy (  )  { return new CavernOfSoulsCantCounterEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public String getInfoMessage ( Ability source, GameEvent event, Game game )  { MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( sourceObject != null )  { return "This spell can't be countered because a colored mana from " + sourceObject . getName (  )  + " was spent to cast it . "; } return null; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . COUNTER; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { CavernOfSoulsWatcher watcher =  ( CavernOfSoulsWatcher )  game . getState (  )  . getWatchers (  )  . get ( "ManaPaidFromCavernOfSoulsWatcher", source . getSourceId (  )  ) ; Spell spell = game . getStack (  )  . getSpell ( event . getTargetId (  )  ) ; return spell != null && watcher != null && watcher . spellCantBeCountered ( spell . getId (  )  ) ; } } 
public class ChampionOfLambholt extends CardImpl { public ChampionOfLambholt ( UUID ownerId )  { super ( ownerId, 171, "Champion of Lambholt", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ChampionOfLambholtEffect (  )  )  ) ; this . addAbility ( new EntersAnotherCreatureYourControlTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  )  )  ) ; } public ChampionOfLambholt ( final ChampionOfLambholt card )  { super ( card ) ; } @Override public ChampionOfLambholt copy (  )  { return new ChampionOfLambholt ( this ) ; } } class ChampionOfLambholtEffect extends RestrictionEffect { ChampionOfLambholtEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "Creatures with power less than {this}'s power can't block creatures you control"; } ChampionOfLambholtEffect ( final ChampionOfLambholtEffect effect )  { super ( effect ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { return true; } return false; } @Override public boolean canBlock ( Permanent attacker, Permanent blocker, Ability source, Game game )  { if  ( attacker != null && blocker != null )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && attacker . getControllerId (  )  . equals ( sourcePermanent . getControllerId (  )  )  )  { return blocker . getPower (  )  . getValue (  )  >= sourcePermanent . getPower (  )  . getValue (  ) ; } } return true; } @Override public ChampionOfLambholtEffect copy (  )  { return new ChampionOfLambholtEffect ( this ) ; } } 
public class Cloudshift extends CardImpl { public Cloudshift ( UUID ownerId )  { super ( ownerId, 12, "Cloudshift", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; Effect effect = new ExileTargetForSourceEffect (  ) ; effect . setApplyEffectsAfter (  ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addEffect ( new ReturnToBattlefieldUnderYourControlTargetEffect ( true )  ) ; } public Cloudshift ( final Cloudshift card )  { super ( card ) ; } @Override public Cloudshift copy (  )  { return new Cloudshift ( this ) ; } } 
public class CorpseTraders extends CardImpl { public CorpseTraders ( UUID ownerId )  { super ( ownerId, 90, "Corpse Traders", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new ActivateAsSorceryActivatedAbility ( Zone . BATTLEFIELD, new DiscardCardYouChooseTargetEffect (  ) , new ManaCostsImpl ( "{2}{B}" )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; this . addAbility ( ability ) ; } public CorpseTraders ( final CorpseTraders card )  { super ( card ) ; } @Override public CorpseTraders copy (  )  { return new CorpseTraders ( this ) ; } } 
public class CraterhoofBehemoth extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public CraterhoofBehemoth ( UUID ownerId )  { super ( ownerId, 172, "Craterhoof Behemoth", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{5}{G}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new GainAbilityControlledEffect ( TrampleAbility . getInstance (  ) , Duration . EndOfTurn, filter )  ) ; PermanentsOnBattlefieldCount controlledCreatures = new PermanentsOnBattlefieldCount ( new FilterControlledCreaturePermanent ( "the number of creatures you control" ) , null ) ; ability . addEffect ( new BoostControlledEffect ( controlledCreatures, controlledCreatures, Duration . EndOfTurn, filter, false, true )  ) ; this . addAbility ( ability ) ; } public CraterhoofBehemoth ( final CraterhoofBehemoth card )  { super ( card ) ; } @Override public CraterhoofBehemoth copy (  )  { return new CraterhoofBehemoth ( this ) ; } } 
public class CripplingChill extends CardImpl { public CripplingChill ( UUID ownerId )  { super ( ownerId, 46, "Crippling Chill", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new TapTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DontUntapInControllersNextUntapStepTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public CripplingChill ( final CripplingChill card )  { super ( card ) ; } @Override public CripplingChill copy (  )  { return new CripplingChill ( this ) ; } } 
public class CryptCreeper extends CardImpl { public CryptCreeper ( UUID ownerId )  { super ( ownerId, 91, "Crypt Creeper", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ExileTargetEffect (  ) , new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCardInGraveyard (  )  ) ; this . addAbility ( ability ) ; } public CryptCreeper ( final CryptCreeper card )  { super ( card ) ; } @Override public CryptCreeper copy (  )  { return new CryptCreeper ( this ) ; } } 
public class Cursebreak extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "enchantment" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public Cursebreak ( UUID ownerId )  { super ( ownerId, 14, "Cursebreak", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 2 )  ) ; } public Cursebreak ( final Cursebreak card )  { super ( card ) ; } @Override public Cursebreak copy (  )  { return new Cursebreak ( this ) ; } } 
public class DangerousWager extends CardImpl { public DangerousWager ( UUID ownerId )  { super ( ownerId, 131, "Dangerous Wager", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DangerousWagerEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 2 )  ) ; } public DangerousWager ( final DangerousWager card )  { super ( card ) ; } @Override public DangerousWager copy (  )  { return new DangerousWager ( this ) ; } } class DangerousWagerEffect extends OneShotEffect { public DangerousWagerEffect (  )  { super ( Outcome . Discard ) ; this . staticText = "Discard your hand"; } public DangerousWagerEffect ( final DangerousWagerEffect effect )  { super ( effect ) ; } @Override public DangerousWagerEffect copy (  )  { return new DangerousWagerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { for  ( Card card : player . getHand (  )  . getCards ( game )  )  { player . discard ( card, source, game ) ; } return true; } return false; } } 
public class DarkImpostor extends CardImpl { public DarkImpostor ( UUID ownerId )  { super ( ownerId, 92, "Dark Impostor", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Assassin" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ImprintTargetEffect (  ) , new ManaCostsImpl ( "{4}{B}{B}" )  ) ; ability . addEffect ( new ExileTargetEffect ( null, this . getIdName (  )  )  ) ; ability . addEffect ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DarkImpostorContinuousEffect (  )  )  ) ; } public DarkImpostor ( final DarkImpostor card )  { super ( card ) ; } @Override public DarkImpostor copy (  )  { return new DarkImpostor ( this ) ; } } class DarkImpostorContinuousEffect extends ContinuousEffectImpl { public DarkImpostorContinuousEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; staticText = "{this} has all activated abilities of all creature cards exiled with it"; } public DarkImpostorContinuousEffect ( final DarkImpostorContinuousEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent perm = game . getPermanent ( source . getSourceId (  )  ) ; if  ( perm != null )  { for  ( UUID imprintedId : perm . getImprinted (  )  )  { Card card = game . getCard ( imprintedId ) ; if  ( card != null )  { for  ( Ability ability : card . getAbilities (  )  )  { if  ( ability instanceof ActivatedAbility )  { perm . addAbility ( ability, source . getSourceId (  ) , game ) ; } } } } } return true; } @Override public DarkImpostorContinuousEffect copy (  )  { return new DarkImpostorContinuousEffect ( this ) ; } } 
public class DeadeyeNavigator extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{1}{U}: Exile this creature, then return it to the battlefield under your control . \""; public DeadeyeNavigator ( UUID ownerId )  { super ( ownerId, 47, "Deadeye Navigator", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ExileSourceEffect ( true ) , new ManaCostsImpl ( "{1}{U}" )  ) ; ability . addEffect ( new ReturnToBattlefieldUnderYourControlSourceEffect (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public DeadeyeNavigator ( final DeadeyeNavigator card )  { super ( card ) ; } @Override public DeadeyeNavigator copy (  )  { return new DeadeyeNavigator ( this ) ; } } 
public class DeathWind extends CardImpl { public DeathWind ( UUID ownerId )  { super ( ownerId, 93, "Death Wind", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{X}{B}" ) ; this . expansionSetCode = "AVR"; DynamicValue x = new SignInversionDynamicValue ( new ManacostVariableValue (  )  ) ; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( x, x, Duration . EndOfTurn, true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public DeathWind ( final DeathWind card )  { super ( card ) ; } @Override public DeathWind copy (  )  { return new DeathWind ( this ) ; } } 
public class Defang extends CardImpl { public Defang ( UUID ownerId )  { super ( ownerId, 15, "Defang", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new PreventAllDamageByAttachedEffect ( Duration . WhileOnBattlefield, "enchanted creature", false )  )  ) ; } public Defang ( final Defang card )  { super ( card ) ; } @Override public Defang copy (  )  { return new Defang ( this ) ; } } 
public class DefyDeath extends CardImpl { public DefyDeath ( UUID ownerId )  { super ( ownerId, 16, "Defy Death", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToBattlefieldTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DefyDeathEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "creature card from your graveyard" )  )  ) ; } public DefyDeath ( final DefyDeath card )  { super ( card ) ; } @Override public DefyDeath copy (  )  { return new DefyDeath ( this ) ; } } class DefyDeathEffect extends OneShotEffect { public DefyDeathEffect (  )  { super ( Outcome . BoostCreature ) ; this . staticText = "If it's an Angel, put two +1/+1 counters on it"; } public DefyDeathEffect ( final DefyDeathEffect effect )  { super ( effect ) ; } @Override public DefyDeathEffect copy (  )  { return new DefyDeathEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null && permanent . hasSubtype ( "Angel" )  )  { permanent . addCounters ( CounterType . P1P1 . createInstance ( 2 ) , game ) ; return true; } return false; } } 
public class DemonicRising extends CardImpl { private static final String ruleText = "At the beginning of your end step, if you control exactly one creature, put a 5/5 black Demon creature token with flying onto the battlefield"; public DemonicRising ( UUID ownerId )  { super ( ownerId, 94, "Demonic Rising", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; TriggeredAbility ability = new BeginningOfYourEndStepTriggeredAbility ( new CreateTokenEffect ( new DemonToken (  )  ) , false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, OneControlledCreatureCondition . getInstance (  ) , ruleText )  ) ; } public DemonicRising ( final DemonicRising card )  { super ( card ) ; } @Override public DemonicRising copy (  )  { return new DemonicRising ( this ) ; } } 
public class DemonicTaskmaster extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "a creature other than Demonic Taskmaster" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public DemonicTaskmaster ( UUID ownerId )  { super ( ownerId, 95, "Demonic Taskmaster", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( new SacrificeEffect ( filter, 1, "" ) , TargetController . YOU, false ) ; this . addAbility ( ability ) ; } public DemonicTaskmaster ( final DemonicTaskmaster card )  { super ( card ) ; } @Override public DemonicTaskmaster copy (  )  { return new DemonicTaskmaster ( this ) ; } } 
public class DemonlordOfAshmouth extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( " another creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public DemonlordOfAshmouth ( UUID ownerId )  { super ( ownerId, 96, "Demonlord of Ashmouth", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ExileSourceUnlessPaysEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public DemonlordOfAshmouth ( final DemonlordOfAshmouth card )  { super ( card ) ; } @Override public DemonlordOfAshmouth copy (  )  { return new DemonlordOfAshmouth ( this ) ; } } 
public class DescendantsPath extends CardImpl { public DescendantsPath ( UUID ownerId )  { super ( ownerId, 173, "Descendants' Path", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; Ability ability = new BeginningOfUpkeepTriggeredAbility ( new DescendantsPathEffect (  ) , TargetController . YOU, false ) ; this . addAbility ( ability ) ; } public DescendantsPath ( final DescendantsPath card )  { super ( card ) ; } @Override public DescendantsPath copy (  )  { return new DescendantsPath ( this ) ; } } class DescendantsPathEffect extends OneShotEffect { public DescendantsPathEffect (  )  { super ( Outcome . Discard ) ; this . staticText = "reveal the top card of your library .  If it's a creature card that shares a creature type with a creature you control, you may cast that card without paying its mana cost .  Otherwise, put that card on the bottom of your library"; } public DescendantsPathEffect ( final DescendantsPathEffect effect )  { super ( effect ) ; } @Override public DescendantsPathEffect copy (  )  { return new DescendantsPathEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = source . getSourceObject ( game ) ; if  ( controller != null && sourceObject != null )  { if  ( controller . getLibrary (  )  . size (  )  > 0 )  { Card card = controller . getLibrary (  )  . getFromTop ( game ) ; if  ( card == null )  { return false; } controller . revealCards ( sourceObject . getIdName (  ) , new CardsImpl ( card ) , game ) ; if  ( card . getCardType (  )  . contains ( CardType . CREATURE )  )  { FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; boolean found = false; for  ( Permanent permanent: game . getBattlefield (  )  . getAllActivePermanents ( filter, controller . getId (  ) , game )  )  { if  ( CardUtil . shareSubtypes ( card, permanent )  )  { found = true; break; } } if  ( found )  { game . informPlayers ( sourceObject . getLogName (  )  + ": Found a creature that shares a creature type with the revealed card . " ) ; if  ( controller . chooseUse ( Outcome . Benefit, "Cast the card?", source, game )  )  { controller . cast ( card . getSpellAbility (  ) , game, true ) ; } else { game . informPlayers ( sourceObject . getLogName (  )  + ": " + controller . getLogName (  )  + " canceled casting the card . " ) ; controller . getLibrary (  )  . putOnBottom ( card, game ) ; } } else { game . informPlayers ( sourceObject . getLogName (  )  + ": No creature that shares a creature type with the revealed card . " ) ; controller . getLibrary (  )  . putOnBottom ( card, game ) ; } } else { game . informPlayers ( sourceObject . getLogName (  )  + ": Put " + card . getLogName (  )  + " on the bottom . " ) ; controller . getLibrary (  )  . putOnBottom ( card, game ) ; } return true; } } return false; } } 
public class DescentIntoMadness extends CardImpl { public DescentIntoMadness ( UUID ownerId )  { super ( ownerId, 97, "Descent into Madness", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new DescentIntoMadnessEffect (  ) , TargetController . YOU, false )  ) ; } public DescentIntoMadness ( final DescentIntoMadness card )  { super ( card ) ; } @Override public DescentIntoMadness copy (  )  { return new DescentIntoMadness ( this ) ; } } class DescentIntoMadnessEffect extends OneShotEffect { public DescentIntoMadnessEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "put a despair counter on {this}, then each player exiles X permanents he or she controls and/or cards from his or her hand, where X is the number of despair counters on {this}"; } public DescentIntoMadnessEffect ( final DescentIntoMadnessEffect effect )  { super ( effect ) ; } @Override public DescentIntoMadnessEffect copy (  )  { return new DescentIntoMadnessEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && controller != null )  { sourcePermanent . addCounters ( CounterType . DESPAIR . createInstance (  ) , game ) ; } if  ( sourcePermanent == null )  { sourcePermanent =  ( Permanent )  game . getLastKnownInformation ( source . getSourceId (  ) , Zone . BATTLEFIELD ) ; } if  ( sourcePermanent != null && controller != null )  { int count = sourcePermanent . getCounters (  )  . getCount ( CounterType . DESPAIR ) ; if  ( count > 0 )  { LinkedList<UUID> selectedObjects = new LinkedList<> (  ) ; PlayerList playerList = game . getState (  )  . getPlayerList ( controller . getId (  )  ) ; Player currentPlayer = controller; do { selectCards ( currentPlayer, selectedObjects, count, source, game ) ; currentPlayer = playerList . getNextInRange ( controller, game ) ; } while  ( !currentPlayer . equals ( controller )  && controller . canRespond (  )  ) ; for  ( UUID objectId : selectedObjects )  { if  ( game . getState (  )  . getZone ( objectId )  . equals ( Zone . BATTLEFIELD )  )  { Permanent permanent = game . getPermanent ( objectId ) ; if  ( permanent != null )  { Player player = game . getPlayer ( permanent . getControllerId (  )  ) ; if  ( player != null )  { player . moveCardToExileWithInfo ( permanent, null, "", source . getSourceId (  ) , game, Zone . BATTLEFIELD, true ) ; } } } else if  ( game . getState (  )  . getZone ( objectId )  . equals ( Zone . HAND )  )  { Card card = game . getCard ( objectId ) ; if  ( card != null )  { Player player = game . getPlayer ( card . getOwnerId (  )  ) ; if  ( player != null )  { player . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . HAND, true ) ; } } } } } return true; } return false; } private void selectCards ( Player player, List<UUID> selectedObjects, int count, Ability source, Game game )  { int amount = Math . min ( count, player . getHand (  )  . size (  )  + game . getBattlefield (  )  . getAllActivePermanents ( player . getId (  )  )  . size (  )  ) ; int cardsFromHand = 0; while  ( player . canRespond (  )  && amount > 0 )  { Target target; do { FilterControlledPermanent filter = new FilterControlledPermanent (  ) ; filter . setMessage ( "permanent you control  ( " + amount + " left in total ) "  ) ; List<PermanentIdPredicate> uuidPredicates = new ArrayList<> (  ) ; for  ( UUID uuid :selectedObjects )  { uuidPredicates . add ( new PermanentIdPredicate ( uuid )  ) ; } filter . add ( Predicates . not ( Predicates . or ( uuidPredicates )  )  ) ; target = new TargetControlledPermanent ( 0, 1, filter, true ) ; if  ( target . canChoose ( player . getId (  ) , game )  && player . choose ( Outcome . Exile, target, source . getSourceId (  ) , game )  )  { for  ( UUID targetId : target . getTargets (  )  )  { if  ( !selectedObjects . contains ( targetId )  )  { Permanent chosen = game . getPermanent ( targetId ) ; if  ( chosen != null )  { amount--; game . informPlayers ( player . getLogName (  )  + " selects " + chosen . getLogName (  )  + " from battlefield" ) ; selectedObjects . add ( targetId ) ; } } } } } while  ( amount > 0 && !target . getTargets (  )  . isEmpty (  )  && player . canRespond (  )  ) ; if  ( amount > 0 )  { TargetCard targetInHand; do { FilterCard filterInHand = new FilterCard (  ) ; filterInHand . setMessage ( "card from your hand  ( " + amount + " left in total ) " ) ; targetInHand = new TargetCard ( 0, 1, Zone . HAND, filterInHand ) ; List<CardIdPredicate> uuidPredicates = new ArrayList<> (  ) ; for  ( UUID uuid :selectedObjects )  { uuidPredicates . add ( new CardIdPredicate ( uuid )  ) ; } filterInHand . add ( Predicates . not ( Predicates . or ( uuidPredicates )  )  ) ; if  ( targetInHand . canChoose ( player . getId (  ) , game )  && player . choose ( Outcome . Exile, player . getHand (  ) , targetInHand, game )  )  { Card card = player . getHand (  )  . get ( targetInHand . getFirstTarget (  ) , game ) ; if  ( card != null )  { selectedObjects . add ( targetInHand . getFirstTarget (  )  ) ; amount--; cardsFromHand++; } } } while  ( amount > 0 && !targetInHand . getTargets (  )  . isEmpty (  )  && player . canRespond (  )  ) ; } } if  ( cardsFromHand > 0 )  { game . informPlayers ( player . getLogName (  )  + " selects " + cardsFromHand +  ( cardsFromHand == 1?" card":" cards" )  + " from his or her hand" ) ; } } } 
public class DesolateLighthouse extends CardImpl { public DesolateLighthouse ( UUID ownerId )  { super ( ownerId, 227, "Desolate Lighthouse", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new ColorlessManaAbility (  )  ) ; SimpleActivatedAbility ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawDiscardControllerEffect (  ) , new ManaCostsImpl ( "{1}{U}{R}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public DesolateLighthouse ( final DesolateLighthouse card )  { super ( card ) ; } @Override public DesolateLighthouse copy (  )  { return new DesolateLighthouse ( this ) ; } } 
public class DevastationTide extends CardImpl { public DevastationTide ( UUID ownerId )  { super ( ownerId, 48, "Devastation Tide", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DevastationTideEffect (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{1}{U}" )  )  ) ; } public DevastationTide ( final DevastationTide card )  { super ( card ) ; } @Override public DevastationTide copy (  )  { return new DevastationTide ( this ) ; } } class DevastationTideEffect extends OneShotEffect { public DevastationTideEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "Return all nonland permanents to their owners' hands"; } public DevastationTideEffect ( final DevastationTideEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Set<Card> cardsToHand = new LinkedHashSet<> (  ) ; for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( new FilterNonlandPermanent (  ) , source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { cardsToHand . add (  ( Card )  permanent ) ; } controller . moveCards ( cardsToHand, Zone . HAND, source, game ) ; return true; } return false; } @Override public DevastationTideEffect copy (  )  { return new DevastationTideEffect ( this ) ; } } 
public class DivineDeflection extends CardImpl { public DivineDeflection ( UUID ownerId )  { super ( ownerId, 18, "Divine Deflection", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{X}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DivineDeflectionPreventDamageTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public DivineDeflection ( final DivineDeflection card )  { super ( card ) ; } @Override public DivineDeflection copy (  )  { return new DivineDeflection ( this ) ; } } class DivineDeflectionPreventDamageTargetEffect extends PreventionEffectImpl { public DivineDeflectionPreventDamageTargetEffect ( Duration duration )  { super ( duration, Integer . MIN_VALUE, false, true ) ; staticText = "Prevent the next X damage that would be dealt to you and/or permanents you control this turn .  If damage is prevented this way, {this} deals that much damage to target creature or player"; } public DivineDeflectionPreventDamageTargetEffect ( final DivineDeflectionPreventDamageTargetEffect effect )  { super ( effect ) ; } @Override public DivineDeflectionPreventDamageTargetEffect copy (  )  { return new DivineDeflectionPreventDamageTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { /* If damage is dealt to multiple permanents you control, or is dealt to you and at least one permanent you control, you choose which of that damage to prevent if the chosen value for X won't prevent all the damage .  For example, if 3 damage would be dealt to you and to each of two creatures you control, and Divine Deflection will prevent the next 3 damage, you might choose to prevent the next 2 damage it would deal to you and the next 1 damage it would deal to one of the creatures, among other choices .  You don't decide until the point at which the damage would be dealt .  TODO: Support to select which damage to prevent */ PreventionEffectData preventionData = preventDamageAction ( event, source, game ) ; /* Divine Deflection's effect is not a redirection effect .  If it prevents damage, Divine Deflection  ( not the original source )  deals damage to the targeted creature or player as part of that prevention effect .  Divine Deflection is the source of the new damage, so the characteristics of the original source  ( such as its color, or whether it had lifelink or deathtouch )  don't affect this damage .  The new damage is not combat damage, even if the prevented damage was .  Since you control the source of the new damage, if you targeted an opponent with Divine Deflection, you may have Divine Deflection deal its damage to a planeswalker that opponent controls .  */ int prevented = preventionData . getPreventedDamage (  ) ; if  ( prevented > 0 )  { UUID dealDamageTo = source . getFirstTarget (  ) ; /* Whether the targeted creature or player is still a legal target is not checked after Divine Deflection resolves .  For example, if a creature targeted by Divine Deflection gains shroud after Divine Deflection resolves, Divine Deflection can still deal damage to that creature .  */ Permanent permanent = game . getPermanent ( dealDamageTo ) ; if  ( permanent != null )  { game . informPlayers ( "Dealing " + prevented + " to " + permanent . getName (  )  + " instead" ) ; permanent . damage ( prevented, source . getSourceId (  ) , game, false, true ) ; } Player player = game . getPlayer ( dealDamageTo ) ; if  ( player != null )  { game . informPlayers ( "Dealing " + prevented + " to " + player . getLogName (  )  + " instead" ) ; player . damage ( prevented, source . getSourceId (  ) , game, false, true ) ; } } return false; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( !this . used && super . applies ( event, source, game )  )  { if  ( amountToPrevent == Integer . MIN_VALUE )  { amountToPrevent = source . getManaCostsToPay (  )  . getX (  ) ; } Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null )  { if  ( permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  )  { return true; } } if  ( source . getControllerId (  )  . equals ( event . getTargetId (  )  )  )  { return true; } } return false; } } 
public class DreadSlaver extends CardImpl { public DreadSlaver ( UUID ownerId )  { super ( ownerId, 98, "Dread Slaver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DiesAndDealtDamageThisTurnTriggeredAbility ( new DreadSlaverEffect (  ) , false )  ) ; } public DreadSlaver ( final DreadSlaver card )  { super ( card ) ; } @Override public DreadSlaver copy (  )  { return new DreadSlaver ( this ) ; } } class DreadSlaverEffect extends OneShotEffect { public DreadSlaverEffect (  )  { super ( Outcome . Benefit ) ; staticText = "return it to the battlefield under your control .  That creature is a black Zombie in addition to its other colors and types"; } public DreadSlaverEffect ( final DreadSlaverEffect effect )  { super ( effect ) ; } @Override public DreadSlaverEffect copy (  )  { return new DreadSlaverEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card card = game . getCard ( targetPointer . getFirst ( game, source )  ) ; if  ( card != null )  { Zone currentZone = game . getState (  )  . getZone ( card . getId (  )  ) ; if  ( card . putOntoBattlefield ( game, currentZone, source . getSourceId (  ) , source . getControllerId (  )  )  )  { ContinuousEffect effect = new DreadSlaverContiniousEffect (  ) ; effect . setTargetPointer ( new FixedTarget ( card . getId (  )  )  ) ; game . addEffect ( effect, source ) ; return true; } } return false; } } class DreadSlaverContiniousEffect extends ContinuousEffectImpl { public DreadSlaverContiniousEffect (  )  { super ( Duration . Custom, Outcome . Neutral ) ; staticText = "That creature is a black Zombie in addition to its other colors and types"; } public DreadSlaverContiniousEffect ( final DreadSlaverContiniousEffect effect )  { super ( effect ) ; } @Override public DreadSlaverContiniousEffect copy (  )  { return new DreadSlaverContiniousEffect ( this ) ; } @Override public boolean apply ( Layer layer, SubLayer sublayer, Ability source, Game game )  { Permanent creature = game . getPermanent ( targetPointer . getFirst ( game, source )  ) ; if  ( creature != null )  { switch  ( layer )  { case TypeChangingEffects_4: if  ( sublayer == SubLayer . NA )  { creature . getSubtype (  )  . add ( "Zombie" ) ; } break; case ColorChangingEffects_5: if  ( sublayer == SubLayer . NA )  { creature . getColor ( game )  . setBlack ( true ) ; } break; } return true; } else { this . used = true; } return false; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean hasLayer ( Layer layer )  { return layer == Layer . ColorChangingEffects_5 || layer == Layer . TypeChangingEffects_4; } } 
public class Dreadwaters extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent ( "lands you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public Dreadwaters ( UUID ownerId )  { super ( ownerId, 49, "Dreadwaters", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new PutLibraryIntoGraveTargetEffect ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public Dreadwaters ( final Dreadwaters card )  { super ( card ) ; } @Override public Dreadwaters copy (  )  { return new Dreadwaters ( this ) ; } } 
public class DriverOfTheDead extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "creature card with converted mana cost 2 or less from your graveyard to the battlefield" ) ; static { filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, 3 )  ) ; } public DriverOfTheDead ( UUID ownerId )  { super ( ownerId, 99, "Driver of the Dead", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new DiesTriggeredAbility ( new ReturnFromGraveyardToBattlefieldTargetEffect (  ) , false ) ; Target target = new TargetCardInYourGraveyard ( filter ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public DriverOfTheDead ( final DriverOfTheDead card )  { super ( card ) ; } @Override public DriverOfTheDead copy (  )  { return new DriverOfTheDead ( this ) ; } } 
public class DruidsFamiliar extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures gets +2/+2"; public DruidsFamiliar ( UUID ownerId )  { super ( ownerId, 175, "Druid's Familiar", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Bear" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostPairedEffect ( 2, 2, ruleText )  )  ) ; } public DruidsFamiliar ( final DruidsFamiliar card )  { super ( card ) ; } @Override public DruidsFamiliar copy (  )  { return new DruidsFamiliar ( this ) ; } } 
public class DruidsRepository extends CardImpl { public DruidsRepository ( UUID ownerId )  { super ( ownerId, 176, "Druids' Repository", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new AttacksCreatureYouControlTriggeredAbility ( new AddCountersSourceEffect ( CounterType . CHARGE . createInstance (  )  )  )  ) ; Ability ability = new SimpleManaAbility ( Zone . BATTLEFIELD, new AddManaOfAnyColorEffect (  ) , new RemoveCountersSourceCost ( CounterType . CHARGE . createInstance (  )  )  ) ; this . addAbility ( ability ) ; } public DruidsRepository ( final DruidsRepository card )  { super ( card ) ; } @Override public DruidsRepository copy (  )  { return new DruidsRepository ( this ) ; } } 
public class DualCasting extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant or sorcery spell" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . INSTANT ) , new CardTypePredicate ( CardType . SORCERY )  )  ) ; filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DualCasting ( UUID ownerId )  { super ( ownerId, 133, "Dual Casting", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CopyTargetSpellEffect (  ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetSpell ( filter )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability, AttachmentType . AURA )  )  ) ; } public DualCasting ( final DualCasting card )  { super ( card ) ; } @Override public DualCasting copy (  )  { return new DualCasting ( this ) ; } } 
public class EatenBySpiders extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public EatenBySpiders ( UUID ownerId )  { super ( ownerId, 177, "Eaten by Spiders", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new EatenBySpidersEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public EatenBySpiders ( final EatenBySpiders card )  { super ( card ) ; } @Override public EatenBySpiders copy (  )  { return new EatenBySpiders ( this ) ; } } class EatenBySpidersEffect extends OneShotEffect { public EatenBySpidersEffect (  )  { super ( Outcome . DestroyPermanent ) ; this . staticText = "Destroy target creature with flying and all Equipment attached to that creature"; } public EatenBySpidersEffect ( final EatenBySpidersEffect effect )  { super ( effect ) ; } @Override public EatenBySpidersEffect copy (  )  { return new EatenBySpidersEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { LinkedList<UUID> attachments = new LinkedList<UUID> (  ) ; attachments . addAll ( permanent . getAttachments (  )  ) ; for  ( UUID attachmentId : attachments )  { Permanent attachment = game . getPermanent ( attachmentId ) ; if  ( attachment . hasSubtype ( "Equipment" )  )  { attachment . destroy ( source . getSourceId (  ) , game, false ) ; } } permanent . destroy ( source . getSourceId (  ) , game, false ) ; return true; } return false; } } 
public class ElgaudShieldmate extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have hexproof"; public ElgaudShieldmate ( UUID ownerId )  { super ( ownerId, 50, "Elgaud Shieldmate", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( HexproofAbility . getInstance (  ) , ruleText )  )  ) ; } public ElgaudShieldmate ( final ElgaudShieldmate card )  { super ( card ) ; } @Override public ElgaudShieldmate copy (  )  { return new ElgaudShieldmate ( this ) ; } } 
public class EmancipationAngel extends CardImpl { public EmancipationAngel ( UUID ownerId )  { super ( ownerId, 19, "Emancipation Angel", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ReturnToHandChosenControlledPermanentEffect ( new FilterControlledPermanent (  )  ) , false )  ) ; } public EmancipationAngel ( final EmancipationAngel card )  { super ( card ) ; } @Override public EmancipationAngel copy (  )  { return new EmancipationAngel ( this ) ; } } 
public class EntreatTheAngels extends CardImpl { public EntreatTheAngels ( UUID ownerId )  { super ( ownerId, 20, "Entreat the Angels", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{X}{X}{W}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new AngelToken (  ) , new ManacostVariableValue (  )  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{X}{W}{W}" )  )  ) ; } public EntreatTheAngels ( final EntreatTheAngels card )  { super ( card ) ; } @Override public EntreatTheAngels copy (  )  { return new EntreatTheAngels ( this ) ; } } 
public class EssenceHarvest extends CardImpl { public EssenceHarvest ( UUID ownerId )  { super ( ownerId, 100, "Essence Harvest", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new EssenceHarvestEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public EssenceHarvest ( final EssenceHarvest card )  { super ( card ) ; } @Override public EssenceHarvest copy (  )  { return new EssenceHarvest ( this ) ; } } class EssenceHarvestEffect extends OneShotEffect { public EssenceHarvestEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "Target player loses X life and you gain X life, where X is the greatest power among creatures you control"; } public EssenceHarvestEffect ( final EssenceHarvestEffect effect )  { super ( effect ) ; } @Override public EssenceHarvestEffect copy (  )  { return new EssenceHarvestEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null && targetPlayer != null )  { List<Permanent> creatures = game . getBattlefield (  )  . getAllActivePermanents ( new FilterCreaturePermanent (  ) , player . getId (  ) , game ) ; int amount = 0; for  ( Permanent creature : creatures )  { int power = creature . getPower (  )  . getValue (  ) ; if  ( amount < power )  { amount = power; } } if  ( amount > 0 )  { targetPlayer . loseLife ( amount, game ) ; player . gainLife ( amount, game ) ; } return true; } return false; } } 
public class EvernightShade extends CardImpl { public EvernightShade ( UUID ownerId )  { super ( ownerId, 101, "Evernight Shade", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Shade" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , new ManaCostsImpl ( "{B}" )  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public EvernightShade ( final EvernightShade card )  { super ( card ) ; } @Override public EvernightShade copy (  )  { return new EvernightShade ( this ) ; } } 
public class ExquisiteBlood extends CardImpl { public ExquisiteBlood ( UUID ownerId )  { super ( ownerId, 102, "Exquisite Blood", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; ExquisiteBloodTriggeredAbility ability = new ExquisiteBloodTriggeredAbility (  ) ; this . addAbility ( ability ) ; } public ExquisiteBlood ( final ExquisiteBlood card )  { super ( card ) ; } @Override public ExquisiteBlood copy (  )  { return new ExquisiteBlood ( this ) ; } } class ExquisiteBloodTriggeredAbility extends TriggeredAbilityImpl { public ExquisiteBloodTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, null ) ; } public ExquisiteBloodTriggeredAbility ( final ExquisiteBloodTriggeredAbility ability )  { super ( ability ) ; } @Override public ExquisiteBloodTriggeredAbility copy (  )  { return new ExquisiteBloodTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . LOST_LIFE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( game . getOpponents ( this . controllerId )  . contains ( event . getPlayerId (  )  )  )  { this . getEffects (  )  . clear (  ) ; this . addEffect ( new GainLifeEffect ( event . getAmount (  )  )  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever an opponent loses life, you gain that much life . "; } } 
public class FalkenrathExterminator extends CardImpl { public FalkenrathExterminator ( UUID ownerId )  { super ( ownerId, 134, "Falkenrath Exterminator", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Archer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( new CountersCount ( CounterType . P1P1 )  ) , new ManaCostsImpl ( "{2}{R}" )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public FalkenrathExterminator ( final FalkenrathExterminator card )  { super ( card ) ; } @Override public FalkenrathExterminator copy (  )  { return new FalkenrathExterminator ( this ) ; } } 
public class FarbogExplorer extends CardImpl { public FarbogExplorer ( UUID ownerId )  { super ( ownerId, 21, "Farbog Explorer", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SwampwalkAbility (  )  ) ; } public FarbogExplorer ( final FarbogExplorer card )  { super ( card ) ; } @Override public FarbogExplorer copy (  )  { return new FarbogExplorer ( this ) ; } } 
public class FavorableWinds extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures you control with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public FavorableWinds ( UUID ownerId )  { super ( ownerId, 51, "Favorable Winds", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1, 1, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public FavorableWinds ( final FavorableWinds card )  { super ( card ) ; } @Override public FavorableWinds copy (  )  { return new FavorableWinds ( this ) ; } } 
public class FerventCathar extends CardImpl { public FerventCathar ( UUID ownerId )  { super ( ownerId, 135, "Fervent Cathar", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new CantBlockTargetEffect ( Duration . EndOfTurn )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public FerventCathar ( final FerventCathar card )  { super ( card ) ; } @Override public FerventCathar copy (  )  { return new FerventCathar ( this ) ; } } 
public class GallowsAtWillowHill extends CardImpl { private static final FilterControlledPermanent humanFilter = new FilterControlledPermanent ( "untapped Human you control" ) ; static { humanFilter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; humanFilter . add ( new SubtypePredicate ( "Human" )  ) ; } public GallowsAtWillowHill ( UUID ownerId )  { super ( ownerId, 215, "Gallows at Willow Hill", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "AVR"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GallowsAtWillowHillEffect (  ) , new GenericManaCost ( 3 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new TapTargetCost ( new TargetControlledPermanent ( 3, 3, humanFilter, false )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public GallowsAtWillowHill ( final GallowsAtWillowHill card )  { super ( card ) ; } @Override public GallowsAtWillowHill copy (  )  { return new GallowsAtWillowHill ( this ) ; } } class GallowsAtWillowHillEffect extends OneShotEffect { public GallowsAtWillowHillEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy target creature .  Its controller puts a 1/1 white Spirit creature token with flying onto the battlefield"; } public GallowsAtWillowHillEffect ( final GallowsAtWillowHillEffect effect )  { super ( effect ) ; } @Override public GallowsAtWillowHillEffect copy (  )  { return new GallowsAtWillowHillEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int affectedTargets = 0; if  ( targetPointer . getTargets ( game, source )  . size (  )  > 0 )  { for  ( UUID permanentId : targetPointer . getTargets ( game, source )  )  { Permanent permanent = game . getPermanent ( permanentId ) ; if  ( permanent != null )  { Player controller = game . getPlayer ( permanent . getControllerId (  )  ) ; permanent . destroy ( source . getSourceId (  ) , game, false ) ; if  ( controller != null )  { new CreateTokenEffect ( new SpiritWhiteToken (  )  )  . apply ( game, source ) ; } affectedTargets++; } } } return affectedTargets > 0; } } 
public class GalvanicAlchemist extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{2}{U}: Untap this creature . \""; public GalvanicAlchemist ( UUID ownerId )  { super ( ownerId, 54, "Galvanic Alchemist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new UntapSourceEffect (  ) , new ManaCostsImpl ( "{2}{U}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public GalvanicAlchemist ( final GalvanicAlchemist card )  { super ( card ) ; } @Override public GalvanicAlchemist copy (  )  { return new GalvanicAlchemist ( this ) ; } } 
public class GangOfDevils extends CardImpl { public GangOfDevils ( UUID ownerId )  { super ( ownerId, 136, "Gang of Devils", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Devil" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new DiesTriggeredAbility ( new DamageMultiEffect ( 3 )  ) ; ability . addTarget ( new TargetCreatureOrPlayerAmount ( 3 )  ) ; this . addAbility ( ability ) ; } public GangOfDevils ( final GangOfDevils card )  { super ( card ) ; } @Override public GangOfDevils copy (  )  { return new GangOfDevils ( this ) ; } } 
public class GeistSnatch extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "creature spell" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public GeistSnatch ( UUID ownerId )  { super ( ownerId, 55, "Geist Snatch", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new GeistSnatchCounterTargetEffect (  )  ) ; } public GeistSnatch ( final GeistSnatch card )  { super ( card ) ; } @Override public GeistSnatch copy (  )  { return new GeistSnatch ( this ) ; } } class GeistSnatchCounterTargetEffect extends OneShotEffect { public GeistSnatchCounterTargetEffect (  )  { super ( Outcome . Detriment ) ; staticText = "Counter target creature spell .  Put a 1/1 blue Spirit creature token with flying onto the battlefield"; } public GeistSnatchCounterTargetEffect ( final GeistSnatchCounterTargetEffect effect )  { super ( effect ) ; } @Override public GeistSnatchCounterTargetEffect copy (  )  { return new GeistSnatchCounterTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { game . getStack (  )  . counter ( source . getFirstTarget (  ) , source . getSourceId (  ) , game ) ; Token token = new SpiritBlueToken (  ) ; token . putOntoBattlefield ( 1, game, source . getSourceId (  ) , source . getControllerId (  )  ) ; return true; } } class SpiritBlueToken extends Token { public SpiritBlueToken (  )  { super ( "Spirit", "1/1 blue Spirit creature token with flying" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Spirit" ) ; color . setBlue ( true ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; setTokenType ( 2 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class GeistTrappers extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have reach"; public GeistTrappers ( UUID ownerId )  { super ( ownerId, 179, "Geist Trappers", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ReachAbility . getInstance (  ) , ruleText )  )  ) ; } public GeistTrappers ( final GeistTrappers card )  { super ( card ) ; } @Override public GeistTrappers copy (  )  { return new GeistTrappers ( this ) ; } } 
public class Ghostform extends CardImpl { public Ghostform ( UUID ownerId )  { super ( ownerId, 56, "Ghostform", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CantBeBlockedTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 2 )  ) ; } public Ghostform ( final Ghostform card )  { super ( card ) ; } @Override public Ghostform copy (  )  { return new Ghostform ( this ) ; } } 
public class GhostlyFlicker extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "artifacts, creatures, and/or lands you control" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . LAND ) , new CardTypePredicate ( CardType . ARTIFACT )  )  ) ; } public GhostlyFlicker ( UUID ownerId )  { super ( ownerId, 57, "Ghostly Flicker", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetControlledPermanent ( 2, 2, filter, false )  ) ; this . getSpellAbility (  )  . addEffect ( new GhostlyFlickerEffect (  )  ) ; } public GhostlyFlicker ( final GhostlyFlicker card )  { super ( card ) ; } @Override public GhostlyFlicker copy (  )  { return new GhostlyFlicker ( this ) ; } } class GhostlyFlickerEffect extends OneShotEffect { public GhostlyFlickerEffect (  )  { super ( Outcome . Benefit ) ; staticText = "Exile two target artifacts, creatures, and/or lands you control, then return those cards to the battlefield under your control"; } public GhostlyFlickerEffect ( final GhostlyFlickerEffect effect )  { super ( effect ) ; } @Override public GhostlyFlickerEffect copy (  )  { return new GhostlyFlickerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID exileId = source . getSourceId (  ) ; for  ( UUID permanentId : targetPointer . getTargets ( game, source )  )  { Permanent target = game . getPermanent ( permanentId ) ; if  ( target != null )  { target . moveToExile ( exileId, "Ghostly Flicker", source . getSourceId (  ) , game ) ; Card card = game . getCard ( target . getId (  )  ) ; if  ( card != null )  { Zone currentZone = game . getState (  )  . getZone ( card . getId (  )  ) ; card . putOntoBattlefield ( game, currentZone, source . getSourceId (  ) , source . getControllerId (  )  ) ; } } } return true; } } 
public class GhostlyTouch extends CardImpl { public GhostlyTouch ( UUID ownerId )  { super ( ownerId, 58, "Ghostly Touch", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability gainedAbility = new AttacksTriggeredAbility ( new MayTapOrUntapTargetEffect (  ) , true ) ; gainedAbility . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA )  )  ) ; } public GhostlyTouch ( final GhostlyTouch card )  { super ( card ) ; } @Override public GhostlyTouch copy (  )  { return new GhostlyTouch ( this ) ; } } 
public class Ghoulflesh extends CardImpl { public Ghoulflesh ( UUID ownerId )  { super ( ownerId, 103, "Ghoulflesh", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . UnboostCreature )  ) ; this . addAbility ( new EnchantAbility ( auraTarget . getTargetName (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( -1, -1, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardSubtypeAttachedEffect ( "Zombie", Duration . WhileOnBattlefield, AttachmentType . AURA )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardColorAttachedEffect ( ObjectColor . BLACK, Duration . WhileOnBattlefield, AttachmentType . AURA )  )  ) ; } public Ghoulflesh ( final Ghoulflesh card )  { super ( card ) ; } @Override public Ghoulflesh copy (  )  { return new Ghoulflesh ( this ) ; } } 
public class GiselaBladeOfGoldnight extends CardImpl { public GiselaBladeOfGoldnight ( UUID ownerId )  { super ( ownerId, 209, "Gisela, Blade of Goldnight", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{R}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GiselaBladeOfGoldnightDoubleDamageEffect (  )  )  ) ; } public GiselaBladeOfGoldnight ( final GiselaBladeOfGoldnight card )  { super ( card ) ; } @Override public GiselaBladeOfGoldnight copy (  )  { return new GiselaBladeOfGoldnight ( this ) ; } } class GiselaBladeOfGoldnightDoubleDamageEffect extends ReplacementEffectImpl { public GiselaBladeOfGoldnightDoubleDamageEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Damage ) ; staticText = "If a source would deal damage to an opponent or a permanent an opponent controls, that source deals double that damage to that player or permanent instead . " + "If a source would deal damage to you or a permanent you control, prevent half that damage, rounded up"; } public GiselaBladeOfGoldnightDoubleDamageEffect ( final GiselaBladeOfGoldnightDoubleDamageEffect effect )  { super ( effect ) ; } @Override public GiselaBladeOfGoldnightDoubleDamageEffect copy (  )  { return new GiselaBladeOfGoldnightDoubleDamageEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  . equals ( EventType . DAMAGE_CREATURE )  || event . getType (  )  . equals ( EventType . DAMAGE_PLANESWALKER )  || event . getType (  )  . equals ( EventType . DAMAGE_PLAYER ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return true; } private void preventDamage ( GameEvent event, Ability source, UUID target, Game game )  { int amount =  ( int ) Math . ceil ( event . getAmount (  )  / 2 . 0 ) ; GameEvent preventEvent = new GameEvent ( GameEvent . EventType . PREVENT_DAMAGE, target, source . getSourceId (  ) , source . getControllerId (  ) , amount, false ) ; if  ( !game . replaceEvent ( preventEvent )  )  { event . setAmount ( event . getAmount (  )  - amount ) ; game . fireEvent ( GameEvent . getEvent ( GameEvent . EventType . PREVENTED_DAMAGE, target, source . getSourceId (  ) , source . getControllerId (  ) , amount )  ) ; } } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { switch  ( event . getType (  )  )  { case DAMAGE_PLAYER: if  ( event . getTargetId (  )  . equals ( source . getControllerId (  )  )  )  { preventDamage ( event, source, source . getControllerId (  ) , game ) ; } else if  ( game . getOpponents ( source . getControllerId (  )  )  . contains ( event . getTargetId (  )  )  )  { event . setAmount ( event . getAmount (  )  * 2 ) ; } break; case DAMAGE_CREATURE: case DAMAGE_PLANESWALKER: Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null )  { if  ( permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  )  { preventDamage ( event, source, permanent . getId (  ) , game ) ; } else if  ( game . getOpponents ( source . getControllerId (  )  )  . contains ( permanent . getControllerId (  )  )  )  { event . setAmount ( event . getAmount (  )  * 2 ) ; } } } return false; } } 
public class GloomSurgeon extends CardImpl { public GloomSurgeon ( UUID ownerId )  { super ( ownerId, 104, "Gloom Surgeon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GloomSurgeonEffect (  )  )  ) ; } public GloomSurgeon ( final GloomSurgeon card )  { super ( card ) ; } @Override public GloomSurgeon copy (  )  { return new GloomSurgeon ( this ) ; } } class GloomSurgeonEffect extends ReplacementEffectImpl { GloomSurgeonEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Exile ) ; staticText = "If combat damage would be dealt to {this}, prevent that damage and exile that many cards from the top of your library"; } GloomSurgeonEffect ( final GloomSurgeonEffect effect )  { super ( effect ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { GameEvent preventEvent = new GameEvent ( GameEvent . EventType . PREVENT_DAMAGE, source . getFirstTarget (  ) , source . getSourceId (  ) , source . getControllerId (  ) , event . getAmount (  ) , false ) ; if  ( !game . replaceEvent ( preventEvent )  )  { int preventedDamage = event . getAmount (  ) ; game . fireEvent ( GameEvent . getEvent ( GameEvent . EventType . PREVENTED_DAMAGE, source . getFirstTarget (  ) , source . getSourceId (  ) , source . getControllerId (  ) , preventedDamage )  ) ; Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . moveCards ( player . getLibrary (  )  . getTopCards ( game, preventedDamage ) , Zone . EXILED, source, game ) ; } return true; } return false; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DAMAGE_CREATURE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( event . getTargetId (  )  . equals ( source . getSourceId (  )  )  )  { DamageCreatureEvent damageEvent =  ( DamageCreatureEvent )  event; if  ( damageEvent . isCombatDamage (  )  )  { return true; } } return false; } @Override public GloomSurgeonEffect copy (  )  { return new GloomSurgeonEffect ( this ) ; } } 
public class Gloomwidow extends CardImpl { public Gloomwidow ( UUID ownerId )  { super ( ownerId, 180, "Gloomwidow", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spider" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; this . addAbility ( new CanBlockOnlyFlyingAbility (  )  ) ; } public Gloomwidow ( final Gloomwidow card )  { super ( card ) ; } @Override public Gloomwidow copy (  )  { return new Gloomwidow ( this ) ; } } 
public class GoldnightCommander extends CardImpl { public GoldnightCommander ( UUID ownerId )  { super ( ownerId, 22, "Goldnight Commander", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new EntersAnotherCreatureYourControlTriggeredAbility ( new BoostControlledEffect ( 1, 1, Duration . EndOfTurn )  )  ) ; } public GoldnightCommander ( final GoldnightCommander card )  { super ( card ) ; } @Override public GoldnightCommander copy (  )  { return new GoldnightCommander ( this ) ; } } 
public class GoldnightRedeemer extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "other creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public GoldnightRedeemer ( UUID ownerId )  { super ( ownerId, 23, "Goldnight Redeemer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( new PermanentsOnBattlefieldCount ( filter, 2 )  ) , false )  ) ; } public GoldnightRedeemer ( final GoldnightRedeemer card )  { super ( card ) ; } @Override public GoldnightRedeemer copy (  )  { return new GoldnightRedeemer ( this ) ; } } 
public class GraveExchange extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "creature card from your graveyard" ) ; public GraveExchange ( UUID ownerId )  { super ( ownerId, 105, "Grave Exchange", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new GraveExchangeEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public GraveExchange ( final GraveExchange card )  { super ( card ) ; } @Override public GraveExchange copy (  )  { return new GraveExchange ( this ) ; } } class GraveExchangeEffect extends OneShotEffect { public GraveExchangeEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "Target player sacrifices a creature"; } public GraveExchangeEffect ( final GraveExchangeEffect effect )  { super ( effect ) ; } @Override public GraveExchangeEffect copy (  )  { return new GraveExchangeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( player == null )  { return false; } Target target = new TargetControlledPermanent ( new FilterControlledCreaturePermanent (  )  ) ; if  ( target . canChoose ( player . getId (  ) , game )  && player . choose ( Outcome . Sacrifice, target, source . getSourceId (  ) , game )  )  { Permanent permanent = game . getPermanent ( target . getFirstTarget (  )  ) ; if  ( permanent != null )  { return permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } return false; } } 
public class Griselbrand extends CardImpl { public Griselbrand ( UUID ownerId )  { super ( ownerId, 106, "Griselbrand", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{B}{B}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( LifelinkAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 7 ) , new PayLifeCost ( 7 )  )  ) ; } public Griselbrand ( final Griselbrand card )  { super ( card ) ; } @Override public Griselbrand copy (  )  { return new Griselbrand ( this ) ; } } 
public class Grounded extends CardImpl { public Grounded ( UUID ownerId )  { super ( ownerId, 181, "Grounded", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . LoseAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new LoseAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; } public Grounded ( final Grounded card )  { super ( card ) ; } @Override public Grounded copy (  )  { return new Grounded ( this ) ; } } 
public class GryffVanguard extends CardImpl { public GryffVanguard ( UUID ownerId )  { super ( ownerId, 59, "Gryff Vanguard", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 )  )  ) ; } public GryffVanguard ( final GryffVanguard card )  { super ( card ) ; } @Override public GryffVanguard copy (  )  { return new GryffVanguard ( this ) ; } } 
public class HarvesterOfSouls extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another nontoken creature" ) ; static { filter . add ( Predicates . not ( new TokenPredicate (  )  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public HarvesterOfSouls ( UUID ownerId )  { super ( ownerId, 107, "Harvester of Souls", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( DeathtouchAbility . getInstance (  )  ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , true, filter )  ) ; } public HarvesterOfSouls ( final HarvesterOfSouls card )  { super ( card ) ; } @Override public HarvesterOfSouls copy (  )  { return new HarvesterOfSouls ( this ) ; } } 
public class HauntedGuardian extends CardImpl { public HauntedGuardian ( UUID ownerId )  { super ( ownerId, 216, "Haunted Guardian", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Construct" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; } public HauntedGuardian ( final HauntedGuardian card )  { super ( card ) ; } @Override public HauntedGuardian copy (  )  { return new HauntedGuardian ( this ) ; } } 
public class HavengulSkaab extends CardImpl { public HavengulSkaab ( UUID ownerId )  { super ( ownerId, 60, "Havengul Skaab", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new HavengulSkaabAbility (  )  ) ; } public HavengulSkaab ( final HavengulSkaab card )  { super ( card ) ; } @Override public HavengulSkaab copy (  )  { return new HavengulSkaab ( this ) ; } } class HavengulSkaabAbility extends TriggeredAbilityImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public HavengulSkaabAbility (  )  { super ( Zone . BATTLEFIELD, new DestroyTargetEffect (  )  ) ; this . addEffect ( new ReturnToHandTargetEffect (  )  ) ; } public HavengulSkaabAbility ( final HavengulSkaabAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  . equals ( this . getSourceId (  )  )  )  { TargetControlledCreaturePermanent target = new TargetControlledCreaturePermanent ( 1, 1, filter, false ) ; this . addTarget ( target ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} attacks, return another creature you control to its owner's hand . "; } @Override public HavengulSkaabAbility copy (  )  { return new HavengulSkaabAbility ( this ) ; } } 
public class HavengulVampire extends CardImpl { public HavengulVampire ( UUID ownerId )  { super ( ownerId, 139, "Havengul Vampire", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false, true )  ) ; } public HavengulVampire ( final HavengulVampire card )  { super ( card ) ; } @Override public HavengulVampire copy (  )  { return new HavengulVampire ( this ) ; } } 
public class HeirsOfStromkirk extends CardImpl { public HeirsOfStromkirk ( UUID ownerId )  { super ( ownerId, 140, "Heirs of Stromkirk", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( IntimidateAbility . getInstance (  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; } public HeirsOfStromkirk ( final HeirsOfStromkirk card )  { super ( card ) ; } @Override public HeirsOfStromkirk copy (  )  { return new HeirsOfStromkirk ( this ) ; } } 
public class HeraldOfWar extends CardImpl { public HeraldOfWar ( UUID ownerId )  { super ( ownerId, 24, "Herald of War", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new AttacksTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new HeraldOfWarCostReductionEffect (  )  )  ) ; } public HeraldOfWar ( final HeraldOfWar card )  { super ( card ) ; } @Override public HeraldOfWar copy (  )  { return new HeraldOfWar ( this ) ; } } class HeraldOfWarCostReductionEffect extends CostModificationEffectImpl { HeraldOfWarCostReductionEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "Angel spells and Human spells you cast cost {1} less to cast for each +1/+1 counter on Herald of War"; } HeraldOfWarCostReductionEffect ( HeraldOfWarCostReductionEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { SpellAbility spellAbility =  ( SpellAbility )  abilityToModify; Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { int amount = sourcePermanent . getCounters (  )  . getCount ( CounterType . P1P1 ) ; if  ( amount > 0 )  { CardUtil . adjustCost ( spellAbility, amount ) ; return true; } } return false; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { if  ( abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility )  { Card sourceCard = game . getCard ( abilityToModify . getSourceId (  )  ) ; if  ( sourceCard != null && abilityToModify . getControllerId (  )  . equals ( source . getControllerId (  )  )  &&  ( sourceCard . hasSubtype ( "Angel" )  || sourceCard . hasSubtype ( "Human" )  )  )  { return true; } } return false; } @Override public HeraldOfWarCostReductionEffect copy (  )  { return new HeraldOfWarCostReductionEffect ( this ) ; } } 
public class HolyJusticiar extends CardImpl { public HolyJusticiar ( UUID ownerId )  { super ( ownerId, 25, "Holy Justiciar", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new HolyJusticiarEffect (  ) , new ManaCostsImpl ( "{2}{W}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public HolyJusticiar ( final HolyJusticiar card )  { super ( card ) ; } @Override public HolyJusticiar copy (  )  { return new HolyJusticiar ( this ) ; } } class HolyJusticiarEffect extends OneShotEffect { public HolyJusticiarEffect (  )  { super ( Outcome . Detriment ) ; staticText = "Tap target creature .  If that creature is a Zombie, exile it"; } public HolyJusticiarEffect ( final HolyJusticiarEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent creature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( creature != null )  { if  ( creature . hasSubtype ( "Zombie" )  )  { creature . tap ( game ) ; creature . moveToExile ( source . getSourceId (  ) , creature . getName (  ) , source . getSourceId (  ) , game ) ; } else { creature . tap ( game ) ; } return true; } return false; } @Override public HolyJusticiarEffect copy (  )  { return new HolyJusticiarEffect ( this ) ; } } 
public class HomicidalSeclusion extends CardImpl { private static final String rule = "As long as you control exactly one creature, that creature gets +3/+1"; public HomicidalSeclusion ( UUID ownerId )  { super ( ownerId, 108, "Homicidal Seclusion", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; ContinuousEffect boostEffect = new BoostControlledEffect ( 3, 1, Duration . WhileOnBattlefield ) ; Effect effect = new ConditionalContinuousEffect ( boostEffect, new OneControlledCreatureCondition (  ) , rule ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, effect ) ; ContinuousEffect lifelinkEffect = new GainAbilityControlledEffect ( LifelinkAbility . getInstance (  ) , Duration . WhileOnBattlefield ) ; effect = new ConditionalContinuousEffect ( lifelinkEffect, new OneControlledCreatureCondition (  ) , "and has lifelink" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public HomicidalSeclusion ( final HomicidalSeclusion card )  { super ( card ) ; } @Override public HomicidalSeclusion copy (  )  { return new HomicidalSeclusion ( this ) ; } } 
public class HoundOfGriselbrand extends CardImpl { public HoundOfGriselbrand ( UUID ownerId )  { super ( ownerId, 141, "Hound of Griselbrand", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . subtype . add ( "Hound" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( DoubleStrikeAbility . getInstance (  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public HoundOfGriselbrand ( final HoundOfGriselbrand card )  { super ( card ) ; } @Override public HoundOfGriselbrand copy (  )  { return new HoundOfGriselbrand ( this ) ; } } 
public class Howlgeist extends CardImpl { public Howlgeist ( UUID ownerId )  { super ( ownerId, 182, "Howlgeist", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . subtype . add ( "Wolf" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeBlockedByCreaturesWithLessPowerEffect (  )  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public Howlgeist ( final Howlgeist card )  { super ( card ) ; } @Override public Howlgeist copy (  )  { return new Howlgeist ( this ) ; } } 
public class HumanFrailty extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Human creature" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public HumanFrailty ( UUID ownerId )  { super ( ownerId, 109, "Human Frailty", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; } public HumanFrailty ( final HumanFrailty card )  { super ( card ) ; } @Override public HumanFrailty copy (  )  { return new HumanFrailty ( this ) ; } } 
public class HuntedGhoul extends CardImpl { public HuntedGhoul ( UUID ownerId )  { super ( ownerId, 110, "Hunted Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleEvasionAbility ( new CantBlockCreaturesSourceEffect ( new FilterCreaturePermanent ( "Human", "Humans" )  )  )  ) ; } public HuntedGhoul ( final HuntedGhoul card )  { super ( card ) ; } @Override public HuntedGhoul copy (  )  { return new HuntedGhoul ( this ) ; } } 
public class InfiniteReflection extends CardImpl { public InfiniteReflection ( UUID ownerId )  { super ( ownerId, 61, "Infinite Reflection", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{5}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Copy )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new InfiniteReflectionTriggeredEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new InfiniteReflectionEntersBattlefieldEffect (  )  )  ) ; } public InfiniteReflection ( final InfiniteReflection card )  { super ( card ) ; } @Override public InfiniteReflection copy (  )  { return new InfiniteReflection ( this ) ; } } class InfiniteReflectionTriggeredEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterControlledCreaturePermanent (  ) ; public InfiniteReflectionTriggeredEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = " attached to a creature, each other nontoken creature you control becomes a copy of that creature"; } public InfiniteReflectionTriggeredEffect ( final InfiniteReflectionTriggeredEffect effect )  { super ( effect ) ; } @Override public InfiniteReflectionTriggeredEffect copy (  )  { return new InfiniteReflectionTriggeredEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && sourcePermanent . getAttachedTo (  )  != null )  { Permanent toCopyFromPermanent = game . getPermanent ( sourcePermanent . getAttachedTo (  )  ) ; if  ( toCopyFromPermanent != null )  { for  ( Permanent toCopyToPermanent : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { if  ( !toCopyToPermanent . equals ( toCopyFromPermanent )  && ! ( toCopyToPermanent instanceof PermanentToken )  )  { game . copyPermanent ( toCopyFromPermanent, toCopyToPermanent . getId (  ) , source, new EmptyApplyToPermanent (  )  ) ; } } return true; } } return false; } } class InfiniteReflectionEntersBattlefieldEffect extends ReplacementEffectImpl { public InfiniteReflectionEntersBattlefieldEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; } public InfiniteReflectionEntersBattlefieldEffect ( InfiniteReflectionEntersBattlefieldEffect effect )  { super ( effect ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { Permanent permanent =  (  ( EntersTheBattlefieldEvent )  event )  . getTarget (  ) ; return permanent != null && permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  && permanent . getCardType (  )  . contains ( CardType . CREATURE )  && ! ( permanent instanceof PermanentToken ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { MageObject toCopyToObject =  (  ( EntersTheBattlefieldEvent )  event )  . getTarget (  ) ; Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && toCopyToObject != null && sourcePermanent . getAttachedTo (  )  != null )  { Permanent toCopyFromPermanent = game . getPermanent ( sourcePermanent . getAttachedTo (  )  ) ; if  ( toCopyFromPermanent != null )  { game . copyPermanent ( toCopyFromPermanent, toCopyToObject . getId (  ) , source, new EmptyApplyToPermanent (  )  ) ; } } return false; } @Override public String getText ( Mode mode )  { return "Nontoken creatures you control enter the battlefield as a copy of enchanted creature"; } @Override public InfiniteReflectionEntersBattlefieldEffect copy (  )  { return new InfiniteReflectionEntersBattlefieldEffect ( this ) ; } } 
public class IntoTheVoid extends CardImpl { public IntoTheVoid ( UUID ownerId )  { super ( ownerId, 62, "Into the Void", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 2 )  ) ; } public IntoTheVoid ( final IntoTheVoid card )  { super ( card ) ; } @Override public IntoTheVoid copy (  )  { return new IntoTheVoid ( this ) ; } } 
public class JointAssault extends CardImpl { public JointAssault ( UUID ownerId )  { super ( ownerId, 183, "Joint Assault", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new JointAssaultBoostTargetEffect ( 2, 2, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public JointAssault ( final JointAssault card )  { super ( card ) ; } @Override public JointAssault copy (  )  { return new JointAssault ( this ) ; } } class JointAssaultBoostTargetEffect extends ContinuousEffectImpl { private int power; private int toughness; private UUID paired; public JointAssaultBoostTargetEffect ( int power, int toughness, Duration duration )  { super ( duration, Layer . PTChangingEffects_7, SubLayer . ModifyPT_7c, Outcome . BoostCreature ) ; this . power = power; this . toughness = toughness; staticText = "Target creature gets +2/+2 until end of turn .  If it's paired with a creature, that creature also gets +2/+2 until end of turn"; } public JointAssaultBoostTargetEffect ( final JointAssaultBoostTargetEffect effect )  { super ( effect ) ; this . power = effect . power; this . toughness = effect . toughness; } @Override public JointAssaultBoostTargetEffect copy (  )  { return new JointAssaultBoostTargetEffect ( this ) ; } @Override public void init ( Ability source, Game game )  { super . init ( source, game ) ; UUID permanentId = targetPointer . getFirst ( game, source ) ; Permanent target = game . getPermanent ( permanentId ) ; if  ( target != null )  { if  ( target . getPairedCard (  )  != null )  { this . paired = target . getPairedCard (  ) ; } } } @Override public boolean apply ( Game game, Ability source )  { int affectedTargets = 0; UUID permanentId = targetPointer . getFirst ( game, source ) ; Permanent target = game . getPermanent ( permanentId ) ; if  ( target != null )  { target . addPower ( power ) ; target . addToughness ( toughness ) ; affectedTargets++; } if  ( this . paired != null )  { Permanent paired = game . getPermanent ( this . paired ) ; if  ( paired != null )  { paired . addPower ( power ) ; paired . addToughness ( toughness ) ; affectedTargets++; } } return affectedTargets > 0; } } 
public class KessigMalcontents extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "Humans you control" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public KessigMalcontents ( UUID ownerId )  { super ( ownerId, 142, "Kessig Malcontents", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DamageTargetEffect ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public KessigMalcontents ( final KessigMalcontents card )  { super ( card ) ; } @Override public KessigMalcontents copy (  )  { return new KessigMalcontents ( this ) ; } } 
public class KillingWave extends CardImpl { public KillingWave ( UUID ownerId )  { super ( ownerId, 111, "Killing Wave", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new KillingWaveEffect (  )  ) ; } public KillingWave ( final KillingWave card )  { super ( card ) ; } @Override public KillingWave copy (  )  { return new KillingWave ( this ) ; } } class KillingWaveEffect extends OneShotEffect { public KillingWaveEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "For each creature, its controller sacrifices it unless he or she pays X life"; } public KillingWaveEffect ( final KillingWaveEffect effect )  { super ( effect ) ; } @Override public KillingWaveEffect copy (  )  { return new KillingWaveEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } int amount =  ( new ManacostVariableValue (  )  )  . calculate ( game, source, this ) ; if  ( amount > 0 )  { LinkedList<Permanent> sacrifices = new LinkedList<Permanent> (  ) ; HashMap<UUID, Integer> lifePaidAmounts = new HashMap<UUID, Integer> (  ) ; FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; List<Permanent> creatures = game . getBattlefield (  )  . getAllActivePermanents ( filter, playerId, game ) ; int lifePaid = 0; int playerLife = player . getLife (  ) ; for  ( Permanent creature : creatures )  { String message = "Pay " + amount + " life? If you don't, " + creature . getName (  )  + " will be sacrificed . "; if  ( playerLife - amount - lifePaid >= 0 && player != null && player . chooseUse ( Outcome . Neutral, message, source, game )  )  { game . informPlayers ( player . getLogName (  )  + " pays " + amount + " life .  He will not sacrifice " + creature . getName (  )  ) ; lifePaid += amount; } else { game . informPlayers ( player . getLogName (  )  + " will sacrifice " + creature . getName (  )  ) ; sacrifices . add ( creature ) ; } } lifePaidAmounts . put ( playerId, lifePaid ) ; } for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { int lifePaid = lifePaidAmounts . get ( playerId ) ; if  ( lifePaid > 0 )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { player . loseLife ( lifePaid, game ) ; } } } for  ( Permanent creature : sacrifices )  { creature . sacrifice ( source . getSourceId (  ) , game ) ; } } return true; } } 
public class KruinStriker extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "another creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public KruinStriker ( UUID ownerId )  { super ( ownerId, 143, "Kruin Striker", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new EntersBattlefieldAllTriggeredAbility ( new BoostSourceEffect ( 1, 0, Duration . EndOfTurn ) , filter, "Whenever another creature enters the battlefield under your control, Kruin Striker gets +1/+0 and gains trample until end of turn . " ) ; ability . addEffect ( new GainAbilitySourceEffect ( TrampleAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . addAbility ( ability ) ; } public KruinStriker ( final KruinStriker card )  { super ( card ) ; } @Override public KruinStriker copy (  )  { return new KruinStriker ( this ) ; } } 
public class LeapOfFaith extends CardImpl { public LeapOfFaith ( UUID ownerId )  { super ( ownerId, 26, "Leap of Faith", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new PreventDamageToTargetEffect ( Duration . EndOfTurn, Integer . MAX_VALUE )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public LeapOfFaith ( final LeapOfFaith card )  { super ( card ) ; } @Override public LeapOfFaith copy (  )  { return new LeapOfFaith ( this ) ; } } 
public class LightningMauler extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have haste"; public LightningMauler ( UUID ownerId )  { super ( ownerId, 144, "Lightning Mauler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( HasteAbility . getInstance (  ) , ruleText )  )  ) ; } public LightningMauler ( final LightningMauler card )  { super ( card ) ; } @Override public LightningMauler copy (  )  { return new LightningMauler ( this ) ; } } 
public class LightningProwess extends CardImpl { public LightningProwess ( UUID ownerId )  { super ( ownerId, 145, "Lightning Prowess", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( HasteAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability, AttachmentType . AURA )  )  ) ; } public LightningProwess ( final LightningProwess card )  { super ( card ) ; } @Override public LightningProwess copy (  )  { return new LightningProwess ( this ) ; } } 
public class LoneRevenant extends CardImpl { public LoneRevenant ( UUID ownerId )  { super ( ownerId, 64, "Lone Revenant", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( HexproofAbility . getInstance (  )  ) ; this . addAbility ( new LoneRevenantTriggeredAbility (  )  ) ; } public LoneRevenant ( final LoneRevenant card )  { super ( card ) ; } @Override public LoneRevenant copy (  )  { return new LoneRevenant ( this ) ; } } class LoneRevenantTriggeredAbility extends TriggeredAbilityImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; public LoneRevenantTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new LookLibraryAndPickControllerEffect ( new StaticValue ( 4 ) , false, new StaticValue ( 1 ) , new FilterCard (  ) , Zone . LIBRARY, false, false )  ) ; } public LoneRevenantTriggeredAbility ( final LoneRevenantTriggeredAbility ability )  { super ( ability ) ; } @Override public LoneRevenantTriggeredAbility copy (  )  { return new LoneRevenantTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  . equals ( this . sourceId )  &&  (  ( DamagedPlayerEvent )  event )  . isCombatDamage (  )  )  { Permanent permanent = game . getPermanent ( event . getSourceId (  )  ) ; int number = game . getBattlefield (  )  . countAll ( filter, controllerId, game ) ; if  ( permanent != null && number != 1 )  { return false; } return permanent != null || number == 0; } return false; } @Override public String getRule (  )  { return "Whenever {this} deals combat damage to a player, if you control no other creatures, " + super . getRule (  ) ; } } 
public class LunarMystic extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "an instant spell" ) ; static { filter . add ( new CardTypePredicate ( CardType . INSTANT )  ) ; } public LunarMystic ( UUID ownerId )  { super ( ownerId, 65, "Lunar Mystic", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new DoIfCostPaid ( new DrawCardSourceControllerEffect ( 1 ) , new GenericManaCost ( 1 )  ) , filter, false )  ) ; } public LunarMystic ( final LunarMystic card )  { super ( card ) ; } @Override public LunarMystic copy (  )  { return new LunarMystic ( this ) ; } } 
public class MaalfeldTwins extends CardImpl { public MaalfeldTwins ( UUID ownerId )  { super ( ownerId, 112, "Maalfeld Twins", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new ZombieToken (  ) , 2 )  )  ) ; } public MaalfeldTwins ( final MaalfeldTwins card )  { super ( card ) ; } @Override public MaalfeldTwins copy (  )  { return new MaalfeldTwins ( this ) ; } } 
public class MadProphet extends CardImpl { public MadProphet ( UUID ownerId )  { super ( ownerId, 146, "Mad Prophet", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addCost ( new DiscardTargetCost ( new TargetCardInHand (  )  )  ) ; this . addAbility ( ability ) ; } public MadProphet ( final MadProphet card )  { super ( card ) ; } @Override public MadProphet copy (  )  { return new MadProphet ( this ) ; } } 
public class MaliciousIntent extends CardImpl { public MaliciousIntent ( UUID ownerId )  { super ( ownerId, 147, "Malicious Intent", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability gainedAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBlockTargetEffect ( Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; gainedAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA )  )  ) ; } public MaliciousIntent ( final MaliciousIntent card )  { super ( card ) ; } @Override public MaliciousIntent copy (  )  { return new MaliciousIntent ( this ) ; } } 
public class Malignus extends CardImpl { public Malignus ( UUID ownerId )  { super ( ownerId, 148, "Malignus", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new SetPowerToughnessSourceEffect ( new HighestLifeTotalAmongOpponentsCount (  ) , Duration . EndOfGame )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MalignusEffect (  )  )  ) ; } public Malignus ( final Malignus card )  { super ( card ) ; } @Override public Malignus copy (  )  { return new Malignus ( this ) ; } } class HighestLifeTotalAmongOpponentsCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { if  ( sourceAbility != null )  { Player controller = game . getPlayer ( sourceAbility . getControllerId (  )  ) ; if  ( controller != null )  { int max = 0; for  ( UUID uuid : game . getOpponents ( controller . getId (  )  )  )  { Player opponent = game . getPlayer ( uuid ) ; if  ( opponent != null )  { if  ( opponent . getLife (  )  > max )  { max = opponent . getLife (  ) ; } } } return  ( int ) Math . ceil ( max / 2 . 0 ) ; } } return 0; } @Override public DynamicValue copy (  )  { return new CardsInControllerHandCount (  ) ; } @Override public String getMessage (  )  { return "half the highest life total among your opponents, rounded up"; } @Override public String toString (  )  { return "1"; } } class MalignusEffect extends ContinuousRuleModifyingEffectImpl { public MalignusEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Damage that would be dealt by {this} can't be prevented"; } public MalignusEffect ( final MalignusEffect effect )  { super ( effect ) ; } @Override public MalignusEffect copy (  )  { return new MalignusEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . PREVENT_DAMAGE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getSourceId (  )  . equals ( source . getSourceId (  )  ) ; } } 
public class MarrowBats extends CardImpl { public MarrowBats ( UUID ownerId )  { super ( ownerId, 113, "Marrow Bats", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Bat" ) ; this . subtype . add ( "Skeleton" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new PayLifeCost ( 4 )  )  ) ; } public MarrowBats ( final MarrowBats card )  { super ( card ) ; } @Override public MarrowBats copy (  )  { return new MarrowBats ( this ) ; } } 
public class MassAppeal extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "Human you control" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public MassAppeal ( UUID ownerId )  { super ( ownerId, 66, "Mass Appeal", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public MassAppeal ( final MassAppeal card )  { super ( card ) ; } @Override public MassAppeal copy (  )  { return new MassAppeal ( this ) ; } } 
public class MentalAgony extends CardImpl { public MentalAgony ( UUID ownerId )  { super ( ownerId, 114, "Mental Agony", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DiscardTargetEffect ( 2 )  ) ; this . getSpellAbility (  )  . addEffect ( new LoseLifeTargetEffect ( 2 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public MentalAgony ( final MentalAgony card )  { super ( card ) ; } @Override public MentalAgony copy (  )  { return new MentalAgony ( this ) ; } } 
public class MidnightDuelist extends CardImpl { private static final FilterPermanent filter = new FilterCreaturePermanent ( "Vampires" ) ; static { filter . add ( new SubtypePredicate ( "Vampire" )  ) ; } public MidnightDuelist ( UUID ownerId )  { super ( ownerId, 27, "Midnight Duelist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new ProtectionAbility ( filter )  ) ; } public MidnightDuelist ( final MidnightDuelist card )  { super ( card ) ; } @Override public MidnightDuelist copy (  )  { return new MidnightDuelist ( this ) ; } } 
public class MidvastProtector extends CardImpl { public MidvastProtector ( UUID ownerId )  { super ( ownerId, 28, "Midvast Protector", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new GainProtectionFromColorTargetEffect ( Duration . EndOfTurn ) , false ) ; ability . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MidvastProtector ( final MidvastProtector card )  { super ( card ) ; } @Override public MidvastProtector copy (  )  { return new MidvastProtector ( this ) ; } } 
public class MisthollowGriffin extends CardImpl { public MisthollowGriffin ( UUID ownerId )  { super ( ownerId, 68, "Misthollow Griffin", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Griffin" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . EXILED, new MisthollowGriffinPlayEffect (  )  )  ) ; } public MisthollowGriffin ( final MisthollowGriffin card )  { super ( card ) ; } @Override public MisthollowGriffin copy (  )  { return new MisthollowGriffin ( this ) ; } } class MisthollowGriffinPlayEffect extends AsThoughEffectImpl { public MisthollowGriffinPlayEffect (  )  { super ( AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE, Duration . EndOfGame, Outcome . Benefit ) ; staticText = "You may cast {this} from exile"; } public MisthollowGriffinPlayEffect ( final MisthollowGriffinPlayEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public MisthollowGriffinPlayEffect copy (  )  { return new MisthollowGriffinPlayEffect ( this ) ; } @Override public boolean applies ( UUID sourceId, Ability source, UUID affectedControllerId, Game game )  { if  ( sourceId . equals ( source . getSourceId (  )  )  )  { Card card = game . getCard ( source . getSourceId (  )  ) ; if  ( card != null && card . getOwnerId (  )  . equals ( source . getControllerId (  )  )  && game . getState (  )  . getZone ( source . getSourceId (  )  )  == Zone . EXILED )  { return true; } } return false; } } 
public class MistRaven extends CardImpl { public MistRaven ( UUID ownerId )  { super ( ownerId, 67, "Mist Raven", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new ReturnToHandTargetEffect (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MistRaven ( final MistRaven card )  { super ( card ) ; } @Override public MistRaven copy (  )  { return new MistRaven ( this ) ; } } 
public class MoonlightGeist extends CardImpl { public MoonlightGeist ( UUID ownerId )  { super ( ownerId, 29, "Moonlight Geist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventCombatDamageToSourceEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}{W}" )  ) ; ability . addEffect ( new PreventCombatDamageBySourceEffect ( Duration . EndOfTurn )  ) ; this . addAbility ( ability ) ; } public MoonlightGeist ( final MoonlightGeist card )  { super ( card ) ; } @Override public MoonlightGeist copy (  )  { return new MoonlightGeist ( this ) ; } } 
public class MoonsilverSpear extends CardImpl { public MoonsilverSpear ( UUID ownerId )  { super ( ownerId, 217, "Moonsilver Spear", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FirstStrikeAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new AttacksAttachedTriggeredAbility ( new CreateTokenEffect ( new AngelToken (  )  )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 4 )  )  ) ; } public MoonsilverSpear ( final MoonsilverSpear card )  { super ( card ) ; } @Override public MoonsilverSpear copy (  )  { return new MoonsilverSpear ( this ) ; } } 
public class NaturalEnd extends CardImpl { public NaturalEnd ( UUID ownerId )  { super ( ownerId, 185, "Natural End", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 3 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( new FilterArtifactOrEnchantmentPermanent (  )  )  ) ; } public NaturalEnd ( final NaturalEnd card )  { super ( card ) ; } @Override public NaturalEnd copy (  )  { return new NaturalEnd ( this ) ; } } 
public class NearheathPilgrim extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have lifelink"; public NearheathPilgrim ( UUID ownerId )  { super ( ownerId, 31, "Nearheath Pilgrim", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( LifelinkAbility . getInstance (  ) , ruleText )  )  ) ; } public NearheathPilgrim ( final NearheathPilgrim card )  { super ( card ) ; } @Override public NearheathPilgrim copy (  )  { return new NearheathPilgrim ( this ) ; } } 
public class Necrobite extends CardImpl { public Necrobite ( UUID ownerId )  { super ( ownerId, 115, "Necrobite", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( DeathtouchAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new RegenerateTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public Necrobite ( final Necrobite card )  { super ( card ) ; } @Override public Necrobite copy (  )  { return new Necrobite ( this ) ; } } 
public class NephaliaSmuggler extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another target creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public NephaliaSmuggler ( UUID ownerId )  { super ( ownerId, 69, "Nephalia Smuggler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ExileTargetForSourceEffect (  ) , new ManaCostsImpl ( "{3}{U}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addEffect ( new ReturnToBattlefieldUnderYourControlTargetEffect ( true )  ) ; ability . addTarget ( new TargetControlledCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; } public NephaliaSmuggler ( final NephaliaSmuggler card )  { super ( card ) ; } @Override public NephaliaSmuggler copy (  )  { return new NephaliaSmuggler ( this ) ; } } 
public class NettleSwine extends CardImpl { public NettleSwine ( UUID ownerId )  { super ( ownerId, 186, "Nettle Swine", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Boar" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; } public NettleSwine ( final NettleSwine card )  { super ( card ) ; } @Override public NettleSwine copy (  )  { return new NettleSwine ( this ) ; } } 
public class NightshadePeddler extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have deathtouch"; public NightshadePeddler ( UUID ownerId )  { super ( ownerId, 187, "Nightshade Peddler", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( DeathtouchAbility . getInstance (  ) , ruleText )  )  ) ; } public NightshadePeddler ( final NightshadePeddler card )  { super ( card ) ; } @Override public NightshadePeddler copy (  )  { return new NightshadePeddler ( this ) ; } } 
public class OtherworldAtlas extends CardImpl { public OtherworldAtlas ( UUID ownerId )  { super ( ownerId, 219, "Otherworld Atlas", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . CHARGE . createInstance (  )  ) , new TapSourceCost (  )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new OtherworldAtlasDrawEffect (  ) , new TapSourceCost (  )  )  ) ; } public OtherworldAtlas ( final OtherworldAtlas card )  { super ( card ) ; } @Override public OtherworldAtlas copy (  )  { return new OtherworldAtlas ( this ) ; } } class OtherworldAtlasDrawEffect extends OneShotEffect { public OtherworldAtlasDrawEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Each player draws a card for each charge counter on {this}"; } public OtherworldAtlasDrawEffect ( final OtherworldAtlasDrawEffect effect )  { super ( effect ) ; } @Override public OtherworldAtlasDrawEffect copy (  )  { return new OtherworldAtlasDrawEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player sourcePlayer = game . getPlayer ( source . getControllerId (  )  ) ; Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { int amount = permanent . getCounters (  )  . getCount ( CounterType . CHARGE ) ; if  ( amount > 0 )  { for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( sourcePlayer . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { player . drawCards ( amount, game ) ; } } } } return true; } } 
public class Outwit extends CardImpl { private static FilterSpell filter = new FilterSpell ( "spell that targets a player" ) ; public Outwit ( UUID ownerId )  { super ( ownerId, 70, "Outwit", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new CustomTargetSpell ( filter )  ) ; } public Outwit ( final Outwit card )  { super ( card ) ; } @Override public Outwit copy (  )  { return new Outwit ( this ) ; } private class CustomTargetSpell extends TargetObject { protected FilterSpell filter; public CustomTargetSpell (  )  { this ( 1, 1, new FilterSpell (  )  ) ; } public CustomTargetSpell ( FilterSpell filter )  { this ( 1, 1, filter ) ; } public CustomTargetSpell ( int numTargets, FilterSpell filter )  { this ( numTargets, numTargets, filter ) ; } public CustomTargetSpell ( int minNumTargets, int maxNumTargets, FilterSpell filter )  { this . minNumberOfTargets = minNumTargets; this . maxNumberOfTargets = maxNumTargets; this . zone = Zone . STACK; this . filter = filter; this . targetName = filter . getMessage (  ) ; } public CustomTargetSpell ( final CustomTargetSpell target )  { super ( target ) ; this . filter = target . filter . copy (  ) ; } @Override public boolean canChoose ( UUID sourceId, UUID sourceControllerId, Game game )  { return canChoose ( sourceControllerId, game ) ; } @Override public Set<UUID> possibleTargets ( UUID sourceId, UUID sourceControllerId, Game game )  { return possibleTargets ( sourceControllerId, game ) ; } @Override public boolean canTarget ( UUID id, Ability source, Game game )  { if  ( super . canTarget ( id, source, game )  )  { if  ( targetsPlayer ( id, game )  )  { return true; } } return false; } @Override public boolean canChoose ( UUID sourceControllerId, Game game )  { int count = 0; for  ( StackObject stackObject : game . getStack (  )  )  { if  ( stackObject instanceof Spell && filter . match (  ( Spell )  stackObject, game )  )  { if  ( targetsPlayer ( stackObject . getId (  ) , game )  )  { count++; if  ( count >= this . minNumberOfTargets )  { return true; } } } } return false; } @Override public Set<UUID> possibleTargets ( UUID sourceControllerId, Game game )  { Set<UUID> possibleTargets = new HashSet<UUID> (  ) ; for  ( StackObject stackObject : game . getStack (  )  )  { if  ( stackObject instanceof Spell && filter . match (  ( Spell )  stackObject, game )  )  { if  ( targetsPlayer ( stackObject . getId (  ) , game )  )  { possibleTargets . add ( stackObject . getId (  )  ) ; } } } return possibleTargets; } @Override public Filter getFilter (  )  { return filter; } private boolean targetsPlayer ( UUID id, Game game )  { StackObject spell = game . getStack (  )  . getStackObject ( id ) ; if  ( spell != null )  { Ability ability = spell . getStackAbility (  ) ; if  ( ability != null && !ability . getTargets (  )  . isEmpty (  )  )  { for  ( Target target : ability . getTargets (  )  )  { for  ( UUID playerId : target . getTargets (  )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { return true; } } } } } return false; } @Override public CustomTargetSpell copy (  )  { return new CustomTargetSpell ( this ) ; } } } 
public class PathbreakerWurm extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have trample"; public PathbreakerWurm ( UUID ownerId )  { super ( ownerId, 188, "Pathbreaker Wurm", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( TrampleAbility . getInstance (  ) , ruleText )  )  ) ; } public PathbreakerWurm ( final PathbreakerWurm card )  { super ( card ) ; } @Override public PathbreakerWurm copy (  )  { return new PathbreakerWurm ( this ) ; } } 
public class PeelFromReality extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature you don't control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . NOT_YOU )  ) ; } public PeelFromReality ( UUID ownerId )  { super ( ownerId, 71, "Peel from Reality", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new PeelFromRealityEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public PeelFromReality ( final PeelFromReality card )  { super ( card ) ; } @Override public PeelFromReality copy (  )  { return new PeelFromReality ( this ) ; } } class PeelFromRealityEffect extends OneShotEffect { public PeelFromRealityEffect (  )  { super ( Outcome . ReturnToHand ) ; this . staticText = "Return target creature you control and target creature you don't control to their owners' hands"; } public PeelFromRealityEffect ( final PeelFromRealityEffect effect )  { super ( effect ) ; } @Override public PeelFromRealityEffect copy (  )  { return new PeelFromRealityEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { boolean result = false; Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { result |= permanent . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; } permanent = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { result |= permanent . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; } return result; } } 
public class PillarOfFlame extends CardImpl { public PillarOfFlame ( UUID ownerId )  { super ( ownerId, 149, "Pillar of Flame", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 2 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DealtDamageToCreatureBySourceDies ( this, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addWatcher ( new DamagedByWatcher (  )  ) ; } public PillarOfFlame ( final PillarOfFlame card )  { super ( card ) ; } @Override public PillarOfFlame copy (  )  { return new PillarOfFlame ( this ) ; } } 
public class PollutedDead extends CardImpl { public PollutedDead ( UUID ownerId )  { super ( ownerId, 116, "Polluted Dead", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new DiesTriggeredAbility ( new DestroyTargetEffect (  )  ) ; Target target = new TargetLandPermanent (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public PollutedDead ( final PollutedDead card )  { super ( card ) ; } @Override public PollutedDead copy (  )  { return new PollutedDead ( this ) ; } } 
public class PredatorsGambit extends CardImpl { private static final String rule = "Enchanted creature has intimidate as long as its controller controls no other creatures"; public PredatorsGambit ( UUID ownerId )  { super ( ownerId, 117, "Predator's Gambit", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 1, Duration . WhileOnBattlefield )  )  ) ; ContinuousEffect effect = new GainAbilityAttachedEffect ( IntimidateAbility . getInstance (  ) , AttachmentType . AURA ) ; ConditionalContinuousEffect intimidate = new ConditionalContinuousEffect ( effect, new OneControlledCreatureCondition (  ) , rule ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, intimidate )  ) ; } public PredatorsGambit ( final PredatorsGambit card )  { super ( card ) ; } @Override public PredatorsGambit copy (  )  { return new PredatorsGambit ( this ) ; } } 
public class PrimalSurge extends CardImpl { public PrimalSurge ( UUID ownerId )  { super ( ownerId, 189, "Primal Surge", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{8}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new PrimalSurgeEffect (  )  ) ; } public PrimalSurge ( final PrimalSurge card )  { super ( card ) ; } @Override public PrimalSurge copy (  )  { return new PrimalSurge ( this ) ; } } class PrimalSurgeEffect extends OneShotEffect { public PrimalSurgeEffect (  )  { super ( Outcome . PutCardInPlay ) ; this . staticText = "Exile the top card of your library .  If it's a permanent card, you may put it onto the battlefield .  If you do, repeat this process"; } public PrimalSurgeEffect ( final PrimalSurgeEffect effect )  { super ( effect ) ; } @Override public PrimalSurgeEffect copy (  )  { return new PrimalSurgeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player == null )  { return false; } boolean repeat; do { repeat = false; if  ( player . getLibrary (  )  . size (  )  > 0 )  { Card card = player . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { card . moveToExile ( null, "", source . getSourceId (  ) , game ) ; List<CardType> cardType = card . getCardType (  ) ; if  (  ( cardType . contains ( CardType . ARTIFACT )  || cardType . contains ( CardType . CREATURE )  || cardType . contains ( CardType . ENCHANTMENT )  || cardType . contains ( CardType . LAND )  || cardType . contains ( CardType . PLANESWALKER )  )  && player . chooseUse ( Outcome . PutCardInPlay, "Put " + card . getName (  )  + " onto the battlefield?", source, game )  )  { card . moveToZone ( Zone . BATTLEFIELD, source . getSourceId (  ) , game, false ) ; Permanent permanent = game . getPermanent ( card . getId (  )  ) ; if  ( permanent == null )  { permanent =  ( Permanent )  game . getLastKnownInformation ( card . getId (  ) , Zone . BATTLEFIELD ) ; } if  ( permanent != null )  { repeat = true; } } } } } while  ( player . canRespond (  )  && repeat ) ; return true; } } 
public class RagingPoltergeist extends CardImpl { public RagingPoltergeist ( UUID ownerId )  { super ( ownerId, 150, "Raging Poltergeist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 1 ) ; } public RagingPoltergeist ( final RagingPoltergeist card )  { super ( card ) ; } @Override public RagingPoltergeist copy (  )  { return new RagingPoltergeist ( this ) ; } } 
public class RainOfThorns extends CardImpl { public RainOfThorns ( UUID ownerId )  { super ( ownerId, 190, "Rain of Thorns", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetArtifactPermanent (  )  ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 1 ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 3 ) ; Mode mode1 = new Mode (  ) ; mode1 . getEffects (  )  . add ( new DestroyTargetEffect (  )  ) ; mode1 . getTargets (  )  . add ( new TargetPermanent ( new FilterEnchantmentPermanent (  )  )  ) ; this . getSpellAbility (  )  . addMode ( mode1 ) ; Mode mode2 = new Mode (  ) ; mode2 . getEffects (  )  . add ( new DestroyTargetEffect (  )  ) ; mode2 . getTargets (  )  . add ( new TargetPermanent ( new FilterLandPermanent (  )  )  ) ; this . getSpellAbility (  )  . addMode ( mode2 ) ; } public RainOfThorns ( final RainOfThorns card )  { super ( card ) ; } @Override public RainOfThorns copy (  )  { return new RainOfThorns ( this ) ; } } 
public class ReforgeTheSoul extends CardImpl { public ReforgeTheSoul ( UUID ownerId )  { super ( ownerId, 151, "Reforge the Soul", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DiscardHandAllEffect (  )  ) ; Effect effect = new DrawCardAllEffect ( 7 ) ; effect . setText ( ", then draws seven cards" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{1}{R}" )  )  ) ; } public ReforgeTheSoul ( final ReforgeTheSoul card )  { super ( card ) ; } @Override public ReforgeTheSoul copy (  )  { return new ReforgeTheSoul ( this ) ; } } 
public class RenegadeDemon extends CardImpl { public RenegadeDemon ( UUID ownerId )  { super ( ownerId, 118, "Renegade Demon", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 3 ) ; } public RenegadeDemon ( final RenegadeDemon card )  { super ( card ) ; } @Override public RenegadeDemon copy (  )  { return new RenegadeDemon ( this ) ; } } 
public class RidersOfGavony extends CardImpl { public RidersOfGavony ( UUID ownerId )  { super ( ownerId, 33, "Riders of Gavony", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new ChooseCreatureTypeEffect ( Outcome . Protect )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new RidersOfGavonyGainAbilityControlledEffect (  )  )  ) ; } public RidersOfGavony ( final RidersOfGavony card )  { super ( card ) ; } @Override public RidersOfGavony copy (  )  { return new RidersOfGavony ( this ) ; } } class RidersOfGavonyGainAbilityControlledEffect extends ContinuousEffectImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Human creatures you control" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } protected FilterPermanent protectionFilter; public RidersOfGavonyGainAbilityControlledEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; staticText = "Human creatures you control have protection from creatures of the chosen type"; } public RidersOfGavonyGainAbilityControlledEffect ( final RidersOfGavonyGainAbilityControlledEffect effect )  { super ( effect ) ; protectionFilter = effect . protectionFilter; } @Override public RidersOfGavonyGainAbilityControlledEffect copy (  )  { return new RidersOfGavonyGainAbilityControlledEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { if  ( protectionFilter == null )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { String subtype =  ( String )  game . getState (  )  . getValue ( permanent . getId (  )  + "_type" ) ; if  ( subtype != null )  { protectionFilter = new FilterPermanent ( subtype + "s" ) ; protectionFilter . add ( new SubtypePredicate ( subtype )  ) ; } } } if  ( protectionFilter != null )  { for  ( Permanent perm : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { perm . addAbility ( new ProtectionAbility ( protectionFilter ) , source . getSourceId (  ) , game ) ; } return true; } return false; } } 
public class RighteousBlow extends CardImpl { public RighteousBlow ( UUID ownerId )  { super ( ownerId, 34, "Righteous Blow", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetAttackingOrBlockingCreature (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 2 )  ) ; } public RighteousBlow ( final RighteousBlow card )  { super ( card ) ; } @Override public RighteousBlow copy (  )  { return new RighteousBlow ( this ) ; } } 
public class RiotRingleader extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Human creatures" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public RiotRingleader ( UUID ownerId )  { super ( ownerId, 152, "Riot Ringleader", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostControlledEffect ( 1, 0, Duration . EndOfTurn, filter ) , false )  ) ; } public RiotRingleader ( final RiotRingleader card )  { super ( card ) ; } @Override public RiotRingleader copy (  )  { return new RiotRingleader ( this ) ; } } 
public class RiteOfRuin extends CardImpl { public RiteOfRuin ( UUID ownerId )  { super ( ownerId, 153, "Rite of Ruin", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{5}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new RiteOfRuinEffect (  )  ) ; } public RiteOfRuin ( final RiteOfRuin card )  { super ( card ) ; } @Override public RiteOfRuin copy (  )  { return new RiteOfRuin ( this ) ; } } class RiteOfRuinEffect extends OneShotEffect { public RiteOfRuinEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "Choose an order for artifacts, creatures, and lands .  Each player sacrifices one permanent of the first type, sacrifices two of the second type, then sacrifices three of the third type"; } public RiteOfRuinEffect ( final RiteOfRuinEffect effect )  { super ( effect ) ; } @Override public RiteOfRuinEffect copy (  )  { return new RiteOfRuinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } HashSet<String> choices = new HashSet<> (  ) ; choices . add ( "Artifacts" ) ; choices . add ( "Creatures" ) ; choices . add ( "Lands" ) ; LinkedList<CardType> order = new LinkedList<> (  ) ; ChoiceImpl choice = new ChoiceImpl ( true ) ; choice . setChoices ( choices ) ; while  ( controller . canRespond (  )  && controller . choose ( Outcome . Sacrifice, choice, game )  && choices . size (  )  > 1 )  { order . add ( getCardType ( choice . getChoice (  )  )  ) ; choices . remove ( choice . getChoice (  )  ) ; choice . clearChoice (  ) ; } order . add ( getCardType ( choices . iterator (  )  . next (  )  )  ) ; LinkedList<UUID> sacrifices = new LinkedList<> (  ) ; int count = 1; for  ( CardType cardType : order )  { FilterControlledPermanent filter = new FilterControlledPermanent ( cardType + " permanent you control" ) ; filter . add ( new CardTypePredicate ( cardType )  ) ; for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { int amount = Math . min ( count, game . getBattlefield (  )  . countAll ( filter, playerId, game )  ) ; TargetControlledPermanent target = new TargetControlledPermanent ( amount, amount, filter, false ) ; Player player = game . getPlayer ( playerId ) ; if  ( player != null && player . choose ( Outcome . Sacrifice, target, source . getSourceId (  ) , game )  )  { sacrifices . addAll ( target . getTargets (  )  ) ; } } for  ( UUID targetId : sacrifices )  { Permanent permanent = game . getPermanent ( targetId ) ; if  ( permanent != null )  { permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } sacrifices . clear (  ) ; count++; } return true; } private CardType getCardType ( String type )  { if  ( "Artifacts" . equals ( type )  )  { return CardType . ARTIFACT; } if  ( "Creatures" . equals ( type )  )  { return CardType . CREATURE; } if  ( "Lands" . equals ( type )  )  { return CardType . LAND; } return null; } } 
public class RotcrownGhoul extends CardImpl { public RotcrownGhoul ( UUID ownerId )  { super ( ownerId, 72, "Rotcrown Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new DiesTriggeredAbility ( new PutLibraryIntoGraveTargetEffect ( 5 )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public RotcrownGhoul ( final RotcrownGhoul card )  { super ( card ) ; } @Override public RotcrownGhoul copy (  )  { return new RotcrownGhoul ( this ) ; } } 
public class RushOfBlood extends CardImpl { public RushOfBlood ( UUID ownerId )  { super ( ownerId, 154, "Rush of Blood", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( new TargetPermanentPowerCount (  ) , new StaticValue ( 0 ) , Duration . EndOfTurn, true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public RushOfBlood ( final RushOfBlood card )  { super ( card ) ; } @Override public RushOfBlood copy (  )  { return new RushOfBlood ( this ) ; } } 
public class ScaldingDevil extends CardImpl { public ScaldingDevil ( UUID ownerId )  { super ( ownerId, 155, "Scalding Devil", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Devil" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new ManaCostsImpl ( "{2}{R}" )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public ScaldingDevil ( final ScaldingDevil card )  { super ( card ) ; } @Override public ScaldingDevil copy (  )  { return new ScaldingDevil ( this ) ; } } 
public class ScrapskinDrake extends CardImpl { public ScrapskinDrake ( UUID ownerId )  { super ( ownerId, 73, "Scrapskin Drake", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new CanBlockOnlyFlyingAbility (  )  ) ; } public ScrapskinDrake ( final ScrapskinDrake card )  { super ( card ) ; } @Override public ScrapskinDrake copy (  )  { return new ScrapskinDrake ( this ) ; } } 
public class ScrollOfAvacyn extends CardImpl { private static final FilterPermanent filter = new FilterPermanent (  ) ; static { filter . add ( new SubtypePredicate ( "Angel" )  ) ; } public ScrollOfAvacyn ( UUID ownerId )  { super ( ownerId, 220, "Scroll of Avacyn", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "AVR"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addEffect ( new ConditionalOneShotEffect ( new GainLifeEffect ( 5 ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "If you control an Angel, you gain 5 life" )  ) ; this . addAbility ( ability ) ; } public ScrollOfAvacyn ( final ScrollOfAvacyn card )  { super ( card ) ; } @Override public ScrollOfAvacyn copy (  )  { return new ScrollOfAvacyn ( this ) ; } } 
public class ScrollOfGriselbrand extends CardImpl { private static final FilterPermanent filter = new FilterPermanent (  ) ; static { filter . add ( new SubtypePredicate ( "Demon" )  ) ; } public ScrollOfGriselbrand ( UUID ownerId )  { super ( ownerId, 221, "Scroll of Griselbrand", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "AVR"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DiscardTargetEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addEffect ( new ConditionalOneShotEffect ( new LoseLifeTargetEffect ( 3 ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "If you control a Demon, that player loses 3 life" )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public ScrollOfGriselbrand ( final ScrollOfGriselbrand card )  { super ( card ) ; } @Override public ScrollOfGriselbrand copy (  )  { return new ScrollOfGriselbrand ( this ) ; } } 
public class SearchlightGeist extends CardImpl { public SearchlightGeist ( UUID ownerId )  { super ( ownerId, 119, "Searchlight Geist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( DeathtouchAbility . getInstance (  ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}{B}" )  )  ) ; } public SearchlightGeist ( final SearchlightGeist card )  { super ( card ) ; } @Override public SearchlightGeist copy (  )  { return new SearchlightGeist ( this ) ; } } 
public class SecondGuess extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "spell that's the second spell cast this turn" ) ; static { filter . add ( new SecondSpellPredicate (  )  ) ; } public SecondGuess ( UUID ownerId )  { super ( ownerId, 74, "Second Guess", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; } public SecondGuess ( final SecondGuess card )  { super ( card ) ; } @Override public SecondGuess copy (  )  { return new SecondGuess ( this ) ; } } class SecondSpellPredicate implements Predicate<Spell> { @Override public boolean apply ( Spell input, Game game )  { CastSpellLastTurnWatcher watcher =  ( CastSpellLastTurnWatcher )  game . getState (  )  . getWatchers (  )  . get ( "CastSpellLastTurnWatcher" ) ; if  ( watcher . getSpellOrder ( new MageObjectReference ( input . getId (  ) , game ) , game )  == 2 )  { return true; } return false; } @Override public String toString (  )  { return "SecondSpellThisTurn"; } } 
public class SeraphOfDawn extends CardImpl { public SeraphOfDawn ( UUID ownerId )  { super ( ownerId, 35, "Seraph of Dawn", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( LifelinkAbility . getInstance (  )  ) ; } public SeraphOfDawn ( final SeraphOfDawn card )  { super ( card ) ; } @Override public SeraphOfDawn copy (  )  { return new SeraphOfDawn ( this ) ; } } 
public class SeraphSanctuary extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "an Angel" ) ; static { filter . add ( new SubtypePredicate ( "Angel" )  ) ; } public SeraphSanctuary ( UUID ownerId )  { super ( ownerId, 228, "Seraph Sanctuary", Rarity . COMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( 1 )  )  ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( new GainLifeEffect ( 1 ) , filter )  ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; } public SeraphSanctuary ( final SeraphSanctuary card )  { super ( card ) ; } @Override public SeraphSanctuary copy (  )  { return new SeraphSanctuary ( this ) ; } } 
public class ShelteringWord extends CardImpl { public ShelteringWord ( UUID ownerId )  { super ( ownerId, 192, "Sheltering Word", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( HexproofAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new ShelteringWordEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; } public ShelteringWord ( final ShelteringWord card )  { super ( card ) ; } @Override public ShelteringWord copy (  )  { return new ShelteringWord ( this ) ; } } class ShelteringWordEffect extends OneShotEffect { public ShelteringWordEffect (  )  { super ( Outcome . GainLife ) ; this . staticText = "You gain life equal to that creature's toughness"; } public ShelteringWordEffect ( final ShelteringWordEffect effect )  { super ( effect ) ; } @Override public ShelteringWordEffect copy (  )  { return new ShelteringWordEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( player != null && permanent != null )  { int amount = permanent . getToughness (  )  . getValue (  ) ; if  ( amount > 0 )  { player . gainLife ( amount, game ) ; return true; } } return false; } } 
public class SigardaHostOfHerons extends CardImpl { public SigardaHostOfHerons ( UUID ownerId )  { super ( ownerId, 210, "Sigarda, Host of Herons", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{G}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HexproofAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SigardaHostOfHeronsEffect (  )  )  ) ; } public SigardaHostOfHerons ( final SigardaHostOfHerons card )  { super ( card ) ; } @Override public SigardaHostOfHerons copy (  )  { return new SigardaHostOfHerons ( this ) ; } } class SigardaHostOfHeronsEffect extends ContinuousRuleModifyingEffectImpl { public SigardaHostOfHeronsEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Spells and abilities your opponents control can't cause you to sacrifice permanents"; } public SigardaHostOfHeronsEffect ( final SigardaHostOfHeronsEffect effect )  { super ( effect ) ; } @Override public SigardaHostOfHeronsEffect copy (  )  { return new SigardaHostOfHeronsEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . SACRIFICE_PERMANENT; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( event . getPlayerId (  )  . equals ( source . getControllerId (  )  )  )  { MageObject object = game . getObject ( event . getSourceId (  )  ) ; if  ( object instanceof PermanentCard )  { if  ( game . getOpponents ( source . getControllerId (  )  )  . contains (  (  ( PermanentCard )  object )  . getControllerId (  )  )  )  { return true; } } if  ( object instanceof Spell )  { if  ( game . getOpponents ( source . getControllerId (  )  )  . contains (  (  ( Spell )  object )  . getControllerId (  )  )  )  { return true; } } } return false; } } 
public class SilverbladePaladin extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have double strike"; public SilverbladePaladin ( UUID ownerId )  { super ( ownerId, 36, "Silverblade Paladin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( DoubleStrikeAbility . getInstance (  ) , ruleText )  )  ) ; } public SilverbladePaladin ( final SilverbladePaladin card )  { super ( card ) ; } @Override public SilverbladePaladin copy (  )  { return new SilverbladePaladin ( this ) ; } } 
public class SlayersStronghold extends CardImpl { public SlayersStronghold ( UUID ownerId )  { super ( ownerId, 229, "Slayers' Stronghold", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 2, 0, Duration . EndOfTurn ) , new ManaCostsImpl ( "{R}{W}" )  ) ; ability . addEffect ( new GainAbilityTargetEffect ( VigilanceAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; ability . addEffect ( new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public SlayersStronghold ( final SlayersStronghold card )  { super ( card ) ; } @Override public SlayersStronghold copy (  )  { return new SlayersStronghold ( this ) ; } } 
public class SomberwaldVigilante extends CardImpl { public SomberwaldVigilante ( UUID ownerId )  { super ( ownerId, 156, "Somberwald Vigilante", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BecomesBlockedByCreatureTriggeredAbility ( new DamageTargetEffect ( 1, true, "that creature" ) , false )  ) ; } public SomberwaldVigilante ( final SomberwaldVigilante card )  { super ( card ) ; } @Override public SomberwaldVigilante copy (  )  { return new SomberwaldVigilante ( this ) ; } } 
public class SoulcageFiend extends CardImpl { public SoulcageFiend ( UUID ownerId )  { super ( ownerId, 120, "Soulcage Fiend", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DiesTriggeredAbility ( new LoseLifeAllPlayersEffect ( 3 )  )  ) ; } public SoulcageFiend ( final SoulcageFiend card )  { super ( card ) ; } @Override public SoulcageFiend copy (  )  { return new SoulcageFiend ( this ) ; } } 
public class SoulOfTheHarvest extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "another nontoken creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( Predicates . not ( new TokenPredicate (  )  )  ) ; } public SoulOfTheHarvest ( UUID ownerId )  { super ( ownerId, 195, "Soul of the Harvest", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , filter, true )  ) ; } public SoulOfTheHarvest ( final SoulOfTheHarvest card )  { super ( card ) ; } @Override public SoulOfTheHarvest copy (  )  { return new SoulOfTheHarvest ( this ) ; } } 
public class SpectralGateguards extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have vigilance"; public SpectralGateguards ( UUID ownerId )  { super ( ownerId, 37, "Spectral Gateguards", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( VigilanceAbility . getInstance (  ) , ruleText )  )  ) ; } public SpectralGateguards ( final SpectralGateguards card )  { super ( card ) ; } @Override public SpectralGateguards copy (  )  { return new SpectralGateguards ( this ) ; } } 
public class SpectralPrison extends CardImpl { public SpectralPrison ( UUID ownerId )  { super ( ownerId, 75, "Spectral Prison", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Detriment )  ) ; this . addAbility ( new EnchantAbility ( auraTarget . getTargetName (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DontUntapInControllersUntapStepEnchantedEffect (  )  )  ) ; this . addAbility ( new SpectralPrisonAbility (  )  ) ; } public SpectralPrison ( final SpectralPrison card )  { super ( card ) ; } @Override public SpectralPrison copy (  )  { return new SpectralPrison ( this ) ; } } class SpectralPrisonAbility extends TriggeredAbilityImpl { public SpectralPrisonAbility (  )  { super ( Zone . BATTLEFIELD, new DestroySourceEffect (  )  ) ; } public SpectralPrisonAbility ( final SpectralPrisonAbility ability )  { super ( ability ) ; } @Override public SpectralPrisonAbility copy (  )  { return new SpectralPrisonAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TARGETED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { MageObject eventSourceObject = game . getObject ( event . getSourceId (  )  ) ; if  ( eventSourceObject != null && eventSourceObject instanceof Spell )  { Permanent enchantment = game . getPermanent ( sourceId ) ; if  ( enchantment != null && enchantment . getAttachedTo (  )  != null )  { if  ( event . getTargetId (  )  . equals ( enchantment . getAttachedTo (  )  )  )  { return true; } } } return false; } @Override public String getRule (  )  { return "When enchanted creature becomes the target of a spell or ability, destroy {this} . "; } } 
public class SpiritAway extends CardImpl { public SpiritAway ( UUID ownerId )  { super ( ownerId, 76, "Spirit Away", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{5}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . GainControl )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ControlEnchantedEffect (  )  )  ) ; SimpleStaticAbility ability2 = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 2, Duration . WhileOnBattlefield )  ) ; ability2 . addEffect ( new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  ) ; this . addAbility ( ability2 ) ; } public SpiritAway ( final SpiritAway card )  { super ( card ) ; } @Override public SpiritAway copy (  )  { return new SpiritAway ( this ) ; } } 
public class SternMentor extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{T}: Target player puts the top two cards of his or her library into his or her graveyard . \""; public SternMentor ( UUID ownerId )  { super ( ownerId, 77, "Stern Mentor", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PutLibraryIntoGraveTargetEffect ( 2 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public SternMentor ( final SternMentor card )  { super ( card ) ; } @Override public SternMentor copy (  )  { return new SternMentor ( this ) ; } } 
public class StolenGoods extends CardImpl { public StolenGoods ( UUID ownerId )  { super ( ownerId, 78, "Stolen Goods", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new StolenGoodsEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public StolenGoods ( final StolenGoods card )  { super ( card ) ; } @Override public StolenGoods copy (  )  { return new StolenGoods ( this ) ; } } class StolenGoodsEffect extends OneShotEffect { public StolenGoodsEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "Target opponent exiles cards from the top of his or her library until he or she exiles a nonland card .  Until end of turn, you may cast that card without paying its mana cost"; } public StolenGoodsEffect ( final StolenGoodsEffect effect )  { super ( effect ) ; } @Override public StolenGoodsEffect copy (  )  { return new StolenGoodsEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player opponent = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; MageObject sourceObject = source . getSourceObject ( game ) ; if  ( opponent != null && opponent . getLibrary (  )  . size (  )  > 0 && sourceObject != null )  { Library library = opponent . getLibrary (  ) ; Card card; do { card = library . removeFromTop ( game ) ; if  ( card != null )  { opponent . moveCardsToExile ( card, source, game, true, source . getSourceId (  ) , sourceObject . getIdName (  )  ) ; } } while  ( library . size (  )  > 0 && card != null && card . getCardType (  )  . contains ( CardType . LAND )  ) ; if  ( card != null )  { ContinuousEffect effect = new StolenGoodsCastFromExileEffect (  ) ; effect . setTargetPointer ( new FixedTarget ( card . getId (  ) , card . getZoneChangeCounter ( game )  )  ) ; game . addEffect ( effect, source ) ; } return true; } return false; } } class StolenGoodsCastFromExileEffect extends AsThoughEffectImpl { public StolenGoodsCastFromExileEffect (  )  { super ( AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE, Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "You may cast card from exile"; } public StolenGoodsCastFromExileEffect ( final StolenGoodsCastFromExileEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public StolenGoodsCastFromExileEffect copy (  )  { return new StolenGoodsCastFromExileEffect ( this ) ; } @Override public boolean applies ( UUID sourceId, Ability source, UUID affectedControllerId, Game game )  { if  ( sourceId != null && sourceId . equals ( getTargetPointer (  )  . getFirst ( game, source )  )  && affectedControllerId . equals ( source . getControllerId (  )  )  )  { Card card = game . getCard ( sourceId ) ; if  ( card != null && game . getState (  )  . getZone ( sourceId )  == Zone . EXILED )  { Player player = game . getPlayer ( affectedControllerId ) ; player . setCastSourceIdWithAlternateMana ( sourceId, null, null ) ; return true; } } return false; } } 
public class Stonewright extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{R}: This creature gets +1/+0 until end of turn . \""; public Stonewright ( UUID ownerId )  { super ( ownerId, 157, "Stonewright", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 0, Duration . EndOfTurn ) , new ManaCostsImpl ( "{R}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public Stonewright ( final Stonewright card )  { super ( card ) ; } @Override public Stonewright copy (  )  { return new Stonewright ( this ) ; } } 
public class TamiyoTheMoonSage extends CardImpl { public TamiyoTheMoonSage ( UUID ownerId )  { super ( ownerId, 79, "Tamiyo, the Moon Sage", Rarity . MYTHIC, new CardType[]{CardType . PLANESWALKER}, "{3}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Tamiyo" ) ; this . addAbility ( new PlanswalkerEntersWithLoyalityCountersAbility ( 4 )  ) ; LoyaltyAbility ability = new LoyaltyAbility ( new TapTargetEffect (  ) , 1 ) ; ability . addEffect ( new DontUntapInControllersNextUntapStepTargetEffect (  )  ) ; Target target = new TargetPermanent (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; ability = new LoyaltyAbility ( new DrawCardSourceControllerEffect ( new TappedCreaturesControlledByTargetCount (  )  ) , -2 ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new LoyaltyAbility ( new GetEmblemEffect ( new TamiyoTheMoonSageEmblem (  )  ) , -8 )  ) ; } public TamiyoTheMoonSage ( final TamiyoTheMoonSage card )  { super ( card ) ; } @Override public TamiyoTheMoonSage copy (  )  { return new TamiyoTheMoonSage ( this ) ; } } class TappedCreaturesControlledByTargetCount implements DynamicValue { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; static { filter . add ( new TappedPredicate (  )  ) ; } @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { return game . getBattlefield (  )  . countAll ( filter, sourceAbility . getFirstTarget (  ) , game ) ; } @Override public DynamicValue copy (  )  { return new TappedCreaturesControlledByTargetCount (  ) ; } @Override public String toString (  )  { return "a"; } @Override public String getMessage (  )  { return "tapped creature target player controls"; } } /** * Emblem with "You have no maximum hand size" and "Whenever a card is put into * your graveyard from anywhere, you may return it to your hand . " */ class TamiyoTheMoonSageEmblem extends Emblem { public TamiyoTheMoonSageEmblem (  )  { this . setName ( "EMBLEM: Tamiyo, the Moon Sage" ) ; Ability ability = new SimpleStaticAbility ( Zone . COMMAND, new MaximumHandSizeControllerEffect ( Integer . MAX_VALUE, Duration . EndOfGame, HandSizeModification . SET )  ) ; this . getAbilities (  )  . add ( ability ) ; Effect effect = new ReturnToHandTargetEffect (  ) ; effect . setText ( "return it to your hand" ) ; this . getAbilities (  )  . add ( new PutCardIntoGraveFromAnywhereAllTriggeredAbility (  Zone . COMMAND, effect, true, new FilterCard ( "a card" ) , TargetController . YOU, SetTargetPointer . CARD )  ) ; } } 
public class TandemLookout extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"Whenever this creature deals damage to an opponent, draw a card . \""; public TandemLookout ( UUID ownerId )  { super ( ownerId, 80, "Tandem Lookout", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new DealsDamageToOpponentTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public TandemLookout ( final TandemLookout card )  { super ( card ) ; } @Override public TandemLookout copy (  )  { return new TandemLookout ( this ) ; } } 
public class TemporalMastery extends CardImpl { public TemporalMastery ( UUID ownerId )  { super ( ownerId, 81, "Temporal Mastery", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{5}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new AddExtraTurnControllerEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( ExileSpellEffect . getInstance (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{1}{U}" )  )  ) ; } public TemporalMastery ( final TemporalMastery card )  { super ( card ) ; } @Override public TemporalMastery copy (  )  { return new TemporalMastery ( this ) ; } } 
public class Terminus extends CardImpl { public Terminus ( UUID ownerId )  { super ( ownerId, 38, "Terminus", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{4}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new TerminusEffect (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{W}" )  )  ) ; } public Terminus ( final Terminus card )  { super ( card ) ; } @Override public Terminus copy (  )  { return new Terminus ( this ) ; } } class TerminusEffect extends OneShotEffect { public TerminusEffect (  )  { super ( Outcome . Removal ) ; this . staticText = "Put all creatures on the bottom of their owners' libraries"; } public TerminusEffect ( final TerminusEffect effect )  { super ( effect ) ; } @Override public TerminusEffect copy (  )  { return new TerminusEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { List<Permanent> permanents = game . getBattlefield (  )  . getActivePermanents (  new FilterCreaturePermanent (  ) , source . getControllerId (  ) , source . getSourceId (  ) , game ) ; for  ( Permanent permanent : permanents )  { permanent . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } return true; } } 
public class TerrifyingPresence extends CardImpl { public TerrifyingPresence ( UUID ownerId )  { super ( ownerId, 196, "Terrifying Presence", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new TerrifyingPresenceEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public TerrifyingPresence ( final TerrifyingPresence card )  { super ( card ) ; } @Override public TerrifyingPresence copy (  )  { return new TerrifyingPresence ( this ) ; } } class TerrifyingPresenceEffect extends PreventionEffectImpl { public TerrifyingPresenceEffect (  )  { super ( Duration . EndOfTurn, Integer . MAX_VALUE, true ) ; this . staticText = "Prevent all combat damage that would be dealt by creatures other than target creature this turn"; } public TerrifyingPresenceEffect ( final TerrifyingPresenceEffect effect )  { super ( effect ) ; } @Override public TerrifyingPresenceEffect copy (  )  { return new TerrifyingPresenceEffect ( this ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return super . applies ( event, source, game )  && !event . getSourceId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  ) ; } } 
public class ThatcherRevolt extends CardImpl { public ThatcherRevolt ( UUID ownerId )  { super ( ownerId, 158, "Thatcher Revolt", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ThatcherRevoltEffect (  )  ) ; } public ThatcherRevolt ( final ThatcherRevolt card )  { super ( card ) ; } @Override public ThatcherRevolt copy (  )  { return new ThatcherRevolt ( this ) ; } } class ThatcherRevoltEffect extends OneShotEffect { public ThatcherRevoltEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "Put three 1/1 red Human creature tokens with haste onto the battlefield .  Sacrifice those tokens at the beginning of the next end step"; } public ThatcherRevoltEffect ( final ThatcherRevoltEffect effect )  { super ( effect ) ; } @Override public ThatcherRevoltEffect copy (  )  { return new ThatcherRevoltEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { RedHumanToken token = new RedHumanToken (  ) ; token . putOntoBattlefield ( 3, game, source . getSourceId (  ) , source . getControllerId (  )  ) ; ArrayList<Permanent> toSacrifice = new ArrayList<> (  ) ; for  ( UUID tokenId : token . getLastAddedTokenIds (  )  )  { Permanent tokenPermanent = game . getPermanent ( tokenId ) ; if  ( tokenPermanent != null )  { toSacrifice . add ( tokenPermanent ) ; } } SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect (  ) ; sacrificeEffect . setTargetPointer ( new FixedTargets ( toSacrifice, game )  ) ; game . addDelayedTriggeredAbility ( new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( sacrificeEffect ) , source ) ; return true; } } class RedHumanToken extends Token { public RedHumanToken (  )  { super ( "Human", "1/1 red Human creature token with haste" ) ; this . cardType . add ( CardType . CREATURE ) ; this . subtype . add ( "Human" ) ; this . color = ObjectColor . RED; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; } } 
public class ThrabenValiant extends CardImpl { public ThrabenValiant ( UUID ownerId )  { super ( ownerId, 39, "Thraben Valiant", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; } public ThrabenValiant ( final ThrabenValiant card )  { super ( card ) ; } @Override public ThrabenValiant copy (  )  { return new ThrabenValiant ( this ) ; } } 
public class Thunderbolt extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public Thunderbolt ( UUID ownerId )  { super ( ownerId, 159, "Thunderbolt", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 3 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new DamageTargetEffect ( 4 )  ) ; mode . getTargets (  )  . add ( new TargetCreaturePermanent ( filter )  ) ; this . getSpellAbility (  )  . addMode ( mode ) ; } public Thunderbolt ( final Thunderbolt card )  { super ( card ) ; } @Override public Thunderbolt copy (  )  { return new Thunderbolt ( this ) ; } } 
public class ThunderousWrath extends CardImpl { public ThunderousWrath ( UUID ownerId )  { super ( ownerId, 160, "Thunderous Wrath", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 5 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{R}" )  )  ) ; } public ThunderousWrath ( final ThunderousWrath card )  { super ( card ) ; } @Override public ThunderousWrath copy (  )  { return new ThunderousWrath ( this ) ; } } 
public class TormentorsTrident extends CardImpl { public TormentorsTrident ( UUID ownerId )  { super ( ownerId, 222, "Tormentor's Trident", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 3, 0 )  ) ; Effect effect = new AttacksIfAbleAttachedEffect ( Duration . WhileOnBattlefield, AttachmentType . EQUIPMENT ) ; effect . setText ( "and attacks each turn if able" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 3 )  )  ) ; } public TormentorsTrident ( final TormentorsTrident card )  { super ( card ) ; } @Override public TormentorsTrident copy (  )  { return new TormentorsTrident ( this ) ; } } 
public class TreacherousPitDweller extends CardImpl { public TreacherousPitDweller ( UUID ownerId )  { super ( ownerId, 121, "Treacherous Pit-Dweller", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new UndyingAbility (  )  ) ; this . addAbility ( new TreacherousPitDwellerTriggeredAbility (  )  ) ; } public TreacherousPitDweller ( final TreacherousPitDweller card )  { super ( card ) ; } @Override public TreacherousPitDweller copy (  )  { return new TreacherousPitDweller ( this ) ; } } class TreacherousPitDwellerTriggeredAbility extends TriggeredAbilityImpl { private static final String ruleText = "When {this} enters the battlefield from a graveyard, "; public TreacherousPitDwellerTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new TreacherousPitDwellerEffect (  ) ,false ) ; addTarget ( new TargetOpponent (  )  ) ; } public TreacherousPitDwellerTriggeredAbility ( final TreacherousPitDwellerTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { return event . getTargetId (  )  . equals ( getSourceId (  )  )  &&  (  ( EntersTheBattlefieldEvent )  event )  . getFromZone (  )  . equals ( Zone . GRAVEYARD ) ; } @Override public TreacherousPitDwellerTriggeredAbility copy (  )  { return new TreacherousPitDwellerTriggeredAbility ( this ) ; } @Override public String getRule (  )  { return ruleText + super . getRule (  ) ; } } class TreacherousPitDwellerEffect extends ContinuousEffectImpl { public TreacherousPitDwellerEffect (  )  { super ( Duration . Custom, Layer . ControlChangingEffects_2, SubLayer . NA, Outcome . GainControl ) ; staticText = "target opponent gains control of {this}"; } public TreacherousPitDwellerEffect ( final TreacherousPitDwellerEffect effect )  { super ( effect ) ; } @Override public TreacherousPitDwellerEffect copy (  )  { return new TreacherousPitDwellerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent =  ( Permanent )  source . getSourceObjectIfItStillExists ( game ) ; Player targetOpponent = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( permanent != null && targetOpponent != null )  { return permanent . changeControllerId ( targetOpponent . getId (  ) , game ) ; } else { discard (  ) ; } return false; } } 
public class TriumphOfCruelty extends CardImpl { private static final String ruleText = "target opponent discards a card if you control the creature with the greatest power or tied for the greatest power"; public TriumphOfCruelty ( UUID ownerId )  { super ( ownerId, 122, "Triumph of Cruelty", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility ( new DiscardTargetEffect ( 1 ) , TargetController . YOU, false ) ; Target target = new TargetOpponent (  ) ; ability . addTarget ( target ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, ControlsCreatureGreatestPowerCondition . getInstance (  ) , ruleText )  ) ; } public TriumphOfCruelty ( final TriumphOfCruelty card )  { super ( card ) ; } @Override public TriumphOfCruelty copy (  )  { return new TriumphOfCruelty ( this ) ; } } 
public class TriumphOfFerocity extends CardImpl { private static final String ruleText = "draw a card if you control the creature with the greatest power or tied for the greatest power"; public TriumphOfFerocity ( UUID ownerId )  { super ( ownerId, 198, "Triumph of Ferocity", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , TargetController . YOU, false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, ControlsCreatureGreatestPowerCondition . getInstance (  ) , ruleText )  ) ; } public TriumphOfFerocity ( final TriumphOfFerocity card )  { super ( card ) ; } @Override public TriumphOfFerocity copy (  )  { return new TriumphOfFerocity ( this ) ; } } 
public class TrustedForcemage extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures gets +1/+1"; public TrustedForcemage ( UUID ownerId )  { super ( ownerId, 199, "Trusted Forcemage", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostPairedEffect ( 1, 1, ruleText )  )  ) ; } public TrustedForcemage ( final TrustedForcemage card )  { super ( card ) ; } @Override public TrustedForcemage copy (  )  { return new TrustedForcemage ( this ) ; } } 
public class TyrantOfDiscord extends CardImpl { public TyrantOfDiscord ( UUID ownerId )  { super ( ownerId, 162, "Tyrant of Discord", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{R}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new TyrantOfDiscordEffect (  )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public TyrantOfDiscord ( final TyrantOfDiscord card )  { super ( card ) ; } @Override public TyrantOfDiscord copy (  )  { return new TyrantOfDiscord ( this ) ; } } class TyrantOfDiscordEffect extends OneShotEffect { public TyrantOfDiscordEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "target opponent chooses a permanent he or she controls at random and sacrifices it .  If a nonland permanent is sacrificed this way, repeat this process"; } public TyrantOfDiscordEffect ( final TyrantOfDiscordEffect effect )  { super ( effect ) ; } @Override public TyrantOfDiscordEffect copy (  )  { return new TyrantOfDiscordEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID target = source . getFirstTarget (  ) ; Player opponent = game . getPlayer ( target ) ; if  ( opponent != null )  { boolean stop = false; while  ( !stop )  { int count = game . getBattlefield (  )  . countAll ( new FilterPermanent (  ) , opponent . getId (  ) , game ) ; if  ( count > 0 )  { int random =  ( int )  ( Math . random (  ) *count ) ; int index = 0; for  ( Permanent permanent : game . getBattlefield (  )  . getAllActivePermanents ( opponent . getId (  )  )  )  { if  ( index == random )  { if  ( permanent . sacrifice ( source . getSourceId (  ) , game )  )  { if  ( permanent . getCardType (  )  . contains ( CardType . LAND )  )  { stop = true; game . informPlayers ( "Land permanent has been sacrificed: " + permanent . getName (  )  + " .  Stopping process . " ) ; } else { game . informPlayers ( "Nonland permanent has been sacrificed: " + permanent . getName (  )  + " .  Repeating process . " ) ; } } else { game . informPlayers ( "Couldn't sacrifice a permanent .  Stopping the process . " ) ; stop = true; } break; } index++; } } else { game . informPlayers ( "There is no permanent to sacrifice" ) ; stop = true; } } } return true; } } 
public class UlvenwaldTracker extends CardImpl { public UlvenwaldTracker ( UUID ownerId )  { super ( ownerId, 200, "Ulvenwald Tracker", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new FightTargetsEffect (  ) , new ManaCostsImpl ( "{1}{G}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; ability . addTarget ( new TargetOtherCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public UlvenwaldTracker ( final UlvenwaldTracker card )  { super ( card ) ; } @Override public UlvenwaldTracker copy (  )  { return new UlvenwaldTracker ( this ) ; } } class TargetOtherCreaturePermanent extends TargetCreaturePermanent { public TargetOtherCreaturePermanent (  )  { super (  ) ; } public TargetOtherCreaturePermanent ( final TargetOtherCreaturePermanent target )  { super ( target ) ; } @Override public boolean canTarget ( UUID controllerId, UUID id, Ability source, Game game )  { if  ( source . getTargets (  )  . get ( 0 )  . getTargets (  )  . contains ( id )  )  { return false; } return super . canTarget ( controllerId, id, source, game ) ; } @Override public TargetOtherCreaturePermanent copy (  )  { return new TargetOtherCreaturePermanent ( this ) ; } } 
public class UncannySpeed extends CardImpl { public UncannySpeed ( UUID ownerId )  { super ( ownerId, 163, "Uncanny Speed", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( 3, 0, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public UncannySpeed ( final UncannySpeed card )  { super ( card ) ; } @Override public UncannySpeed copy (  )  { return new UncannySpeed ( this ) ; } } 
public class UndeadExecutioner extends CardImpl { public UndeadExecutioner ( UUID ownerId )  { super ( ownerId, 123, "Undead Executioner", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new DiesTriggeredAbility ( new BoostTargetEffect ( -2, -2, Duration . EndOfTurn ) , true ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public UndeadExecutioner ( final UndeadExecutioner card )  { super ( card ) ; } @Override public UndeadExecutioner copy (  )  { return new UndeadExecutioner ( this ) ; } } 
public class UnhallowedPact extends CardImpl { public UnhallowedPact ( UUID ownerId )  { super ( ownerId, 124, "Unhallowed Pact", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Detriment )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new DiesAttachedTriggeredAbility ( new ReturnToBattlefieldUnderYourControlAttachedEffect (  ) , "enchanted creature" )  ) ; } public UnhallowedPact ( final UnhallowedPact card )  { super ( card ) ; } @Override public UnhallowedPact copy (  )  { return new UnhallowedPact ( this ) ; } } 
public class VanguardsShield extends CardImpl { public VanguardsShield ( UUID ownerId )  { super ( ownerId, 223, "Vanguard's Shield", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 0, 3 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new VanguardsShieldEffect (  )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 3 )  )  ) ; } public VanguardsShield ( final VanguardsShield card )  { super ( card ) ; } @Override public VanguardsShield copy (  )  { return new VanguardsShield ( this ) ; } } class VanguardsShieldEffect extends ContinuousEffectImpl { public VanguardsShieldEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . AddAbility ) ; staticText = "Equipped creature can block an additional creature each combat"; } public VanguardsShieldEffect ( final VanguardsShieldEffect effect )  { super ( effect ) ; } @Override public VanguardsShieldEffect copy (  )  { return new VanguardsShieldEffect ( this ) ; } @Override public boolean apply ( Layer layer, SubLayer sublayer, Ability source, Game game )  { Permanent perm = game . getPermanent ( source . getSourceId (  )  ) ; if  ( perm != null && perm . getAttachedTo (  )  != null )  { Permanent equipped = game . getPermanent ( perm . getAttachedTo (  )  ) ; if  ( equipped != null )  { switch  ( layer )  { case RulesEffects: if  ( equipped . getMaxBlocks (  )  > 0 )  { equipped . setMaxBlocks ( equipped . getMaxBlocks (  )  + 1 ) ; } break; } return true; } } return false; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean hasLayer ( Layer layer )  { return layer == Layer . RulesEffects; } } 
public class Vanishment extends CardImpl { public Vanishment ( UUID ownerId )  { super ( ownerId, 82, "Vanishment", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetNonlandPermanent (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{U}" )  )  ) ; } public Vanishment ( final Vanishment card )  { super ( card ) ; } @Override public Vanishment copy (  )  { return new Vanishment ( this ) ; } } 
public class VesselOfEndlessRest extends CardImpl { public VesselOfEndlessRest ( UUID ownerId )  { super ( ownerId, 224, "Vessel of Endless Rest", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "AVR"; Ability ability = new EntersBattlefieldTriggeredAbility ( new PutOnLibraryTargetEffect ( false ) , false ) ; ability . addTarget ( new TargetCardInGraveyard (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new AnyColorManaAbility (  )  ) ; } public VesselOfEndlessRest ( final VesselOfEndlessRest card )  { super ( card ) ; } @Override public VesselOfEndlessRest copy (  )  { return new VesselOfEndlessRest ( this ) ; } } 
public class VexingDevil extends CardImpl { public VexingDevil ( UUID ownerId )  { super ( ownerId, 164, "Vexing Devil", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Devil" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new VexingDevilEffect (  ) , false )  ) ; } public VexingDevil ( final VexingDevil card )  { super ( card ) ; } @Override public VexingDevil copy (  )  { return new VexingDevil ( this ) ; } } class VexingDevilEffect extends OneShotEffect { public VexingDevilEffect (  )  { super ( Outcome . Neutral ) ; staticText = "any opponent may have it deal 4 damage to him or her .  If a player does, sacrifice {this}"; } VexingDevilEffect ( final VexingDevilEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( controller != null && permanent != null )  { for  ( UUID opponentUuid : game . getOpponents ( source . getControllerId (  )  )  )  { Player opponent = game . getPlayer ( opponentUuid ) ; if  ( opponent != null && opponent . chooseUse ( Outcome . LoseLife, "Make " + permanent . getLogName (  )  + " deal 4 damage to you?", source, game )  )  { game . informPlayers ( opponent . getLogName (  )  + " has chosen to receive 4 damage from " + permanent . getLogName (  )  ) ; opponent . damage ( 4, permanent . getId (  ) , game, false, true ) ; permanent . sacrifice ( source . getSourceId (  ) , game ) ; return true; } } game . informPlayers ( "4 damage wasn't dealt so " + permanent . getLogName (  )  + " won't be sacrificed . " ) ; return true; } return false; } @Override public VexingDevilEffect copy (  )  { return new VexingDevilEffect ( this ) ; } } 
public class VigilanteJustice extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Human" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public VigilanteJustice ( UUID ownerId )  { super ( ownerId, 165, "Vigilante Justice", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{R}" ) ; this . expansionSetCode = "AVR"; Ability ability = new CreatureEntersBattlefieldTriggeredAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , filter, false, false ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public VigilanteJustice ( final VigilanteJustice card )  { super ( card ) ; } @Override public VigilanteJustice copy (  )  { return new VigilanteJustice ( this ) ; } } 
public class VoiceOfTheProvinces extends CardImpl { public VoiceOfTheProvinces ( UUID ownerId )  { super ( ownerId, 40, "Voice of the Provinces", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new CreateTokenEffect ( new HumanToken (  )  )  )  ) ; } public VoiceOfTheProvinces ( final VoiceOfTheProvinces card )  { super ( card ) ; } @Override public VoiceOfTheProvinces copy (  )  { return new VoiceOfTheProvinces ( this ) ; } } 
public class Vorstclaw extends CardImpl { public Vorstclaw ( UUID ownerId )  { super ( ownerId, 201, "Vorstclaw", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; } public Vorstclaw ( final Vorstclaw card )  { super ( card ) ; } @Override public Vorstclaw copy (  )  { return new Vorstclaw ( this ) ; } } 
public class WanderingWolf extends CardImpl { public WanderingWolf ( UUID ownerId )  { super ( ownerId, 202, "Wandering Wolf", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Wolf" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeBlockedByCreaturesWithLessPowerEffect (  )  )  ) ; } public WanderingWolf ( final WanderingWolf card )  { super ( card ) ; } @Override public WanderingWolf copy (  )  { return new WanderingWolf ( this ) ; } } 
public class Wingcrafter extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have flying"; public Wingcrafter ( UUID ownerId )  { super ( ownerId, 83, "Wingcrafter", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( FlyingAbility . getInstance (  ) , ruleText )  )  ) ; } public Wingcrafter ( final Wingcrafter card )  { super ( card ) ; } @Override public Wingcrafter copy (  )  { return new Wingcrafter ( this ) ; } } 
public class WolfirAvenger extends CardImpl { public WolfirAvenger ( UUID ownerId )  { super ( ownerId, 205, "Wolfir Avenger", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Wolf" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{1}{G}" )  )  ) ; } public WolfirAvenger ( final WolfirAvenger card )  { super ( card ) ; } @Override public WolfirAvenger copy (  )  { return new WolfirAvenger ( this ) ; } } 
public class WolfirSilverheart extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures gets +4/+4"; public WolfirSilverheart ( UUID ownerId )  { super ( ownerId, 206, "Wolfir Silverheart", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Wolf" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostPairedEffect ( 4, 4, ruleText )  )  ) ; } public WolfirSilverheart ( final WolfirSilverheart card )  { super ( card ) ; } @Override public WolfirSilverheart copy (  )  { return new WolfirSilverheart ( this ) ; } } 
public class YewSpirit extends CardImpl { public YewSpirit ( UUID ownerId )  { super ( ownerId, 207, "Yew Spirit", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . subtype . add ( "Treefolk" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; SourcePermanentPowerCount x = new SourcePermanentPowerCount (  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( x, x, Duration . EndOfTurn, true ) , new ManaCostsImpl ( "{2}{G}{G}" )  )  ) ; } public YewSpirit ( final YewSpirit card )  { super ( card ) ; } @Override public YewSpirit copy (  )  { return new YewSpirit ( this ) ; } } 
public class ZealousConscripts extends CardImpl { public ZealousConscripts ( UUID ownerId )  { super ( ownerId, 166, "Zealous Conscripts", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new GainControlTargetEffect ( Duration . EndOfTurn )  ) ; ability . addTarget ( new TargetPermanent (  )  ) ; ability . addEffect ( new UntapTargetEffect (  )  ) ; ability . addEffect ( new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn, "It gains haste until end of turn" )  ) ; this . addAbility ( ability ) ; } public ZealousConscripts ( final ZealousConscripts card )  { super ( card ) ; } @Override public ZealousConscripts copy (  )  { return new ZealousConscripts ( this ) ; } } 
public class ZealousStrike extends CardImpl { public ZealousStrike ( UUID ownerId )  { super ( ownerId, 41, "Zealous Strike", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( 2, 2, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( FirstStrikeAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public ZealousStrike ( final ZealousStrike card )  { super ( card ) ; } @Override public ZealousStrike copy (  )  { return new ZealousStrike ( this ) ; } } 
public class AdverseConditions extends CardImpl { public AdverseConditions ( UUID ownerId )  { super ( ownerId, 54, "Adverse Conditions", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new TapTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 2 )  ) ; this . getSpellAbility (  )  . addEffect ( new DontUntapInControllersNextUntapStepTargetEffect (  )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  )  ) ; effect . setText ( "put a 1/1 colorless Eldrazi Scion creature token onto the battlefield .  It has \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public AdverseConditions ( final AdverseConditions card )  { super ( card ) ; } @Override public AdverseConditions copy (  )  { return new AdverseConditions ( this ) ; } } 
public class AkoumFirebird extends CardImpl { public AkoumFirebird ( UUID ownerId )  { super ( ownerId, 138, "Akoum Firebird", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Phoenix" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new AttacksEachTurnStaticAbility (  )  ) ; this . addAbility ( new AkoumFirebirdLandfallAbility ( new DoIfCostPaid (  new ReturnSourceFromGraveyardToBattlefieldEffect (  ) , new ManaCostsImpl ( "{4}{R}{R}" )  ) , false )  ) ; } public AkoumFirebird ( final AkoumFirebird card )  { super ( card ) ; } @Override public AkoumFirebird copy (  )  { return new AkoumFirebird ( this ) ; } } class AkoumFirebirdLandfallAbility extends TriggeredAbilityImpl { public AkoumFirebirdLandfallAbility ( Effect effect, boolean optional )  { this ( Zone . GRAVEYARD, effect, optional ) ; } public AkoumFirebirdLandfallAbility  ( Zone zone, Effect effect, Boolean optional  )  { super ( zone, effect, optional ) ; } public AkoumFirebirdLandfallAbility ( final AkoumFirebirdLandfallAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; return permanent != null && permanent . getCardType (  )  . contains ( CardType . LAND )  && permanent . getControllerId (  )  . equals ( this . controllerId ) ; } @Override public String getRule (  )  { return "<i>Landfall</i> &mdash; Whenever a land enters the battlefield under your control, " + super . getRule (  ) ; } @Override public AkoumFirebirdLandfallAbility copy (  )  { return new AkoumFirebirdLandfallAbility ( this ) ; } } 
public class AkoumHellkite extends CardImpl { public AkoumHellkite ( UUID ownerId )  { super ( ownerId, 139, "Akoum Hellkite", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{R}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new AkoumHellkiteTriggeredAbility (  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public AkoumHellkite ( final AkoumHellkite card )  { super ( card ) ; } @Override public AkoumHellkite copy (  )  { return new AkoumHellkite ( this ) ; } } class AkoumHellkiteTriggeredAbility extends TriggeredAbilityImpl { private static final String text = "<i>Landfall</i> - Whenever a land enters the battlefield under your control, {this} deals 1 damage to target creature or player .  " + "If that land is a Mountain, Akoum Hellkite deals 2 damage to that creature or player instead . "; public AkoumHellkiteTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new AkoumHellkiteDamageEffect (  )  ) ; } public AkoumHellkiteTriggeredAbility ( final AkoumHellkiteTriggeredAbility ability )  { super ( ability ) ; } @Override public AkoumHellkiteTriggeredAbility copy (  )  { return new AkoumHellkiteTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null && permanent . getCardType (  )  . contains ( CardType . LAND )  && permanent . getControllerId (  )  . equals ( getControllerId (  )  )  )  { Permanent sourcePermanent = game . getPermanent ( getSourceId (  )  ) ; if  ( sourcePermanent != null )  for  ( Effect effect : getEffects (  )  )  { if  ( effect instanceof AkoumHellkiteDamageEffect )  { effect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; } return true; } } return false; } @Override public String getRule (  )  { return text; } } class AkoumHellkiteDamageEffect extends OneShotEffect { public AkoumHellkiteDamageEffect (  )  { super ( Outcome . Damage ) ; } public AkoumHellkiteDamageEffect ( final AkoumHellkiteDamageEffect effect )  { super ( effect ) ; } @Override public AkoumHellkiteDamageEffect copy (  )  { return new AkoumHellkiteDamageEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent land = game . getPermanentOrLKIBattlefield ( getTargetPointer (  )  . getFirst ( game, source )  ) ; Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( land != null && player != null )  { if  ( land . hasSubtype ( "Mountain" )  )  { player . damage ( 2, source . getSourceId (  ) , game, false, true ) ; } else { player . damage ( 1, source . getSourceId (  ) , game, false, true ) ; } return true; } Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( land != null && permanent != null )  { if  ( land . hasSubtype ( "Mountain" )  )  { permanent . damage ( 2, source . getSourceId (  ) , game, false, true ) ; } else { permanent . damage ( 1, source . getSourceId (  ) , game, false, true ) ; } return true; } return false; } } 
public class AkoumStonewaker extends CardImpl { public AkoumStonewaker ( UUID ownerId )  { super ( ownerId, 140, "Akoum Stonewaker", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new LandfallAbility ( new DoIfCostPaid ( new AkoumStonewakerEffect (  ) , new ManaCostsImpl ( "{2}{R}" )  ) , false )  ) ; } public AkoumStonewaker ( final AkoumStonewaker card )  { super ( card ) ; } @Override public AkoumStonewaker copy (  )  { return new AkoumStonewaker ( this ) ; } } class AkoumStonewakerEffect extends OneShotEffect { public AkoumStonewakerEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "put a 3/1 red Elemental creature token with trample and haste onto the battlefield .  Exile that token at the beginning of the next end step"; } public AkoumStonewakerEffect ( final AkoumStonewakerEffect effect )  { super ( effect ) ; } @Override public AkoumStonewakerEffect copy (  )  { return new AkoumStonewakerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Token token = new AkoumStonewakerElementalToken (  ) ; if  ( token . putOntoBattlefield ( 1, game, source . getSourceId (  ) , source . getControllerId (  )  )  )  { for  ( UUID tokenId : token . getLastAddedTokenIds (  )  )  { Permanent tokenPermanent = game . getPermanent ( tokenId ) ; if  ( tokenPermanent != null )  { ExileTargetEffect exileEffect = new ExileTargetEffect (  ) ; exileEffect . setTargetPointer ( new FixedTarget ( tokenPermanent, game )  ) ; game . addDelayedTriggeredAbility ( new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( exileEffect ) , source ) ; } } return true; } return false; } } class AkoumStonewakerElementalToken extends Token { public AkoumStonewakerElementalToken (  )  { super ( "Elemental", "3/1 red Elemental creature token with trample and haste" ) ; cardType . add ( CardType . CREATURE ) ; color . setRed ( true ) ; subtype . add ( "Elemental" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 1 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . setOriginalExpansionSetCode ( "BFZ" ) ; this . setTokenType ( 1 ) ; } } 
public class AlignedHedronNetwork extends CardImpl { public AlignedHedronNetwork ( UUID ownerId )  { super ( ownerId, 222, "Aligned Hedron Network", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new AlignedHedronNetworkExileEffect (  ) , false )  ) ; } public AlignedHedronNetwork ( final AlignedHedronNetwork card )  { super ( card ) ; } @Override public AlignedHedronNetwork copy (  )  { return new AlignedHedronNetwork ( this ) ; } } class AlignedHedronNetworkExileEffect extends OneShotEffect { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creatures with power 5 or greater" ) ; static { filter . add ( new PowerPredicate ( Filter . ComparisonType . GreaterThan, 4 )  ) ; } public AlignedHedronNetworkExileEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "exile all creatures with power 5 or greater until {this} leaves the battlefield"; } public AlignedHedronNetworkExileEffect ( final AlignedHedronNetworkExileEffect effect )  { super ( effect ) ; } @Override public AlignedHedronNetworkExileEffect copy (  )  { return new AlignedHedronNetworkExileEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( controller != null && permanent != null )  { Set<Card> toExile = new LinkedHashSet<> (  ) ; for  ( Permanent creature : game . getBattlefield (  )  . getActivePermanents ( filter, controller . getId (  ) , source . getSourceId (  ) , game )  )  { toExile . add ( creature ) ; } if  ( !toExile . isEmpty (  )  )  { controller . moveCardsToExile ( toExile, source, game, true, CardUtil . getCardExileZoneId ( game, source ) , permanent . getIdName (  )  ) ; new CreateDelayedTriggeredAbilityEffect ( new OnLeaveReturnExiledToBattlefieldAbility (  )  )  . apply ( game, source ) ; } return true; } return false; } } 
public class AllyEncampment extends CardImpl { private static final FilterSpell FILTER = new FilterSpell ( "an Ally spell" ) ; static { FILTER . add ( new SubtypePredicate ( "Ally" )  ) ; } public AllyEncampment ( UUID ownerId )  { super ( ownerId, 228, "Ally Encampment", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; this . addAbility ( new ConditionalAnyColorManaAbility ( new TapSourceCost (  ) , 1, new ConditionalSpellManaBuilder ( FILTER ) , true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ReturnToHandTargetEffect (  ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetControlledCreaturePermanent ( new FilterControlledCreaturePermanent ( "Ally", "Ally you control" )  )  ) ; this . addAbility ( ability ) ; } public AllyEncampment ( final AllyEncampment card )  { super ( card ) ; } @Override public AllyEncampment copy (  )  { return new AllyEncampment ( this ) ; } } 
public class AngelicCaptain extends CardImpl { private static final FilterAttackingCreature filter = new FilterAttackingCreature ( "other attacking Ally" ) ; static { filter . add ( new SubtypePredicate ( "Ally" )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public AngelicCaptain ( UUID ownerId )  { super ( ownerId, 208, "Angelic Captain", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{R}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Angel" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount ( filter ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( value, value, Duration . EndOfTurn, true ) , false )  ) ; } public AngelicCaptain ( final AngelicCaptain card )  { super ( card ) ; } @Override public AngelicCaptain copy (  )  { return new AngelicCaptain ( this ) ; } } 
public class AngelicGift extends CardImpl { public AngelicGift ( UUID ownerId )  { super ( ownerId, 19, "Angelic Gift", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; } public AngelicGift ( final AngelicGift card )  { super ( card ) ; } @Override public AngelicGift copy (  )  { return new AngelicGift ( this ) ; } } 
public class AngelOfRenewal extends CardImpl { public AngelOfRenewal ( UUID ownerId )  { super ( ownerId, 18, "Angel of Renewal", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Angel" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect (  new PermanentsOnBattlefieldCount ( new FilterControlledCreaturePermanent (  )  )  )  )  ) ; } public AngelOfRenewal ( final AngelOfRenewal card )  { super ( card ) ; } @Override public AngelOfRenewal copy (  )  { return new AngelOfRenewal ( this ) ; } } 
public class BaneOfBalaGed extends CardImpl { public BaneOfBalaGed ( UUID ownerId )  { super ( ownerId, 1, "Bane of Bala Ged", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{7}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new AttacksTriggeredAbility ( new BaneOfBalaGedEffect (  ) , false, "", SetTargetPointer . PLAYER )  ) ; } public BaneOfBalaGed ( final BaneOfBalaGed card )  { super ( card ) ; } @Override public BaneOfBalaGed copy (  )  { return new BaneOfBalaGed ( this ) ; } } class BaneOfBalaGedEffect extends OneShotEffect { public BaneOfBalaGedEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "defending player exiles two permanents he or she controls"; } public BaneOfBalaGedEffect ( final BaneOfBalaGedEffect effect )  { super ( effect ) ; } @Override public BaneOfBalaGedEffect copy (  )  { return new BaneOfBalaGedEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player defendingPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( defendingPlayer != null )  { Target target = new TargetControlledPermanent ( 2 ) ; defendingPlayer . chooseTarget ( outcome, target, source, game ) ; defendingPlayer . moveCards ( new CardsImpl ( target . getTargets (  )  ) , null, Zone . EXILED, source, game ) ; return true; } return false; } } 
public class BarrageTyrant extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another colorless creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new ColorlessPredicate (  )  ) ; } public BarrageTyrant ( UUID ownerId )  { super ( ownerId, 127, "Barrage Tyrant", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new DamageTargetEffect ( new SacrificeCostCreaturesPower (  )  ) ; effect . setText ( "{this} deals damage equal to the sacrificed creature's power to target creature or player" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{2}{R}" )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( filter )  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public BarrageTyrant ( final BarrageTyrant card )  { super ( card ) ; } @Override public BarrageTyrant copy (  )  { return new BarrageTyrant ( this ) ; } } 
public class BeastcallerSavant extends CardImpl { public BeastcallerSavant ( UUID ownerId )  { super ( ownerId, 170, "Beastcaller Savant", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Shaman" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new ConditionalAnyColorManaAbility ( 1, new ConditionalSpellManaBuilder ( new FilterCreatureSpell ( "creature spells" )  )  )  ) ; } public BeastcallerSavant ( final BeastcallerSavant card )  { super ( card ) ; } @Override public BeastcallerSavant copy (  )  { return new BeastcallerSavant ( this ) ; } } 
public class BlightedCataract extends CardImpl { public BlightedCataract ( UUID ownerId )  { super ( ownerId, 229, "Blighted Cataract", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 2 ) , new ManaCostsImpl ( "{5}{U}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BlightedCataract ( final BlightedCataract card )  { super ( card ) ; } @Override public BlightedCataract copy (  )  { return new BlightedCataract ( this ) ; } } 
public class BlightedFen extends CardImpl { public BlightedFen ( UUID ownerId )  { super ( ownerId, 230, "Blighted Fen", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SacrificeEffect ( new FilterCreaturePermanent (  ) , 1, "Target opponent" ) , new ManaCostsImpl<> ( "{4}{B}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public BlightedFen ( final BlightedFen card )  { super ( card ) ; } @Override public BlightedFen copy (  )  { return new BlightedFen ( this ) ; } } 
public class BlightedGorge extends CardImpl { public BlightedGorge ( UUID ownerId )  { super ( ownerId, 231, "Blighted Gorge", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 2 ) , new ManaCostsImpl<> ( "{4}{R}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public BlightedGorge ( final BlightedGorge card )  { super ( card ) ; } @Override public BlightedGorge copy (  )  { return new BlightedGorge ( this ) ; } } 
public class BlightedSteppe extends CardImpl { public BlightedSteppe ( UUID ownerId )  { super ( ownerId, 232, "Blighted Steppe", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( new PermanentsOnBattlefieldCount ( new FilterControlledCreaturePermanent ( "creature you control" ) , 2 )  ) , new ManaCostsImpl<> ( "{3}{W}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BlightedSteppe ( final BlightedSteppe card )  { super ( card ) ; } @Override public BlightedSteppe copy (  )  { return new BlightedSteppe ( this ) ; } } 
public class BlightedWoodland extends CardImpl { public BlightedWoodland ( UUID ownerId )  { super ( ownerId, 233, "Blighted Woodland", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SearchLibraryPutInPlayEffect ( new TargetCardInLibrary ( 0, 2, new FilterBasicLandCard (  )  ) , true, true ) , new ManaCostsImpl<> ( "{3}{G}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BlightedWoodland ( final BlightedWoodland card )  { super ( card ) ; } @Override public BlightedWoodland copy (  )  { return new BlightedWoodland ( this ) ; } } 
public class BlightHerder extends CardImpl { public BlightHerder ( UUID ownerId )  { super ( ownerId, 2, "Blight Herder", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new CastSourceTriggeredAbility ( new BlightHerderEffect (  ) , true )  ) ; } public BlightHerder ( final BlightHerder card )  { super ( card ) ; } @Override public BlightHerder copy (  )  { return new BlightHerder ( this ) ; } } class BlightHerderEffect extends OneShotEffect { private final static FilterCard filter = new FilterCard ( "cards your opponents own from exile" ) ; static { filter . add ( new OwnerPredicate ( TargetController . OPPONENT )  ) ; } public BlightHerderEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "you may put two cards your opponents own from exile into their owners' graveyards .  If you do, put three 1/1 colorless Eldrazi Scion creature tokens onto the battlefield .  They have \"Sacrifice this creature: Add {C} to your mana pool . "; } public BlightHerderEffect ( final BlightHerderEffect effect )  { super ( effect ) ; } @Override public BlightHerderEffect copy (  )  { return new BlightHerderEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Target target = new TargetCardInExile ( 2, 2, filter, null ) ; if  ( target . canChoose ( source . getSourceId (  ) , source . getControllerId (  ) , game )  )  { if  ( controller . chooseTarget ( outcome, target, source, game )  )  { Cards cardsToGraveyard = new CardsImpl ( target . getTargets (  )  ) ; controller . moveCards ( cardsToGraveyard, null, Zone . GRAVEYARD, source, game ) ; return new CreateTokenEffect ( new EldraziScionToken (  ) , 3 )  . apply ( game, source ) ; } } return true; } return false; } } 
public class Blisterpod extends CardImpl { public Blisterpod ( UUID ownerId )  { super ( ownerId, 163, "Blisterpod", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  )  ) ; effect . setText ( "put a 1/1 colorless Eldrazi Scion creature token onto the battlefield .  It has \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; this . addAbility ( new DiesTriggeredAbility ( effect, false )  ) ; } public Blisterpod ( final Blisterpod card )  { super ( card ) ; } @Override public Blisterpod copy (  )  { return new Blisterpod ( this ) ; } } 
public class BloodbondVampire extends CardImpl { public BloodbondVampire ( UUID ownerId )  { super ( ownerId, 104, "Bloodbond Vampire", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Shaman" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new GainLifeControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; } public BloodbondVampire ( final BloodbondVampire card )  { super ( card ) ; } @Override public BloodbondVampire copy (  )  { return new BloodbondVampire ( this ) ; } } 
public class BoilingEarth extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public BoilingEarth ( UUID ownerId )  { super ( ownerId, 142, "Boiling Earth", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{R}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DamageAllEffect ( 1, filter )  ) ; this . addAbility ( new AwakenAbility ( this, 4, "{6}{R}" )  ) ; } public BoilingEarth ( final BoilingEarth card )  { super ( card ) ; } @Override public BoilingEarth copy (  )  { return new BoilingEarth ( this ) ; } } 
public class BreakerOfArmies extends CardImpl { public BreakerOfArmies ( UUID ownerId )  { super ( ownerId, 3, "Breaker of Armies", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{8}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 10 ) ; this . toughness = new MageInt ( 8 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MustBeBlockedByAllSourceEffect ( Duration . WhileOnBattlefield )  )  ) ; } public BreakerOfArmies ( final BreakerOfArmies card )  { super ( card ) ; } @Override public BreakerOfArmies copy (  )  { return new BreakerOfArmies ( this ) ; } } 
public class BrilliantSpectrum extends CardImpl { public BrilliantSpectrum ( UUID ownerId )  { super ( ownerId, 70, "Brilliant Spectrum", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . setAbilityWord ( AbilityWord . CONVERGE ) ; Effect effect = new DrawCardSourceControllerEffect ( ColorsOfManaSpentToCastCount . getInstance (  )  ) ; effect . setText ( "Draw X cards, where X is the number of colors of mana spent to cast {this}" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addEffect ( new DiscardControllerEffect ( 2 )  ) ; } public BrilliantSpectrum ( final BrilliantSpectrum card )  { super ( card ) ; } @Override public BrilliantSpectrum copy (  )  { return new BrilliantSpectrum ( this ) ; } } 
public class BringToLight extends CardImpl { public BringToLight ( UUID ownerId )  { super ( ownerId, 209, "Bring to Light", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{G}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new BringToLightEffect (  )  ) ; } public BringToLight ( final BringToLight card )  { super ( card ) ; } @Override public BringToLight copy (  )  { return new BringToLight ( this ) ; } } class BringToLightEffect extends OneShotEffect { public BringToLightEffect (  )  { super ( Outcome . PlayForFree ) ; this . staticText = "<i>Converge</i> &mdash; Search your library for a creature, instant, or sorcery card with converted mana " + "cost less than or equal to the number of colors of mana spent to cast {this}, exile that card, " + "then shuffle your library .  You may cast that card without paying its mana cost"; } public BringToLightEffect ( final BringToLightEffect effect )  { super ( effect ) ; } @Override public BringToLightEffect copy (  )  { return new BringToLightEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { int numberColors = ColorsOfManaSpentToCastCount . getInstance (  )  . calculate ( game, source, this ) ; FilterCard filter = new FilterCard (  ) ; filter . add ( Predicates . or ( new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . INSTANT ) , new CardTypePredicate ( CardType . SORCERY )  )  ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, numberColors + 1 )  ) ; TargetCardInLibrary target = new TargetCardInLibrary ( filter ) ; controller . searchLibrary ( target, game ) ; Card card = controller . getLibrary (  )  . getCard ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { controller . moveCards ( card, Zone . EXILED, source, game ) ; } controller . shuffleLibrary ( game ) ; if  ( card != null )  { if  ( controller . chooseUse ( outcome, "Cast " + card . getName (  )  + " without paying its mana cost?", source, game )  )  { if  ( card . getSpellAbility (  )  != null )  { controller . cast ( card . getSpellAbility (  ) , game, true ) ; } else { Logger . getLogger ( BringToLightEffect . class )  . error ( "Bring to Light: spellAbility == null " + card . getName (  )  ) ; } } } return true; } return false; } } 
public class BroodButcher extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "a creature" ) ; public BroodButcher ( UUID ownerId )  { super ( ownerId, 199, "Brood Butcher", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new CreateTokenEffect ( new EldraziScionToken (  )  ) , false )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -2, -2, Duration . EndOfTurn ) , new ManaCostsImpl ( "{B}{G}" )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( filter )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public BroodButcher ( final BroodButcher card )  { super ( card ) ; } @Override public BroodButcher copy (  )  { return new BroodButcher ( this ) ; } } 
public class BroodhunterWurm extends CardImpl { public BroodhunterWurm ( UUID ownerId )  { super ( ownerId, 171, "Broodhunter Wurm", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; } public BroodhunterWurm ( final BroodhunterWurm card )  { super ( card ) ; } @Override public BroodhunterWurm copy (  )  { return new BroodhunterWurm ( this ) ; } } 
public class BroodMonitor extends CardImpl { public BroodMonitor ( UUID ownerId )  { super ( ownerId, 164, "Brood Monitor", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  ) , 3 ) ; effect . setText ( "put three 1/1 colorless Eldrazi Scion creature tokens onto the battlefield .  They have \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( effect, false )  ) ; } public BroodMonitor ( final BroodMonitor card )  { super ( card ) ; } @Override public BroodMonitor copy (  )  { return new BroodMonitor ( this ) ; } } 
public class BrutalExpulsion extends CardImpl { private static final FilterSpellOrPermanent filter = new FilterSpellOrPermanent ( "spell or creature" ) ; static { filter . setPermanentFilter ( new FilterCreaturePermanent (  )  ) ; } public BrutalExpulsion ( UUID ownerId )  { super ( ownerId, 200, "Brutal Expulsion", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{2}{U}{R}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . getModes (  )  . setMinModes ( 1 ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 2 ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpellOrPermanent ( 1, 1, filter, false )  ) ; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new DamageTargetEffect ( 2 )  ) ; mode . getTargets (  )  . add ( new TargetCreatureOrPlaneswalker (  )  ) ; Effect effect = new DealtDamageToCreatureBySourceDies ( this, Duration . EndOfTurn ) ; effect . setText ( "If that permanent would be put into a graveyard this turn, exile it instead" ) ; mode . getEffects (  )  . add ( effect ) ; this . getSpellAbility (  )  . addMode ( mode ) ; this . getSpellAbility (  )  . addWatcher ( new DamagedByWatcher ( true )  ) ; } public BrutalExpulsion ( final BrutalExpulsion card )  { super ( card ) ; } @Override public BrutalExpulsion copy (  )  { return new BrutalExpulsion ( this ) ; } } 
public class CallTheScions extends CardImpl { public CallTheScions ( UUID ownerId )  { super ( ownerId, 165, "Call the Scions", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{G}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  ) , 2 ) ; effect . setText ( "put two 1/1 colorless Eldrazi Scion creature tokens onto the battlefield .  They have \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public CallTheScions ( final CallTheScions card )  { super ( card ) ; } @Override public CallTheScions copy (  )  { return new CallTheScions ( this ) ; } } 
public class CanopyVista extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public CanopyVista ( UUID ownerId )  { super ( ownerId, 234, "Canopy Vista", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Forest" ) ; this . subtype . add ( "Plains" ) ; Condition controls = new InvertCondition ( new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . MORE_THAN, 1 )  ) ; String abilityText = "tapped unless you control two or more basic lands"; this . addAbility ( new EntersBattlefieldAbility ( new ConditionalOneShotEffect ( new TapSourceEffect (  ) , controls, abilityText ) , abilityText )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; this . addAbility ( new WhiteManaAbility (  )  ) ; } public CanopyVista ( final CanopyVista card )  { super ( card ) ; } @Override public CanopyVista copy (  )  { return new CanopyVista ( this ) ; } } 
public class ChasmGuide extends CardImpl { public ChasmGuide ( UUID ownerId )  { super ( ownerId, 143, "Chasm Guide", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Scout" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility (  new GainAbilityControlledEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "creatures you control" )  ) , false )  ) ; } public ChasmGuide ( final ChasmGuide card )  { super ( card ) ; } @Override public ChasmGuide copy (  )  { return new ChasmGuide ( this ) ; } } 
public class CinderGlade extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public CinderGlade ( UUID ownerId )  { super ( ownerId, 235, "Cinder Glade", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Mountain" ) ; this . subtype . add ( "Forest" ) ; Condition controls = new InvertCondition ( new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . MORE_THAN, 1 )  ) ; String abilityText = "tapped unless you control two or more basic lands"; this . addAbility ( new EntersBattlefieldAbility ( new ConditionalOneShotEffect ( new TapSourceEffect (  ) , controls, abilityText ) , abilityText )  ) ; this . addAbility ( new RedManaAbility (  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; } public CinderGlade ( final CinderGlade card )  { super ( card ) ; } @Override public CinderGlade copy (  )  { return new CinderGlade ( this ) ; } } 
public class CliffsideLookout extends CardImpl { public CliffsideLookout ( UUID ownerId )  { super ( ownerId, 20, "Cliffside Lookout", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Scout" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1, 1, Duration . EndOfTurn ) , new ManaCostsImpl<> ( "{4}{W}" )  )  ) ; } public CliffsideLookout ( final CliffsideLookout card )  { super ( card ) ; } @Override public CliffsideLookout copy (  )  { return new CliffsideLookout ( this ) ; } } 
public class CloudManta extends CardImpl { public CloudManta ( UUID ownerId )  { super ( ownerId, 71, "Cloud Manta", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Fish" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } public CloudManta ( final CloudManta card )  { super ( card ) ; } @Override public CloudManta copy (  )  { return new CloudManta ( this ) ; } } 
public class ClutchOfCurrents extends CardImpl { public ClutchOfCurrents ( UUID ownerId )  { super ( ownerId, 72, "Clutch of Currents", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect ( true, false )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new AwakenAbility ( this, 3, "{4}{U}" )  ) ; } public ClutchOfCurrents ( final ClutchOfCurrents card )  { super ( card ) ; } @Override public ClutchOfCurrents copy (  )  { return new ClutchOfCurrents ( this ) ; } } 
public class CoastalDiscovery extends CardImpl { public CoastalDiscovery ( UUID ownerId )  { super ( ownerId, 73, "Coastal Discovery", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 2 )  ) ; this . addAbility ( new AwakenAbility ( this, 4, "{5}{U}" )  ) ; } public CoastalDiscovery ( final CoastalDiscovery card )  { super ( card ) ; } @Override public CoastalDiscovery copy (  )  { return new CoastalDiscovery ( this ) ; } } 
public class CompleteDisregard extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with power 3 or less" ) ; static { filter . add ( new PowerPredicate ( Filter . ComparisonType . LessThan, 4 )  ) ; } public CompleteDisregard ( UUID ownerId )  { super ( ownerId, 90, "Complete Disregard", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public CompleteDisregard ( final CompleteDisregard card )  { super ( card ) ; } @Override public CompleteDisregard copy (  )  { return new CompleteDisregard ( this ) ; } } 
public class ConduitOfRuin extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "a colorless creature card with converted mana cost 7 or greater" ) ; private static final FilterCreatureCard filterCost = new FilterCreatureCard ( "The first creature spell" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . GreaterThan, 6 )  ) ; filterCost . add ( new FirstCastCreatureSpellPredicate (  )  ) ; } public ConduitOfRuin ( UUID ownerId )  { super ( ownerId, 4, "Conduit of Ruin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; TargetCardInLibrary target = new TargetCardInLibrary ( filter ) ; this . addAbility ( new CastSourceTriggeredAbility ( new SearchLibraryPutOnLibraryEffect ( target, true, true ) , true )  ) ; Effect effect = new SpellsCostReductionControllerEffect ( filterCost, 2 ) ; effect . setText ( "The first creature spell you cast each turn costs {2} less to cast" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect ) , new ConduitOfRuinWatcher (  )  ) ; } public ConduitOfRuin ( final ConduitOfRuin card )  { super ( card ) ; } @Override public ConduitOfRuin copy (  )  { return new ConduitOfRuin ( this ) ; } } class ConduitOfRuinWatcher extends Watcher { Map<UUID, Integer> playerCreatureSpells; int spellCount = 0; public ConduitOfRuinWatcher (  )  { super ( "FirstCreatureSpellCastThisTurn", WatcherScope . GAME ) ; playerCreatureSpells = new HashMap<> (  ) ; } public ConduitOfRuinWatcher ( final ConduitOfRuinWatcher watcher )  { super ( watcher ) ; this . playerCreatureSpells = new HashMap<> (  ) ; playerCreatureSpells . putAll ( watcher . playerCreatureSpells ) ; } @Override public void watch ( GameEvent event, Game game )  { if  ( event . getType (  )  == GameEvent . EventType . SPELL_CAST )  { Spell spell =  ( Spell )  game . getObject ( event . getTargetId (  )  ) ; if  ( spell != null && spell . getCardType (  )  . contains ( CardType . CREATURE )  )  { if  ( playerCreatureSpells . containsKey ( event . getPlayerId (  )  )  )  { playerCreatureSpells . put ( event . getPlayerId (  ) , playerCreatureSpells . get ( event . getPlayerId (  )  )  + 1 ) ; } else { playerCreatureSpells . put ( event . getPlayerId (  ) , 1 ) ; } } } } public int creatureSpellsCastThisTurn ( UUID playerId )  { if  ( playerCreatureSpells . containsKey ( playerId )  )  { return playerCreatureSpells . get ( playerId ) ; } return 0; } @Override public ConduitOfRuinWatcher copy (  )  { return new ConduitOfRuinWatcher ( this ) ; } @Override public void reset (  )  { super . reset (  ) ; playerCreatureSpells . clear (  ) ; } } class FirstCastCreatureSpellPredicate implements ObjectPlayerPredicate<ObjectPlayer<Controllable>> { @Override public boolean apply ( ObjectPlayer<Controllable> input, Game game )  { if  ( input . getObject (  )  instanceof Spell &&  (  ( Spell )  input . getObject (  )  )  . getCardType (  )  . contains ( CardType . CREATURE )  )  { ConduitOfRuinWatcher watcher =  ( ConduitOfRuinWatcher )  game . getState (  )  . getWatchers (  )  . get ( "FirstCreatureSpellCastThisTurn" ) ; return watcher != null && watcher . creatureSpellsCastThisTurn ( input . getPlayerId (  )  )  == 0; } return false; } @Override public String toString (  )  { return "The first creature spell you cast each turn"; } } 
public class CoralhelmGuide extends CardImpl { public CoralhelmGuide ( UUID ownerId )  { super ( ownerId, 74, "Coralhelm Guide", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Scout" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBeBlockedTargetEffect ( Duration . EndOfTurn ) , new ManaCostsImpl<> ( "{4}{U}" )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public CoralhelmGuide ( final CoralhelmGuide card )  { super ( card ) ; } @Override public CoralhelmGuide copy (  )  { return new CoralhelmGuide ( this ) ; } } 
public class CourierGriffin extends CardImpl { public CourierGriffin ( UUID ownerId )  { super ( ownerId, 21, "Courier Griffin", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Griffin" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( 2 ) , false )  ) ; } public CourierGriffin ( final CourierGriffin card )  { super ( card ) ; } @Override public CourierGriffin copy (  )  { return new CourierGriffin ( this ) ; } } 
public class CrumbleToDust extends CardImpl { public CrumbleToDust ( UUID ownerId )  { super ( ownerId, 128, "Crumble to Dust", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{R}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addTarget ( new TargetNonBasicLandPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetAndSearchGraveyardHandLibraryEffect ( false, "its controller's", "any number of cards with the same name as that land" )  ) ; } public CrumbleToDust ( final CrumbleToDust card )  { super ( card ) ; } @Override public CrumbleToDust copy (  )  { return new CrumbleToDust ( this ) ; } } 
public class CrypticCruiser extends CardImpl { public CrypticCruiser ( UUID ownerId )  { super ( ownerId, 56, "Cryptic Cruiser", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new ManaCostsImpl<> ( "{2}{U}" )  ) ; ability . addCost ( new ExileOpponentsCardFromExileToGraveyardCost ( true )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public CrypticCruiser ( final CrypticCruiser card )  { super ( card ) ; } @Override public CrypticCruiser copy (  )  { return new CrypticCruiser ( this ) ; } } 
public class CullingDrone extends CardImpl { public CullingDrone ( UUID ownerId )  { super ( ownerId, 91, "Culling Drone", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new IngestAbility (  )  ) ; } public CullingDrone ( final CullingDrone card )  { super ( card ) ; } @Override public CullingDrone copy (  )  { return new CullingDrone ( this ) ; } } 
public class DampeningPulse extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public DampeningPulse ( UUID ownerId )  { super ( ownerId, 75, "Dampening Pulse", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostAllEffect ( -1, -0, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public DampeningPulse ( final DampeningPulse card )  { super ( card ) ; } @Override public DampeningPulse copy (  )  { return new DampeningPulse ( this ) ; } } 
public class DeathlessBehemoth extends CardImpl { private final static FilterControlledPermanent filter = new FilterControlledPermanent ( "two Eldrazi Scions" ) ; static { filter . add ( Predicates . and (  new SubtypePredicate ( "Eldrazi" ) , new SubtypePredicate ( "Scion" )  )  ) ; } public DeathlessBehemoth ( UUID ownerId )  { super ( ownerId, 5, "Deathless Behemoth", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{6}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( new ActivateAsSorceryActivatedAbility ( Zone . GRAVEYARD, new ReturnToHandSourceEffect (  ) , new SacrificeTargetCost ( new TargetControlledPermanent ( 2, 2, filter, true )  )  )  ) ; } public DeathlessBehemoth ( final DeathlessBehemoth card )  { super ( card ) ; } @Override public DeathlessBehemoth copy (  )  { return new DeathlessBehemoth ( this ) ; } } 
public class DefiantBloodlord extends CardImpl { public DefiantBloodlord ( UUID ownerId )  { super ( ownerId, 107, "Defiant Bloodlord", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{B}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; DefiantBloodlordTriggeredAbility ability = new DefiantBloodlordTriggeredAbility (  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public DefiantBloodlord ( final DefiantBloodlord card )  { super ( card ) ; } @Override public DefiantBloodlord copy (  )  { return new DefiantBloodlord ( this ) ; } } class DefiantBloodlordTriggeredAbility extends TriggeredAbilityImpl { public DefiantBloodlordTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, null ) ; } public DefiantBloodlordTriggeredAbility ( final DefiantBloodlordTriggeredAbility ability )  { super ( ability ) ; } @Override public DefiantBloodlordTriggeredAbility copy (  )  { return new DefiantBloodlordTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . GAINED_LIFE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getPlayerId (  )  . equals ( this . controllerId )  )  { this . getEffects (  )  . clear (  ) ; this . addEffect ( new LoseLifeTargetEffect ( event . getAmount (  )  )  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever you gain life, target opponent loses that much life . "; } } 
public class DemonsGrasp extends CardImpl { public DemonsGrasp ( UUID ownerId )  { super ( ownerId, 108, "Demon's Grasp", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{B}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( -5, -5, Duration . EndOfTurn )  ) ; } public DemonsGrasp ( final DemonsGrasp card )  { super ( card ) ; } @Override public DemonsGrasp copy (  )  { return new DemonsGrasp ( this ) ; } } 
public class DesolationTwin extends CardImpl { public DesolationTwin ( UUID ownerId )  { super ( ownerId, 6, "Desolation Twin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{10}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 10 ) ; this . toughness = new MageInt ( 10 ) ; this . addAbility ( new DesolationTwinOnCastAbility (  )  ) ; } public DesolationTwin ( final DesolationTwin card )  { super ( card ) ; } @Override public DesolationTwin copy (  )  { return new DesolationTwin ( this ) ; } } class DesolationTwinOnCastAbility extends TriggeredAbilityImpl { DesolationTwinOnCastAbility (  )  { super ( Zone . STACK, new CreateTokenEffect ( new EldraziToken (  )  )  ) ; } DesolationTwinOnCastAbility ( DesolationTwinOnCastAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SPELL_CAST; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Spell spell =  ( Spell )  game . getObject ( event . getTargetId (  )  ) ; return this . getSourceId (  )  . equals ( spell . getSourceId (  )  ) ; } @Override public DesolationTwinOnCastAbility copy (  )  { return new DesolationTwinOnCastAbility ( this ) ; } @Override public String getRule (  )  { return "When you cast {this}, " + super . getRule (  ) ; } } class EldraziToken extends Token { public EldraziToken (  )  { super ( "Eldrazi", "10/10 colorless Eldrazi creature token" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Eldrazi" ) ; power = new MageInt ( 10 ) ; toughness = new MageInt ( 10 ) ; } } 
public class DranasEmissary extends CardImpl { public DranasEmissary ( UUID ownerId )  { super ( ownerId, 210, "Drana's Emissary", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Cleric" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Effect effect = new GainLifeEffect ( 1 ) ; effect . setText ( "and you gain 1 life" ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( new LoseLifeOpponentsEffect ( 1 ) , TargetController . YOU, false ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public DranasEmissary ( final DranasEmissary card )  { super ( card ) ; } @Override public DranasEmissary copy (  )  { return new DranasEmissary ( this ) ; } } 
public class DrownerOfHope extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an Eldrazi Scion" ) ; static { filter . add ( Predicates . and (  new SubtypePredicate ( "Eldrazi" ) , new SubtypePredicate ( "Scion" )  )  ) ; } public DrownerOfHope ( UUID ownerId )  { super ( ownerId, 57, "Drowner of Hope", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  ) , 2 ) ; effect . setText ( "put two 1/1 colorless Eldrazi Scion creature tokens onto the battlefield .  They have \"Sacrifice this creature: Add {C} to your mana pool" ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( effect, false )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public DrownerOfHope ( final DrownerOfHope card )  { super ( card ) ; } @Override public DrownerOfHope copy (  )  { return new DrownerOfHope ( this ) ; } } 
public class DustStalker extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "if you control no other colorless creatures" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new ColorlessPredicate (  )  ) ; } public DustStalker ( UUID ownerId )  { super ( ownerId, 202, "Dust Stalker", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( Zone . BATTLEFIELD, new ReturnToHandSourceEffect (  ) , TargetController . ANY, new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . EQUAL_TO, 0 ) , false )  ) ; } public DustStalker ( final DustStalker card )  { super ( card ) ; } @Override public DustStalker copy (  )  { return new DustStalker ( this ) ; } } 
public class EarthenArms extends CardImpl { public EarthenArms ( UUID ownerId )  { super ( ownerId, 172, "Earthen Arms", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{G}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance ( 2 )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( new AwakenAbility ( this, 4, "{6}{G}" )  ) ; } public EarthenArms ( final EarthenArms card )  { super ( card ) ; } @Override public EarthenArms copy (  )  { return new EarthenArms ( this ) ; } } 
public class EldraziDevastator extends CardImpl { public EldraziDevastator ( UUID ownerId )  { super ( ownerId, 7, "Eldrazi Devastator", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{8}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 8 ) ; this . toughness = new MageInt ( 9 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; } public EldraziDevastator ( final EldraziDevastator card )  { super ( card ) ; } @Override public EldraziDevastator copy (  )  { return new EldraziDevastator ( this ) ; } } 
public class EldraziSkyspawner extends CardImpl { public EldraziSkyspawner ( UUID ownerId )  { super ( ownerId, 58, "Eldrazi Skyspawner", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  )  ) ; effect . setText ( "put a 1/1 colorless Eldrazi Scion creature token onto the battlefield .  It has \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( effect, false )  ) ; } public EldraziSkyspawner ( final EldraziSkyspawner card )  { super ( card ) ; } @Override public EldraziSkyspawner copy (  )  { return new EldraziSkyspawner ( this ) ; } } 
public class EmeriaShepherd extends CardImpl { private static final FilterPermanentCard filter = new FilterPermanentCard ( "nonland permanent card from your graveyard" ) ; static { filter . add ( Predicates . not ( new CardTypePredicate ( CardType . LAND )  )  ) ; } public EmeriaShepherd ( UUID ownerId )  { super ( ownerId, 22, "Emeria Shepherd", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{W}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new LandfallAbility ( Zone . BATTLEFIELD, new EmeriaShepherdReturnToHandTargetEffect (  ) , true ) ; ability . addTarget ( new TargetCardInYourGraveyard ( new FilterPermanentCard ( filter )  )  ) ; this . addAbility ( ability ) ; } public EmeriaShepherd ( final EmeriaShepherd card )  { super ( card ) ; } @Override public EmeriaShepherd copy (  )  { return new EmeriaShepherd ( this ) ; } } class EmeriaShepherdReturnToHandTargetEffect extends OneShotEffect { public EmeriaShepherdReturnToHandTargetEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "you may return target nonland permanent card from your graveyard to your hand .  If that land is a Plains, you may return that nonland permanent card to the battlefield instead"; } public EmeriaShepherdReturnToHandTargetEffect ( final EmeriaShepherdReturnToHandTargetEffect effect )  { super ( effect ) ; } @Override public EmeriaShepherdReturnToHandTargetEffect copy (  )  { return new EmeriaShepherdReturnToHandTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Permanent triggeringLand =  (  ( LandfallAbility )  source )  . getTriggeringPermanent (  ) ; if  ( controller == null || triggeringLand == null )  { return false; } Zone toZone = Zone . HAND; if  ( triggeringLand . getSubtype (  )  . contains ( "Plains" )  && controller . chooseUse ( Outcome . PutCardInPlay, "Put the card to battlefield instead?", source, game )  )  { toZone = Zone . BATTLEFIELD; } return controller . moveCards ( new CardsImpl ( targetPointer . getTargets ( game, source )  ) , toZone, source, game ) ; } } 
public class EncirclingFissure extends CardImpl { public EncirclingFissure ( UUID ownerId )  { super ( ownerId, 23, "Encircling Fissure", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{W}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new EncirclingFissurePreventEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( new AwakenAbility ( this, 2, "{4}{W}" )  ) ; } public EncirclingFissure ( final EncirclingFissure card )  { super ( card ) ; } @Override public EncirclingFissure copy (  )  { return new EncirclingFissure ( this ) ; } } class EncirclingFissurePreventEffect extends PreventionEffectImpl { public EncirclingFissurePreventEffect (  )  { super ( Duration . EndOfTurn, Integer . MAX_VALUE, true, false ) ; staticText = "Prevent all combat damage that would be dealt this turn by creatures target opponent controls"; } public EncirclingFissurePreventEffect ( final EncirclingFissurePreventEffect effect )  { super ( effect ) ; } @Override public EncirclingFissurePreventEffect copy (  )  { return new EncirclingFissurePreventEffect ( this ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( super . applies ( event, source, game )  && event instanceof DamageEvent && event . getAmount (  )  > 0 )  { DamageEvent damageEvent =  ( DamageEvent )  event; if  ( damageEvent . isCombatDamage (  )  )  { Permanent permanent = game . getPermanent ( damageEvent . getSourceId (  )  ) ; if  ( permanent != null && permanent . getCardType (  )  . contains ( CardType . CREATURE )  && permanent . getControllerId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  )  )  { return true; } } } return false; } } 
public class EndlessOne extends CardImpl { public EndlessOne ( UUID ownerId )  { super ( ownerId, 8, "Endless One", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{X}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( new EntersBattlefieldAbility ( new EntersBattlefieldWithXCountersEffect ( CounterType . P1P1 . createInstance (  )  )  )  ) ; } public EndlessOne ( final EndlessOne card )  { super ( card ) ; } @Override public EndlessOne copy (  )  { return new EndlessOne ( this ) ; } } 
public class ExertInfluence extends CardImpl { public ExertInfluence ( UUID ownerId )  { super ( ownerId, 77, "Exert Influence", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{4}{U}" ) ; this . expansionSetCode = "BFZ"; getSpellAbility (  )  . setAbilityWord ( AbilityWord . CONVERGE ) ; getSpellAbility (  )  . addEffect ( new ExertInfluenceEffect (  )  ) ; getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public ExertInfluence ( final ExertInfluence card )  { super ( card ) ; } @Override public ExertInfluence copy (  )  { return new ExertInfluence ( this ) ; } } class ExertInfluenceEffect extends OneShotEffect { public ExertInfluenceEffect (  )  { super ( Outcome . GainControl ) ; this . staticText = "Gain control of target creature if its power is less than or equal to the number of colors spent to cast {this}"; } public ExertInfluenceEffect ( final ExertInfluenceEffect effect )  { super ( effect ) ; } @Override public ExertInfluenceEffect copy (  )  { return new ExertInfluenceEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Permanent targetCreature = game . getPermanent ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && sourceObject != null )  { int colors = new ColorsOfManaSpentToCastCount (  )  . calculate ( game, source, this ) ; if  ( targetCreature . getPower (  )  . getValue (  )  <= colors )  { game . addEffect ( new GainControlTargetEffect ( Duration . Custom, true ) , source ) ; } return true; } return false; } } 
public class ExpeditionEnvoy extends CardImpl { public ExpeditionEnvoy ( UUID ownerId )  { super ( ownerId, 24, "Expedition Envoy", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Scout" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; } public ExpeditionEnvoy ( final ExpeditionEnvoy card )  { super ( card ) ; } @Override public ExpeditionEnvoy copy (  )  { return new ExpeditionEnvoy ( this ) ; } } 
public class EyelessWatcher extends CardImpl { public EyelessWatcher ( UUID ownerId )  { super ( ownerId, 166, "Eyeless Watcher", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  ) , 2 ) ; effect . setText ( "put two 1/1 colorless Eldrazi Scion creature tokens onto the battlefield .  They have \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( effect, false )  ) ; } public EyelessWatcher ( final EyelessWatcher card )  { super ( card ) ; } @Override public EyelessWatcher copy (  )  { return new EyelessWatcher ( this ) ; } } 
public class FathomFeeder extends CardImpl { public FathomFeeder ( UUID ownerId )  { super ( ownerId, 203, "Fathom Feeder", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{U}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( DeathtouchAbility . getInstance (  )  ) ; this . addAbility ( new IngestAbility (  )  ) ; Effect effect = new FathomFeederEffect (  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new ManaCostsImpl ( "{3}{U}{B}" )  ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public FathomFeeder ( final FathomFeeder card )  { super ( card ) ; } @Override public FathomFeeder copy (  )  { return new FathomFeeder ( this ) ; } } class FathomFeederEffect extends OneShotEffect { public FathomFeederEffect (  )  { super ( Outcome . Exile ) ; this . staticText = "Each opponent exiles the top card of his or her library"; } public FathomFeederEffect ( final FathomFeederEffect effect )  { super ( effect ) ; } @Override public FathomFeederEffect copy (  )  { return new FathomFeederEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( UUID opponentId: game . getOpponents ( source . getControllerId (  )  )  )  { Player player = game . getPlayer ( opponentId ) ; if  ( player != null )  { Card card = player . getLibrary (  )  . getFromTop ( game ) ; if  ( card != null )  { player . moveCards ( card, Zone . LIBRARY, Zone . EXILED, source, game ) ; } } } return true; } } 
public class FelidarCub extends CardImpl { public FelidarCub ( UUID ownerId )  { super ( ownerId, 25, "Felidar Cub", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Cat" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetEnchantmentPermanent (  )  ) ; this . addAbility ( ability ) ; } public FelidarCub ( final FelidarCub card )  { super ( card ) ; } @Override public FelidarCub copy (  )  { return new FelidarCub ( this ) ; } } 
public class FertileThicket extends CardImpl { public FertileThicket ( UUID ownerId )  { super ( ownerId, 237, "Fertile Thicket", Rarity . COMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new FertileThicketEffect (  ) , true )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; } public FertileThicket ( final FertileThicket card )  { super ( card ) ; } @Override public FertileThicket copy (  )  { return new FertileThicket ( this ) ; } } class FertileThicketEffect extends OneShotEffect { public FertileThicketEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "you may look at the top five cards of your library .  If you do, reveal up to one basic land card from among them, then put that card on top of your library and the rest on the bottom in any order"; } public FertileThicketEffect ( final FertileThicketEffect effect )  { super ( effect ) ; } @Override public FertileThicketEffect copy (  )  { return new FertileThicketEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller != null && sourceObject != null )  { Cards cards = new CardsImpl (  ) ; cards . addAll ( controller . getLibrary (  )  . getTopCards ( game, 5 )  ) ; controller . lookAtCards ( sourceObject . getIdName (  ) , cards, game ) ; TargetCard target = new TargetCard ( 0, 1, Zone . LIBRARY, new FilterBasicLandCard (  )  ) ; controller . chooseTarget ( outcome, cards, target, source, game ) ; Cards cardsRevealed = new CardsImpl ( target . getTargets (  )  ) ; if  ( !cardsRevealed . isEmpty (  )  )  { controller . revealCards ( sourceObject . getIdName (  ) , cardsRevealed, game ) ; cards . removeAll ( cardsRevealed ) ; controller . putCardsOnTopOfLibrary ( cardsRevealed, game, source, true ) ; } controller . putCardsOnBottomOfLibrary ( cards, game, source, true ) ; return true; } return false; } } 
public class FiremantleMage extends CardImpl { public FiremantleMage ( UUID ownerId )  { super ( ownerId, 145, "Firemantle Mage", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility (  new GainAbilityControlledEffect ( new MenaceAbility (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "creatures you control" )  ) , false )  ) ; } public FiremantleMage ( final FiremantleMage card )  { super ( card ) ; } @Override public FiremantleMage copy (  )  { return new FiremantleMage ( this ) ; } } 
public class FortifiedRampart extends CardImpl { public FortifiedRampart ( UUID ownerId )  { super ( ownerId, 27, "Fortified Rampart", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; } public FortifiedRampart ( final FortifiedRampart card )  { super ( card ) ; } @Override public FortifiedRampart copy (  )  { return new FortifiedRampart ( this ) ; } } 
public class FromBeyond extends CardImpl { private static final FilterCard filter = new FilterCard ( "Eldrazi card" ) ; static { filter . add ( new SubtypePredicate ( "Eldrazi" )  ) ; } public FromBeyond ( UUID ownerId )  { super ( ownerId, 167, "From Beyond", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{G}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new CreateTokenEffect ( new EldraziScionToken (  )  ) , TargetController . YOU, false )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( filter ) , true, true ) , new ManaCostsImpl ( "{1}{G}" )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public FromBeyond ( final FromBeyond card )  { super ( card ) ; } @Override public FromBeyond copy (  )  { return new FromBeyond ( this ) ; } } 
public class GideonAllyOfZendikar extends CardImpl { public GideonAllyOfZendikar ( UUID ownerId )  { super ( ownerId, 29, "Gideon, Ally of Zendikar", Rarity . MYTHIC, new CardType[]{CardType . PLANESWALKER}, "{2}{W}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Gideon" ) ; this . addAbility ( new PlanswalkerEntersWithLoyalityCountersAbility ( 4 )  ) ; LoyaltyAbility ability = new LoyaltyAbility ( new BecomesCreatureSourceEffect ( new GideonAllyOfZendikarToken (  ) , "planeswalker", Duration . EndOfTurn ) , 1 ) ; Effect effect = new PreventAllDamageToSourceEffect ( Duration . EndOfTurn ) ; effect . setText ( "Prevent all damage that would be dealt to him this turn" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; this . addAbility ( new LoyaltyAbility ( new CreateTokenEffect ( new KnightAllyToken (  )  ) , 0 )  ) ; this . addAbility ( new LoyaltyAbility ( new GetEmblemEffect ( new GideonAllyOfZendikarEmblem (  )  ) , -4 )  ) ; } public GideonAllyOfZendikar ( final GideonAllyOfZendikar card )  { super ( card ) ; } @Override public GideonAllyOfZendikar copy (  )  { return new GideonAllyOfZendikar ( this ) ; } } class GideonAllyOfZendikarEmblem extends Emblem { public GideonAllyOfZendikarEmblem (  )  { this . setName ( "EMBLEM: Gideon, Ally of Zendikar" ) ; BoostControlledEffect effect = new BoostControlledEffect ( 1, 1, Duration . EndOfGame ) ; Ability ability = new SimpleStaticAbility ( Zone . COMMAND, effect ) ; this . getAbilities (  )  . add ( ability ) ; this . setExpansionSetCodeForImage ( "BFZ" ) ; } } class GideonAllyOfZendikarToken extends Token { public GideonAllyOfZendikarToken (  )  { super ( "", "5/5 Human Soldier Ally creature with indestructible" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Human" ) ; subtype . add ( "Soldier" ) ; subtype . add ( "Ally" ) ; power = new MageInt ( 5 ) ; toughness = new MageInt ( 5 ) ; addAbility ( IndestructibleAbility . getInstance (  )  ) ; } } class KnightAllyToken extends Token { public KnightAllyToken (  )  { super ( "Knight Ally", "2/2 white Knight Ally creature token" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Knight" ) ; subtype . add ( "Ally" ) ; color . setWhite ( true ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 2 ) ; } } 
public class GideonsReproach extends CardImpl { public GideonsReproach ( UUID ownerId )  { super ( ownerId, 30, "Gideon's Reproach", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 4 )  ) ; getSpellAbility (  )  . addTarget ( new TargetAttackingOrBlockingCreature (  )  ) ; } public GideonsReproach ( final GideonsReproach card )  { super ( card ) ; } @Override public GideonsReproach copy (  )  { return new GideonsReproach ( this ) ; } } 
public class GraveBirthing extends CardImpl { public GraveBirthing ( UUID ownerId )  { super ( ownerId, 93, "Grave Birthing", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new GraveBirthingEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  )  ) ; effect . setText ( "You put a 1/1 colorless Eldrazi Scion creature token onto the battlefield .  It has \"Sacrifice this creature: Add {C} to your mana pool . \"<br>" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ;  
public class GreenwardenOfMurasa extends CardImpl { public GreenwardenOfMurasa ( UUID ownerId )  { super ( ownerId, 174, "Greenwarden of Murasa", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new ReturnFromGraveyardToHandTargetEffect (  ) , true ) ; ability . addTarget ( new TargetCardInYourGraveyard (  )  ) ; this . addAbility ( ability ) ; ability = new DiesTriggeredAbility ( new GreenwardenOfMurasaEffect (  ) , false ) ; ability . addTarget ( new TargetCardInYourGraveyard (  )  ) ; this . addAbility ( ability ) ; } public GreenwardenOfMurasa ( final GreenwardenOfMurasa card )  { super ( card ) ; } @Override public GreenwardenOfMurasa copy (  )  { return new GreenwardenOfMurasa ( this ) ; } } class GreenwardenOfMurasaEffect extends OneShotEffect { public GreenwardenOfMurasaEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "you may exile it .  If you do, return target card from your graveyard to your hand"; } public GreenwardenOfMurasaEffect ( final GreenwardenOfMurasaEffect effect )  { super ( effect ) ; } @Override public GreenwardenOfMurasaEffect copy (  )  { return new GreenwardenOfMurasaEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; Card targetCard = game . getCard ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && sourceObject != null && targetCard != null )  { if  ( controller . chooseUse ( outcome, "Exile " + sourceObject . getLogName (  )  + " to return card from your graveyard to your hand?", source, game )  )  { Effect effect = new ReturnToHandTargetEffect (  ) ; effect . setTargetPointer ( new FixedTarget ( targetCard . getId (  ) , targetCard . getZoneChangeCounter ( game )  )  ) ; new ExileSourceEffect (  )  . apply ( game, source ) ; return effect . apply ( game, source ) ; } return true; } return false; } } 
public class GripOfDesolation extends CardImpl { public GripOfDesolation ( UUID ownerId )  { super ( ownerId, 94, "Grip of Desolation", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{B}{B}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new ExileTargetEffect (  ) ; effect . setTargetPointer ( new SecondTargetPointer (  )  ) ; effect . setText ( "and target land" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetLandPermanent (  )  ) ; } public GripOfDesolation ( final GripOfDesolation card )  { super ( card ) ; } @Override public GripOfDesolation copy (  )  { return new GripOfDesolation ( this ) ; } } 
public class GroveRumbler extends CardImpl { public GroveRumbler ( UUID ownerId )  { super ( ownerId, 211, "Grove Rumbler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new LandfallAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , false )  ) ; } public GroveRumbler ( final GroveRumbler card )  { super ( card ) ; } @Override public GroveRumbler copy (  )  { return new GroveRumbler ( this ) ; } } 
public class GrovetenderDruids extends CardImpl { public GrovetenderDruids ( UUID ownerId )  { super ( ownerId, 212, "Grovetender Druids", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Druid" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility ( new GrovetenderDruidsEffect (  ) , false )  ) ; } public GrovetenderDruids ( final GrovetenderDruids card )  { super ( card ) ; } @Override public GrovetenderDruids copy (  )  { return new GrovetenderDruids ( this ) ; } } class GrovetenderDruidsEffect extends OneShotEffect { GrovetenderDruidsEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "you may pay {1} .  If you do, put a 1/1 green Plant creature token onto the battlefield"; } GrovetenderDruidsEffect ( final GrovetenderDruidsEffect effect )  { super ( effect ) ; } @Override public GrovetenderDruidsEffect copy (  )  { return new GrovetenderDruidsEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if ( player != null )  { if ( player . chooseUse ( Outcome . BoostCreature, "Do you want to to pay {1}?", source, game )  )  { Cost cost = new ManaCostsImpl ( "{1}" ) ; if ( cost . pay ( source, game, source . getSourceId (  ) , source . getControllerId (  ) , false, null )  )  { new CreateTokenEffect ( new GrovetenderDruidsPlantToken (  )  )  . apply ( game, source ) ; } return true; } } return false; } } class GrovetenderDruidsPlantToken extends Token { public GrovetenderDruidsPlantToken (  )  { super ( "Plant", "1/1 green Plant creature" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; subtype . add ( "Plant" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; this . setOriginalExpansionSetCode ( "BFZ" ) ; } } 
public class GruesomeSlaughter extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "colorless creatures you control" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public GruesomeSlaughter ( UUID ownerId )  { super ( ownerId, 9, "Gruesome Slaughter", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{6}" ) ; this . expansionSetCode = "BFZ"; Effect effect = new DamageTargetEffect ( new SourcePermanentPowerCount (  )  ) ; effect . setText ( "{this} deals damage equal to its power to target creature . " ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; effect = new GainAbilityControlledEffect ( ability, Duration . EndOfTurn, filter ) ; effect . setText ( "Until end of turn, colorless creatures you control gain \"{T}: This creature deals damage equal to its power to target creature . \"" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public GruesomeSlaughter ( final GruesomeSlaughter card )  { super ( card ) ; } @Override public GruesomeSlaughter copy (  )  { return new GruesomeSlaughter ( this ) ; } } 
public class GuardianOfTazeem extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature an opponent controls" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public GuardianOfTazeem ( UUID ownerId )  { super ( ownerId, 78, "Guardian of Tazeem", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{U}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Sphinx" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new GuardianOfTazeemTriggeredAbility (  ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; } public GuardianOfTazeem ( final GuardianOfTazeem card )  { super ( card ) ; } @Override public GuardianOfTazeem copy (  )  { return new GuardianOfTazeem ( this ) ; } } class GuardianOfTazeemTriggeredAbility extends TriggeredAbilityImpl { public GuardianOfTazeemTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , false ) ; addEffect ( new GuardianOfTazeemEffect (  )  ) ; } public GuardianOfTazeemTriggeredAbility ( final GuardianOfTazeemTriggeredAbility ability )  { super ( ability ) ; } @Override public GuardianOfTazeemTriggeredAbility copy (  )  { return new GuardianOfTazeemTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null && permanent . getCardType (  )  . contains ( CardType . LAND )  && permanent . getControllerId (  )  . equals ( getControllerId (  )  )  )  { for  ( Effect effect : getEffects (  )  )  { if  ( effect instanceof GuardianOfTazeemEffect )  { effect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; } } return true; } return false; } @Override public String getRule (  )  { return "<i>Landfall</i> - Whenever a land enters the battlefield under your control, " + super . getRule (  ) ; } } class GuardianOfTazeemEffect extends OneShotEffect { public GuardianOfTazeemEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "If that land is an Island, that creature doesn't untap during its controller's next untap step"; } public GuardianOfTazeemEffect ( final GuardianOfTazeemEffect effect )  { super ( effect ) ; } @Override public GuardianOfTazeemEffect copy (  )  { return new GuardianOfTazeemEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent land = game . getPermanentOrLKIBattlefield ( getTargetPointer (  )  . getFirst ( game, source )  ) ; Permanent targetCreature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( land != null && targetCreature != null )  { if  ( land . hasSubtype ( "Island" )  )  { ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect ( "that creature" ) ; effect . setTargetPointer ( new FixedTarget ( targetCreature, game )  ) ; game . addEffect ( effect, source ) ; } } return true; } } 
public class GuulDrazOverseer extends CardImpl { public GuulDrazOverseer ( UUID ownerId )  { super ( ownerId, 112, "Guul Draz Overseer", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new LandfallAbility ( Zone . BATTLEFIELD, new GuulDrazOverseerEffect (  ) , false, SetTargetPointer . PERMANENT )  ) ; } public GuulDrazOverseer ( final GuulDrazOverseer card )  { super ( card ) ; } @Override public GuulDrazOverseer copy (  )  { return new GuulDrazOverseer ( this ) ; } } class GuulDrazOverseerEffect extends OneShotEffect { public GuulDrazOverseerEffect (  )  { super ( Outcome . BoostCreature ) ; this . staticText = "other creatures you control get +1/+0 until end of turn .  If that land is a Swamp, those creatures get +2/+0 until end of turn instead"; } public GuulDrazOverseerEffect ( final GuulDrazOverseerEffect effect )  { super ( effect ) ; } @Override public GuulDrazOverseerEffect copy (  )  { return new GuulDrazOverseerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Permanent land = game . getPermanentOrLKIBattlefield ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && land != null )  { int boost = 1; if  ( land . getSubtype (  )  . contains ( "Swamp" )  )  { boost = 2; } game . addEffect ( new BoostControlledEffect ( boost, 0, Duration . EndOfTurn, true ) , source ) ; return true; } return false; } } 
public class HagraSharpshooter extends CardImpl { public HagraSharpshooter ( UUID ownerId )  { super ( ownerId, 113, "Hagra Sharpshooter", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Assassin" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -1, -1, Duration . EndOfTurn ) , new ManaCostsImpl ( "{4}{B}" )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public HagraSharpshooter ( final HagraSharpshooter card )  { super ( card ) ; } @Override public HagraSharpshooter copy (  )  { return new HagraSharpshooter ( this ) ; } } 
public class HalimarTidecaller extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Land creatures" ) ; private static final FilterCard filterCard = new FilterCard ( "card with awaken from your graveyard" ) ; static { filter . add ( new CardTypePredicate ( CardType . LAND )  ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; filterCard . add ( new AbilityPredicate ( AwakenAbility . class )  ) ; } public HalimarTidecaller ( UUID ownerId )  { super ( ownerId, 79, "Halimar Tidecaller", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new ReturnToHandTargetEffect (  ) , true ) ; ability . addTarget ( new TargetCardInYourGraveyard ( filterCard )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( FlyingAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public HalimarTidecaller ( final HalimarTidecaller card )  { super ( card ) ; } @Override public HalimarTidecaller copy (  )  { return new HalimarTidecaller ( this ) ; } } 
public class HedronArchive extends CardImpl { public HedronArchive ( UUID ownerId )  { super ( ownerId, 223, "Hedron Archive", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . ColorlessMana ( 2 ) , new TapSourceCost (  )  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 2 ) , new GenericManaCost ( 2 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public HedronArchive ( final HedronArchive card )  { super ( card ) ; } @Override public HedronArchive copy (  )  { return new HedronArchive ( this ) ; } } 
public class HedronBlade extends CardImpl { public HedronBlade ( UUID ownerId )  { super ( ownerId, 224, "Hedron Blade", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 1, 1 )  )  ) ; this . addAbility ( new HedronBladeTriggeredAbility (  new GainAbilityAttachedEffect ( DeathtouchAbility . getInstance (  ) , AttachmentType . EQUIPMENT, Duration . EndOfTurn )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 )  )  ) ; } public HedronBlade ( final HedronBlade card )  { super ( card ) ; } @Override public HedronBlade copy (  )  { return new HedronBlade ( this ) ; } } class HedronBladeTriggeredAbility extends TriggeredAbilityImpl { HedronBladeTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect, false ) ; } HedronBladeTriggeredAbility ( final HedronBladeTriggeredAbility ability )  { super ( ability ) ; } @Override public HedronBladeTriggeredAbility copy (  )  { return new HedronBladeTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DECLARED_BLOCKERS; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent equipment = game . getPermanentOrLKIBattlefield (  ( this . getSourceId (  )  )  ) ; if  ( equipment != null && equipment . getAttachedTo (  )  != null )  { Permanent equippedPermanent = game . getPermanentOrLKIBattlefield (  ( equipment . getAttachedTo (  )  )  ) ; if  ( equippedPermanent != null )  { if  ( equippedPermanent . isAttacking (  )  )  { for  ( CombatGroup group : game . getCombat (  )  . getGroups (  )  )  { if  ( group . getAttackers (  )  . contains ( equippedPermanent . getId (  )  )  )  { for  ( UUID blockerId : group . getBlockers (  )  )  { Permanent blocker = game . getPermanent ( blockerId ) ; if  ( blocker != null && blocker . getColor ( game )  . isColorless (  )  )  { return true; } } } } } } } return false; } @Override public String getRule (  )  { return "Whenever equipped creature becomes blocked by one or more colorless creatures, " + super . getRule (  ) ; } } 
public class HeraldOfKozilek extends CardImpl { private static final FilterCard filter = new FilterCard ( "Colorless spells" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public HeraldOfKozilek ( UUID ownerId )  { super ( ownerId, 205, "Herald of Kozilek", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SpellsCostReductionControllerEffect ( filter, 1 )  )  ) ; } public HeraldOfKozilek ( final HeraldOfKozilek card )  { super ( card ) ; } @Override public HeraldOfKozilek copy (  )  { return new HeraldOfKozilek ( this ) ; } } 
public class HeroOfGomaFada extends CardImpl { public HeroOfGomaFada ( UUID ownerId )  { super ( ownerId, 31, "Hero of Goma Fada", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new AllyEntersBattlefieldTriggeredAbility (  new GainAbilityAllEffect ( IndestructibleAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "creatures you control" )  ) , false ) ; this . addAbility ( ability ) ; } public HeroOfGomaFada ( final HeroOfGomaFada card )  { super ( card ) ; } @Override public HeroOfGomaFada copy (  )  { return new HeroOfGomaFada ( this ) ; } } 
public class HorriblyAwry extends CardImpl { private static final FilterCreatureSpell filter = new FilterCreatureSpell ( "creature spell with converted mana cost 4 or less" ) ; static { filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, 5 )  ) ; } public HorriblyAwry ( UUID ownerId )  { super ( ownerId, 59, "Horribly Awry", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new CounterTargetWithReplacementEffect ( Zone . EXILED )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; } public HorriblyAwry ( final HorriblyAwry card )  { super ( card ) ; } @Override public HorriblyAwry copy (  )  { return new HorriblyAwry ( this ) ; } } 
public class IncubatorDrone extends CardImpl { public IncubatorDrone ( UUID ownerId )  { super ( ownerId, 60, "Incubator Drone", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  )  ) ; effect . setText ( "put a 1/1 colorless Eldrazi Scion creature token onto the battlefield .  It has \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( effect, false )  ) ; } public IncubatorDrone ( final IncubatorDrone card )  { super ( card ) ; } @Override public IncubatorDrone copy (  )  { return new IncubatorDrone ( this ) ; } } 
public class KalastriaHealer extends CardImpl { public KalastriaHealer ( UUID ownerId )  { super ( ownerId, 114, "Kalastria Healer", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Cleric" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new AllyEntersBattlefieldTriggeredAbility ( new LoseLifeOpponentsEffect ( 1 ) , false ) ; Effect effect = new GainLifeEffect ( 1 ) ; effect . setText ( "and you gain 1 life" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public KalastriaHealer ( final KalastriaHealer card )  { super ( card ) ; } @Override public KalastriaHealer copy (  )  { return new KalastriaHealer ( this ) ; } } 
public class KalastriaNightwatch extends CardImpl { public KalastriaNightwatch ( UUID ownerId )  { super ( ownerId, 115, "Kalastria Nightwatch", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Warrior" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new GainLifeControllerTriggeredAbility ( new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , false )  ) ; } public KalastriaNightwatch ( final KalastriaNightwatch card )  { super ( card ) ; } @Override public KalastriaNightwatch copy (  )  { return new KalastriaNightwatch ( this ) ; } } 
public class KioraMasterOfTheDepths extends CardImpl { public KioraMasterOfTheDepths ( UUID ownerId )  { super ( ownerId, 213, "Kiora, Master of the Depths", Rarity . MYTHIC, new CardType[]{CardType . PLANESWALKER}, "{2}{G}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kiora" ) ; this . addAbility ( new PlanswalkerEntersWithLoyalityCountersAbility ( 4 )  ) ; LoyaltyAbility ability1 = new LoyaltyAbility ( new KioraUntapEffect (  ) , 1 ) ; ability1 . addTarget ( new TargetCreaturePermanent ( 0, 1, new FilterCreaturePermanent (  ) , false )  ) ; ability1 . addTarget ( new TargetLandPermanent ( 0, 1, new FilterLandPermanent (  ) , false )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( new LoyaltyAbility ( new KioraRevealEffect (  ) , -2 )  ) ; Effect effect = new CreateTokenEffect ( new OctopusToken (  ) , 3 ) ; effect . setText ( "Then put three 8/8 blue Octopus creature tokens onto the battlefield" ) ; LoyaltyAbility ability3 = new LoyaltyAbility ( new GetEmblemEffect ( new KioraMasterOfTheDepthsEmblem (  )  ) , -8 ) ; ability3 . addEffect ( effect ) ; this . addAbility ( ability3 ) ; } public KioraMasterOfTheDepths ( final KioraMasterOfTheDepths card )  { super ( card ) ; } @Override public KioraMasterOfTheDepths copy (  )  { return new KioraMasterOfTheDepths ( this ) ; } } class KioraUntapEffect extends OneShotEffect { public KioraUntapEffect (  )  { super ( Outcome . Untap ) ; this . staticText = "Untap up to one target creature and up to one target land"; } public KioraUntapEffect ( final KioraUntapEffect effect )  { super ( effect ) ; } @Override public KioraUntapEffect copy (  )  { return new KioraUntapEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent firstTarget = game . getPermanent ( source . getTargets (  )  . get ( 0 )  . getFirstTarget (  )  ) ; Permanent secondTarget = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( firstTarget != null )  { firstTarget . untap ( game ) ; } if  ( secondTarget != null )  { return secondTarget . untap ( game ) ; } return true; } } class KioraRevealEffect extends OneShotEffect { public KioraRevealEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Reveal the top four cards of your library .  You may put a creature card and/or a land card from among them into your hand .  Put the rest into your graveyard"; } public KioraRevealEffect ( final KioraRevealEffect effect )  { super ( effect ) ; } @Override public KioraRevealEffect copy (  )  { return new KioraRevealEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( sourceObject != null && controller != null )  { Cards cards = new CardsImpl (  ) ; cards . addAll ( controller . getLibrary (  )  . getTopCards ( game, 4 )  ) ; boolean creatureCardFound = false; boolean landCardFound = false; for  ( UUID cardId : cards )  { Card card = game . getCard ( cardId ) ; if  ( card != null )  { cards . add ( card ) ; if  ( card . getCardType (  )  . contains ( CardType . CREATURE )  )  { creatureCardFound = true; } if  ( card . getCardType (  )  . contains ( CardType . LAND )  )  { landCardFound = true; } } } if  ( !cards . isEmpty (  )  )  { controller . revealCards ( sourceObject . getName (  ) , cards, game ) ; if  (  ( creatureCardFound || landCardFound )  && controller . chooseUse ( Outcome . DrawCard, "Put a creature card and/or a land card into your hand?", source, game )  )  { TargetCard target = new TargetCard ( Zone . LIBRARY, new FilterCreatureCard ( "creature card to put into your hand" )  ) ; if  ( creatureCardFound && controller . chooseTarget ( Outcome . DrawCard, cards, target, source, game )  )  { Card card = cards . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { cards . remove ( card ) ; controller . moveCards ( card, null, Zone . HAND, source, game ) ; } } target = new TargetCard ( Zone . LIBRARY, new FilterLandCard ( "land card to put into your hand" )  ) ; if  ( landCardFound && controller . chooseTarget ( Outcome . DrawCard, cards, target, source, game )  )  { Card card = cards . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { cards . remove ( card ) ; controller . moveCards ( card, null, Zone . HAND, source, game ) ; } } } } controller . moveCards ( cards, null, Zone . GRAVEYARD, source, game ) ; return true; } return false; } } class KioraMasterOfTheDepthsEmblem extends Emblem { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures" ) ; public KioraMasterOfTheDepthsEmblem (  )  { this . setName ( "EMBLEM: Kiora, Master of the Depths" ) ; Ability ability = new EntersBattlefieldControlledTriggeredAbility ( Zone . COMMAND, new KioraFightEffect (  ) , filter, true, SetTargetPointer . PERMANENT, "Whenever a creature enters the battlefield under your control, you may have it fight target creature . " ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getAbilities (  )  . add ( ability ) ; this . setExpansionSetCodeForImage ( "BFZ" ) ; } } class KioraFightEffect extends OneShotEffect { KioraFightEffect (  )  { super ( Outcome . Damage ) ; } KioraFightEffect ( final KioraFightEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent triggeredCreature = game . getPermanent ( getTargetPointer (  )  . getFirst ( game, source )  ) ; Permanent target = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( triggeredCreature != null && target != null && triggeredCreature . getCardType (  )  . contains ( CardType . CREATURE )  && target . getCardType (  )  . contains ( CardType . CREATURE )  )  { triggeredCreature . fight ( target, source, game ) ; return true; } return false; } @Override public KioraFightEffect copy (  )  { return new KioraFightEffect ( this ) ; } } class OctopusToken extends Token { public OctopusToken (  )  { super ( "Octopus", "8/8 blue Octopus creature token" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlue ( true ) ; subtype . add ( "Octopus" ) ; power = new MageInt ( 8 ) ; toughness = new MageInt ( 8 ) ; this . setOriginalExpansionSetCode ( "BFZ" ) ; } } 
public class KitesailScout extends CardImpl { public KitesailScout ( UUID ownerId )  { super ( ownerId, 33, "Kitesail Scout", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } public KitesailScout ( final KitesailScout card )  { super ( card ) ; } @Override public KitesailScout copy (  )  { return new KitesailScout ( this ) ; } } 
public class KorBladewhirl extends CardImpl { public KorBladewhirl ( UUID ownerId )  { super ( ownerId, 34, "Kor Bladewhirl", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Soldier" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility (  new GainAbilityControlledEffect ( FirstStrikeAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "creatures you control" )  ) , false )  ) ; } public KorBladewhirl ( final KorBladewhirl card )  { super ( card ) ; } @Override public KorBladewhirl copy (  )  { return new KorBladewhirl ( this ) ; } } 
public class KorCastigator extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Eldrazi Scions" ) ; static { filter . add ( new SubtypePredicate ( "Eldrazi" )  ) ; filter . add ( new SubtypePredicate ( "Scion" )  ) ; } public KorCastigator ( UUID ownerId )  { super ( ownerId, 35, "Kor Castigator", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Wizard" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleEvasionAbility ( new CantBeBlockedByCreaturesSourceEffect ( filter, Duration . WhileOnBattlefield )  )  ) ; } public KorCastigator ( final KorCastigator card )  { super ( card ) ; } @Override public KorCastigator copy (  )  { return new KorCastigator ( this ) ; } } 
public class KorEntanglers extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature an opponent controls" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public KorEntanglers ( UUID ownerId )  { super ( ownerId, 36, "Kor Entanglers", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Soldier" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new AllyEntersBattlefieldTriggeredAbility ( new TapTargetEffect (  ) , false ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; } public KorEntanglers ( final KorEntanglers card )  { super ( card ) ; } @Override public KorEntanglers copy (  )  { return new KorEntanglers ( this ) ; } } 
public class KozileksChanneler extends CardImpl { public KozileksChanneler ( UUID ownerId )  { super ( ownerId, 10, "Kozilek's Channeler", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . ColorlessMana ( 2 ) , new TapSourceCost (  )  )  ) ; } public KozileksChanneler ( final KozileksChanneler card )  { super ( card ) ; } @Override public KozileksChanneler copy (  )  { return new KozileksChanneler ( this ) ; } } 
public class KozileksSentinel extends CardImpl { private static final FilterSpell filterSpell = new FilterSpell ( "a colorless spell" ) ; static { filterSpell . add ( new ColorlessPredicate (  )  ) ; } public KozileksSentinel ( UUID ownerId )  { super ( ownerId, 129, "Kozilek's Sentinel", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new BoostSourceEffect ( 1, 0, Duration . EndOfTurn ) , filterSpell, false )  ) ; } public KozileksSentinel ( final KozileksSentinel card )  { super ( card ) ; } @Override public KozileksSentinel copy (  )  { return new KozileksSentinel ( this ) ; } } 
public class LanternScout extends CardImpl { public LanternScout ( UUID ownerId )  { super ( ownerId, 37, "Lantern Scout", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Scout" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; FilterPermanent filter = new FilterPermanent ( "{this} or another Ally" ) ; filter . add ( Predicates . or (  new CardIdPredicate ( this . getId (  )  ) , new SubtypePredicate ( "Ally" )  )  ) ; Effect effect = new GainAbilityAllEffect ( LifelinkAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent (  )  ) ; effect . setText ( "creatures you control gain lifelink until end of turn" ) ; Ability ability = new AllyEntersBattlefieldTriggeredAbility (  effect, false ) ; this . addAbility ( ability ) ; } public LanternScout ( final LanternScout card )  { super ( card ) ; } @Override public LanternScout copy (  )  { return new LanternScout ( this ) ; } } 
public class LavastepRaider extends CardImpl { public LavastepRaider ( UUID ownerId )  { super ( ownerId, 147, "Lavastep Raider", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 2, 0, Duration . EndOfTurn ) , new ManaCostsImpl<> ( "{2}{R}" )  )  ) ; } public LavastepRaider ( final LavastepRaider card )  { super ( card ) ; } @Override public LavastepRaider copy (  )  { return new LavastepRaider ( this ) ; } } 
public class LifespringDruid extends CardImpl { public LifespringDruid ( UUID ownerId )  { super ( ownerId, 177, "Lifespring Druid", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new AnyColorManaAbility (  )  ) ; } public LifespringDruid ( final LifespringDruid card )  { super ( card ) ; } @Override public LifespringDruid copy (  )  { return new LifespringDruid ( this ) ; } } 
public class LithomancersFocus extends CardImpl { public LithomancersFocus ( UUID ownerId )  { super ( ownerId, 38, "Lithomancer's Focus", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( 2, 2, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new LithomancersFocusPreventDamageToTargetEffect (  )  ) ; } public LithomancersFocus ( final LithomancersFocus card )  { super ( card ) ; } @Override public LithomancersFocus copy (  )  { return new LithomancersFocus ( this ) ; } } class LithomancersFocusPreventDamageToTargetEffect extends PreventionEffectImpl { public LithomancersFocusPreventDamageToTargetEffect (  )  { super ( Duration . EndOfTurn, Integer . MAX_VALUE, false ) ; staticText = "Prevent all damage that would be dealt to that creature this turn by colorless sources"; } public LithomancersFocusPreventDamageToTargetEffect ( final LithomancersFocusPreventDamageToTargetEffect effect )  { super ( effect ) ; } @Override public LithomancersFocusPreventDamageToTargetEffect copy (  )  { return new LithomancersFocusPreventDamageToTargetEffect ( this ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( super . applies ( event, source, game )  && event . getTargetId (  )  . equals ( targetPointer . getFirst ( game, source )  )  )  { MageObject object = game . getObject ( event . getSourceId (  )  ) ; return object != null && object . getColor ( game )  . isColorless (  ) ; } return false; } } 
public class LoomingSpires extends CardImpl { public LoomingSpires ( UUID ownerId )  { super ( ownerId, 238, "Looming Spires", Rarity . COMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; Effect effect = new GainAbilityTargetEffect ( FirstStrikeAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains first strike" ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new BoostTargetEffect ( 1, 1, Duration . EndOfTurn ) , false ) ; ability . addEffect ( effect ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new RedManaAbility (  )  ) ; } public LoomingSpires ( final LoomingSpires card )  { super ( card ) ; } @Override public LoomingSpires copy (  )  { return new LoomingSpires ( this ) ; } } 
public class LumberingFalls extends CardImpl { public LumberingFalls ( UUID ownerId )  { super ( ownerId, 239, "Lumbering Falls", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureSourceEffect ( new LumberingFallsToken (  ) , "land", Duration . EndOfTurn ) , new ManaCostsImpl ( "{2}{G}{U}" )  )  ) ; } public LumberingFalls ( final LumberingFalls card )  { super ( card ) ; } @Override public LumberingFalls copy (  )  { return new LumberingFalls ( this ) ; } } class LumberingFallsToken extends Token { public LumberingFallsToken (  )  { super ( "", "3/3 green and blue Elemental creature with hexproof" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Elemental" ) ; color . setBlue ( true ) ; color . setGreen ( true ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; addAbility ( HexproofAbility . getInstance (  )  ) ; } } 
public class MakindiPatrol extends CardImpl { public MakindiPatrol ( UUID ownerId )  { super ( ownerId, 39, "Makindi Patrol", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility (  new GainAbilityControlledEffect ( VigilanceAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "creatures" )  ) , false )  ) ; } public MakindiPatrol ( final MakindiPatrol card )  { super ( card ) ; } @Override public MakindiPatrol copy (  )  { return new MakindiPatrol ( this ) ; } } 
public class MakindiSliderunner extends CardImpl { public MakindiSliderunner ( UUID ownerId )  { super ( ownerId, 148, "Makindi Sliderunner", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new LandfallAbility ( new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , false )  ) ; } public MakindiSliderunner ( final MakindiSliderunner card )  { super ( card ) ; } @Override public MakindiSliderunner copy (  )  { return new MakindiSliderunner ( this ) ; } } 
public class MalakirFamiliar extends CardImpl { public MalakirFamiliar ( UUID ownerId )  { super ( ownerId, 116, "Malakir Familiar", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Bat" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( DeathtouchAbility . getInstance (  )  ) ; this . addAbility ( new GainLifeControllerTriggeredAbility ( new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , false )  ) ; } public MalakirFamiliar ( final MalakirFamiliar card )  { super ( card ) ; } @Override public MalakirFamiliar copy (  )  { return new MalakirFamiliar ( this ) ; } } 
public class MiresMalice extends CardImpl { public MiresMalice ( UUID ownerId )  { super ( ownerId, 117, "Mire's Malice", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{B}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DiscardTargetEffect ( 2 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( new AwakenAbility ( this, 3, "{5}{B}" )  ) ; } public MiresMalice ( final MiresMalice card )  { super ( card ) ; } @Override public MiresMalice copy (  )  { return new MiresMalice ( this ) ; } } 
public class MistIntruder extends CardImpl { public MistIntruder ( UUID ownerId )  { super ( ownerId, 61, "Mist Intruder", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new IngestAbility (  )  ) ; } public MistIntruder ( final MistIntruder card )  { super ( card ) ; } @Override public MistIntruder copy (  )  { return new MistIntruder ( this ) ; } } 
public class MoltenNursery extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "a colorless spell" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public MoltenNursery ( UUID ownerId )  { super ( ownerId, 130, "Molten Nursery", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new DevoidAbility ( this . color )  ) ; Ability ability = new SpellCastControllerTriggeredAbility ( new DamageTargetEffect ( 1 ) , filter, false ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public MoltenNursery ( final MoltenNursery card )  { super ( card ) ; } @Override public MoltenNursery copy (  )  { return new MoltenNursery ( this ) ; } } 
public class MortuaryMire extends CardImpl { public MortuaryMire ( UUID ownerId )  { super ( ownerId, 240, "Mortuary Mire", Rarity . COMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new PutOnLibraryTargetEffect ( true ) , true ) ; ability . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "creature card from your graveyard" )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public MortuaryMire ( final MortuaryMire card )  { super ( card ) ; } @Override public MortuaryMire copy (  )  { return new MortuaryMire ( this ) ; } } 
public class MundaAmbushLeader extends CardImpl { public MundaAmbushLeader ( UUID ownerId )  { super ( ownerId, 215, "Munda, Ambush Leader", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{W}" ) ; this . expansionSetCode = "BFZ"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility ( new MundaAmbushLeaderEffect (  ) , true )  ) ; } public MundaAmbushLeader ( final MundaAmbushLeader card )  { super ( card ) ; } @Override public MundaAmbushLeader copy (  )  { return new MundaAmbushLeader ( this ) ; } } class MundaAmbushLeaderEffect extends OneShotEffect { private static final FilterCard filter = new FilterCard ( "Ally cards to reveal and put on top of your library" ) ; static { filter . add ( new SubtypePredicate ( "Ally" )  ) ; } public MundaAmbushLeaderEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "you may look at the top four cards of your library .  If you do, reveal any number of Ally cards from among them, then put those cards on top of your library in any order and the rest on the bottom in any order"; } public MundaAmbushLeaderEffect ( final MundaAmbushLeaderEffect effect )  { super ( effect ) ; } @Override public MundaAmbushLeaderEffect copy (  )  { return new MundaAmbushLeaderEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller != null && sourceObject != null )  { Cards allCards = new CardsImpl (  ) ; allCards . addAll ( controller . getLibrary (  )  . getTopCards ( game, 4 )  ) ; controller . lookAtCards ( sourceObject . getIdName (  ) , allCards, game ) ; if  ( !allCards . isEmpty (  )  )  { Cards cardsToReveal = new CardsImpl (  ) ; TargetCard target = new TargetCard ( 0, Integer . MAX_VALUE, Zone . LIBRARY, filter ) ; controller . chooseTarget ( outcome, allCards, target, source, game ) ; cardsToReveal . addAll ( target . getTargets (  )  ) ; if  ( !cardsToReveal . isEmpty (  )  )  { controller . revealCards ( sourceObject . getIdName (  ) , cardsToReveal, game, true ) ; allCards . removeAll ( cardsToReveal ) ; } controller . putCardsOnTopOfLibrary ( cardsToReveal, game, source, true ) ; } if  ( !allCards . isEmpty (  )  )  { controller . putCardsOnBottomOfLibrary ( allCards, game, source, true ) ; } return true; } return false; } } 
public class MurasaRanger extends CardImpl { public MurasaRanger ( UUID ownerId )  { super ( ownerId, 178, "Murasa Ranger", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new LandfallAbility ( new DoIfCostPaid ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  ) , new ManaCostsImpl ( "{3}{G}" )  ) , false )  ) ; } public MurasaRanger ( final MurasaRanger card )  { super ( card ) ; } @Override public MurasaRanger copy (  )  { return new MurasaRanger ( this ) ; } } 
public class MurkStrider extends CardImpl { public MurkStrider ( UUID ownerId )  { super ( ownerId, 62, "Murk Strider", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility (  new DoIfCostPaid ( new ReturnToHandTargetEffect (  ) , new ExileOpponentsCardFromExileToGraveyardCost ( true )  ) , false ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MurkStrider ( final MurkStrider card )  { super ( card ) ; } @Override public MurkStrider copy (  )  { return new MurkStrider ( this ) ; } } 
public class NaturalConnection extends CardImpl { public NaturalConnection ( UUID ownerId )  { super ( ownerId, 179, "Natural Connection", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{G}" ) ; this . expansionSetCode = "BFZ"; TargetCardInLibrary target = new TargetCardInLibrary ( new FilterBasicLandCard (  )  ) ; this . getSpellAbility (  )  . addEffect ( new SearchLibraryPutInPlayEffect ( target, true )  ) ; } public NaturalConnection ( final NaturalConnection card )  { super ( card ) ; } @Override public NaturalConnection copy (  )  { return new NaturalConnection ( this ) ; } } 
public class NettleDrone extends CardImpl { private static final FilterSpell filterSpell = new FilterSpell ( "a colorless spell" ) ; static { filterSpell . add ( new ColorlessPredicate (  )  ) ; } public NettleDrone ( UUID ownerId )  { super ( ownerId, 131, "Nettle Drone", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamagePlayersEffect ( 1, TargetController . OPPONENT ) , new TapSourceCost (  )  )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new UntapSourceEffect (  ) , filterSpell, false )  ) ; } public NettleDrone ( final NettleDrone card )  { super ( card ) ; } @Override public NettleDrone copy (  )  { return new NettleDrone ( this ) ; } } 
public class NirkanaAssassin extends CardImpl { public NirkanaAssassin ( UUID ownerId )  { super ( ownerId, 118, "Nirkana Assassin", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Assassin" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new GainLifeControllerTriggeredAbility ( new GainAbilitySourceEffect ( DeathtouchAbility . getInstance (  ) , Duration . EndOfTurn ) , false )  ) ; } public NirkanaAssassin ( final NirkanaAssassin card )  { super ( card ) ; } @Override public NirkanaAssassin copy (  )  { return new NirkanaAssassin ( this ) ; } } 
public class NissasRenewal extends CardImpl { public NissasRenewal ( UUID ownerId )  { super ( ownerId, 180, "Nissa's Renewal", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{5}{G}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new SearchLibraryPutInPlayEffect ( new TargetCardInLibrary ( 0, 3, new FilterBasicLandCard (  )  ) , true )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 7 )  ) ; } public NissasRenewal ( final NissasRenewal card )  { super ( card ) ; } @Override public NissasRenewal copy (  )  { return new NissasRenewal ( this ) ; } } 
public class NoyanDarRoilShaper extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant or sorcery card" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . INSTANT ) , new CardTypePredicate ( CardType . SORCERY )  )  ) ; } public NoyanDarRoilShaper ( UUID ownerId )  { super ( ownerId, 216, "Noyan Dar, Roil Shaper", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{W}{U}" ) ; this . expansionSetCode = "BFZ"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new SpellCastControllerTriggeredAbility ( new NoyanDarEffect (  ) , filter, false ) ; ability . addTarget ( new TargetControlledPermanent ( new FilterControlledLandPermanent (  )  )  ) ; this . addAbility ( ability ) ; } public NoyanDarRoilShaper ( final NoyanDarRoilShaper card )  { super ( card ) ; } @Override public NoyanDarRoilShaper copy (  )  { return new NoyanDarRoilShaper ( this ) ; } } class NoyanDarEffect extends OneShotEffect { public NoyanDarEffect (  )  { super ( Outcome . BoostCreature ) ; this . staticText = "put three +1/+1 counters on target land you control .  If you do, that land becomes a 0/0 Elemental creature with haste that's still a land . "; } public NoyanDarEffect ( final NoyanDarEffect effect )  { super ( effect ) ; } @Override public NoyanDarEffect copy (  )  { return new NoyanDarEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID targetId = null; for  ( Target target : source . getTargets (  )  )  { targetId = target . getFirstTarget (  ) ; } if  ( targetId != null )  { FixedTarget fixedTarget = new FixedTarget ( targetId ) ; ContinuousEffect continuousEffect = new BecomesCreatureTargetEffect ( new AwakenElementalToken (  ) , false, true, Duration . Custom ) ; continuousEffect . setTargetPointer ( fixedTarget ) ; game . addEffect ( continuousEffect, source ) ; Effect effect = new AddCountersTargetEffect ( CounterType . P1P1 . createInstance ( 3 )  ) ; effect . setTargetPointer ( fixedTarget ) ; return effect . apply ( game, source ) ; } return true; } } class AwakenElementalToken extends Token { public AwakenElementalToken (  )  { super ( "", "0/0 Elemental creature with haste" ) ; this . cardType . add ( CardType . CREATURE ) ; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; } } 
public class OblivionSower extends CardImpl { public OblivionSower ( UUID ownerId )  { super ( ownerId, 11, "Oblivion Sower", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{6}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 8 ) ; Ability ability = new CastSourceTriggeredAbility ( new ExileCardsFromTopOfLibraryTargetEffect ( 4, "target opponent" ) , false ) ; ability . addEffect ( new OblivionSowerEffect (  )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public OblivionSower ( final OblivionSower card )  { super ( card ) ; } @Override public OblivionSower copy (  )  { return new OblivionSower ( this ) ; } } class OblivionSowerEffect extends OneShotEffect { public OblivionSowerEffect (  )  { super ( Outcome . PutLandInPlay ) ; this . staticText = ", then you may put any number of land cards that player owns from exile onto the battlefield under your control"; } public OblivionSowerEffect ( final OblivionSowerEffect effect )  { super ( effect ) ; } @Override public OblivionSowerEffect copy (  )  { return new OblivionSowerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && targetPlayer != null )  { FilterLandCard filter = new FilterLandCard (  ) ; filter . add ( new OwnerIdPredicate ( targetPlayer . getId (  )  )  ) ; Cards exiledCards = new CardsImpl (  ) ; exiledCards . addAll ( game . getExile (  )  . getAllCards ( game )  ) ; Cards exiledLands = new CardsImpl (  ) ; exiledLands . addAll ( exiledCards . getCards ( filter, source . getSourceId (  ) , controller . getId (  ) , game )  ) ; if  ( !exiledLands . isEmpty (  )  && controller . chooseUse ( outcome, "Put lands into play?", source, game )  )  { FilterCard filterToPlay = new FilterCard ( "land" +  ( exiledLands . size (  )  > 1 ? "s" : "" )  + " from exile owned by " + targetPlayer . getName (  )  + " to put into play under your control" ) ; TargetCard targetCards = new TargetCard ( 0, exiledLands . size (  ) , Zone . EXILED, filterToPlay ) ; if  ( controller . chooseTarget ( outcome, exiledLands, targetCards, source, game )  )  { controller . moveCards ( new CardsImpl ( targetCards . getTargets (  )  ) , Zone . BATTLEFIELD, source, game ) ; } } return true; } return false; } } 
public class ObNixilisReignited extends CardImpl { public ObNixilisReignited ( UUID ownerId )  { super ( ownerId, 119, "Ob Nixilis Reignited", Rarity . MYTHIC, new CardType[]{CardType . PLANESWALKER}, "{3}{B}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Nixilis" ) ; this . addAbility ( new PlanswalkerEntersWithLoyalityCountersAbility ( 5 )  ) ; Effect effect = new DrawCardSourceControllerEffect ( 1 ) ; effect . setText ( "You draw a card" ) ; LoyaltyAbility ability1 = new LoyaltyAbility ( effect, 1 ) ; effect = new LoseLifeSourceControllerEffect ( 1 ) ; effect . setText ( "and you lose 1 life" ) ; ability1 . addEffect ( effect ) ; this . addAbility ( ability1 ) ; LoyaltyAbility ability2 = new LoyaltyAbility ( new DestroyTargetEffect (  ) , -3 ) ; ability2 . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability2 ) ; effect = new GetEmblemTargetPlayerEffect ( new ObNixilisReignitedEmblem (  )  ) ; effect . setText ( "Target opponent gets an emblem with \"Whenever a player draws a card, you lose 2 life . \"" ) ; LoyaltyAbility ability3 = new LoyaltyAbility ( effect, -8 ) ; ability3 . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability3 ) ; } public ObNixilisReignited ( final ObNixilisReignited card )  { super ( card ) ; } @Override public ObNixilisReignited copy (  )  { return new ObNixilisReignited ( this ) ; } } class ObNixilisReignitedEmblem extends Emblem { public ObNixilisReignitedEmblem (  )  { setName ( "EMBLEM: Ob Nixilis Reignited" ) ; this . getAbilities (  )  . add ( new ObNixilisEmblemTriggeredAbility ( new LoseLifeSourceControllerEffect ( 2 ) , false )  ) ; this . setExpansionSetCodeForImage ( "BFZ" ) ; } } class ObNixilisEmblemTriggeredAbility extends TriggeredAbilityImpl { public ObNixilisEmblemTriggeredAbility ( Effect effect, boolean optional )  { super ( Zone . COMMAND, effect, optional ) ; } public ObNixilisEmblemTriggeredAbility ( final ObNixilisEmblemTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DREW_CARD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { return event . getPlayerId (  )  != null; } @Override public String getRule (  )  { return "Whenever a player draws a card, you lose 2 life . "; } @Override public ObNixilisEmblemTriggeredAbility copy (  )  { return new ObNixilisEmblemTriggeredAbility ( this ) ; } } 
public class OmnathLocusOfRage extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Elemental you control" ) ; static { filter . add ( new SubtypePredicate ( "Elemental" )  ) ; filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public OmnathLocusOfRage ( UUID ownerId )  { super ( ownerId, 217, "Omnath, Locus of Rage", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{R}{R}{G}{G}" ) ; this . expansionSetCode = "BFZ"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new LandfallAbility ( new CreateTokenEffect ( new OmnathElementalToken (  )  ) , false )  ) ; Ability ability = new DiesThisOrAnotherCreatureTriggeredAbility ( new DamageTargetEffect ( 3 ) , false, filter ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public OmnathLocusOfRage ( final OmnathLocusOfRage card )  { super ( card ) ; } @Override public OmnathLocusOfRage copy (  )  { return new OmnathLocusOfRage ( this ) ; } } class OmnathElementalToken extends Token { OmnathElementalToken (  )  { super ( "Elemental", "5/5 red and green Elemental creature token" ) ; setTokenType ( 2 ) ; setOriginalExpansionSetCode ( "BFZ" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Elemental" ) ; color . setRed ( true ) ; color . setGreen ( true ) ; power = new MageInt ( 5 ) ; toughness = new MageInt ( 5 ) ; } } 
public class OnduChampion extends CardImpl { public OnduChampion ( UUID ownerId )  { super ( ownerId, 149, "Ondu Champion", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Warrior" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility (  new GainAbilityControlledEffect ( TrampleAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "creatures you control" )  ) , false )  ) ; } public OnduChampion ( final OnduChampion card )  { super ( card ) ; } @Override public OnduChampion copy (  )  { return new OnduChampion ( this ) ; } } 
public class OnduGreathorn extends CardImpl { public OnduGreathorn ( UUID ownerId )  { super ( ownerId, 40, "Ondu Greathorn", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new LandfallAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , false )  ) ; } public OnduGreathorn ( final OnduGreathorn card )  { super ( card ) ; } @Override public OnduGreathorn copy (  )  { return new OnduGreathorn ( this ) ; } } 
public class OnduRising extends CardImpl { public OnduRising ( UUID ownerId )  { super ( ownerId, 41, "Ondu Rising", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new CreateDelayedTriggeredAbilityEffect ( new OnduRisingTriggeredAbility (  )  )  ) ; this . addAbility ( new AwakenAbility ( this, 4, "{4}{W}" )  ) ; } public OnduRising ( final OnduRising card )  { super ( card ) ; } @Override public OnduRising copy (  )  { return new OnduRising ( this ) ; } } class OnduRisingTriggeredAbility extends DelayedTriggeredAbility { public OnduRisingTriggeredAbility (  )  { super ( new GainAbilityTargetEffect ( LifelinkAbility . getInstance (  ) , Duration . EndOfTurn ) , Duration . EndOfTurn, false ) ; } public OnduRisingTriggeredAbility ( OnduRisingTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent permanent = game . getPermanent ( event . getSourceId (  )  ) ; if  ( permanent != null )  { for  ( Effect effect : getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; } return true; } return false; } @Override public OnduRisingTriggeredAbility copy (  )  { return new OnduRisingTriggeredAbility ( this ) ; } @Override public String getRule (  )  { return "Whenever a creature attacks this turn, it gains lifelink until end of turn . "; } } 
public class OranRiefInvoker extends CardImpl { public OranRiefInvoker ( UUID ownerId )  { super ( ownerId, 182, "Oran-Rief Invoker", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Effect effect = new BoostSourceEffect ( 5, 5, Duration . EndOfTurn ) ; effect . setText ( "{source} gets +5/+5" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new GenericManaCost ( 8 )  ) ; effect = new GainAbilitySourceEffect ( TrampleAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains trample until end of turn" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public OranRiefInvoker ( final OranRiefInvoker card )  { super ( card ) ; } @Override public OranRiefInvoker copy (  )  { return new OranRiefInvoker ( this ) ; } } 
public class Outnumber extends CardImpl { public Outnumber ( UUID ownerId )  { super ( ownerId, 150, "Outnumber", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{R}" ) ; this . expansionSetCode = "BFZ"; Effect effect = new DamageTargetEffect ( new PermanentsOnBattlefieldCount ( new FilterControlledCreaturePermanent ( "the number of creatures you control" )  )  ) ; effect . setText ( "{this} deals damage to target creature equal to the number of creatures you control" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public Outnumber ( final Outnumber card )  { super ( card ) ; } @Override public Outnumber copy (  )  { return new Outnumber ( this ) ; } } 
public class PainfulTruths extends CardImpl { public PainfulTruths ( UUID ownerId )  { super ( ownerId, 120, "Painful Truths", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; getSpellAbility (  )  . setAbilityWord ( AbilityWord . CONVERGE ) ; Effect effect = new DrawCardSourceControllerEffect ( ColorsOfManaSpentToCastCount . getInstance (  )  ) ; effect . setText ( "You draw X cards" ) ; getSpellAbility (  )  . addEffect ( effect ) ; effect = new LoseLifeSourceControllerEffect ( ColorsOfManaSpentToCastCount . getInstance (  )  ) ; effect . setText ( "and lose X life, where X is the number of colors of mana spent to cast {this}" ) ; getSpellAbility (  )  . addEffect ( effect ) ; } public PainfulTruths ( final PainfulTruths card )  { super ( card ) ; } @Override public PainfulTruths copy (  )  { return new PainfulTruths ( this ) ; } } 
public class PartTheWaterveil extends CardImpl { public PartTheWaterveil ( UUID ownerId )  { super ( ownerId, 80, "Part the Waterveil", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{4}{U}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new AddExtraTurnControllerEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( ExileSpellEffect . getInstance (  )  ) ; this . addAbility ( new AwakenAbility ( this, 6, "{6}{U}{U}{U}" )  ) ; } public PartTheWaterveil ( final PartTheWaterveil card )  { super ( card ) ; } @Override public PartTheWaterveil copy (  )  { return new PartTheWaterveil ( this ) ; } } 
public class PathwayArrows extends CardImpl { public PathwayArrows ( UUID ownerId )  { super ( ownerId, 225, "Pathway Arrows", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Equipment" ) ; SimpleActivatedAbility ability2 = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PathwayArrowsEffect (  ) , new GenericManaCost ( 2 )  ) ; ability2 . addCost ( new TapSourceCost (  )  ) ; ability2 . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability2, AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 )  )  ) ; } public PathwayArrows ( final PathwayArrows card )  { super ( card ) ; } @Override public PathwayArrows copy (  )  { return new PathwayArrows ( this ) ; } } class PathwayArrowsEffect extends OneShotEffect { public PathwayArrowsEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "This creature deals 1 damage to target creature .  If a colorless creature is dealt damage this way, tap it"; } public PathwayArrowsEffect ( final PathwayArrowsEffect effect )  { super ( effect ) ; } @Override public PathwayArrowsEffect copy (  )  { return new PathwayArrowsEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Permanent targetCreature = game . getPermanent ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( targetCreature != null )  { int damageDealt = targetCreature . damage ( 1, source . getSourceId (  ) , game, false, true ) ; if  ( damageDealt > 0 && targetCreature . getColor ( game )  . isColorless (  )  )  { targetCreature . tap ( game ) ; } } return true; } return false; } } 
public class PlanarOutburst extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonland creatures" ) ; static { filter . add ( Predicates . not ( new CardTypePredicate ( CardType . LAND )  )  ) ; } public PlanarOutburst ( UUID ownerId )  { super ( ownerId, 42, "Planar Outburst", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{W}{W}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DestroyAllEffect ( filter, false )  ) ; this . addAbility ( new AwakenAbility ( this, 4, "{5}{W}{W}{W}" )  ) ; } public PlanarOutburst ( final PlanarOutburst card )  { super ( card ) ; } @Override public PlanarOutburst copy (  )  { return new PlanarOutburst ( this ) ; } } 
public class PlatedCrusher extends CardImpl { public PlatedCrusher ( UUID ownerId )  { super ( ownerId, 183, "Plated Crusher", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{G}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( HexproofAbility . getInstance (  )  ) ; } public PlatedCrusher ( final PlatedCrusher card )  { super ( card ) ; } @Override public PlatedCrusher copy (  )  { return new PlatedCrusher ( this ) ; } } 
public class PrairieStream extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public PrairieStream ( UUID ownerId )  { super ( ownerId, 241, "Prairie Stream", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Plains" ) ; this . subtype . add ( "Island" ) ; Condition controls = new InvertCondition ( new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . MORE_THAN, 1 )  ) ; String abilityText = "tapped unless you control two or more basic lands"; this . addAbility ( new EntersBattlefieldAbility ( new ConditionalOneShotEffect ( new TapSourceEffect (  ) , controls, abilityText ) , abilityText )  ) ; this . addAbility ( new WhiteManaAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; } public PrairieStream ( final PrairieStream card )  { super ( card ) ; } @Override public PrairieStream copy (  )  { return new PrairieStream ( this ) ; } } 
public class PrismArray extends CardImpl { public PrismArray ( UUID ownerId )  { super ( ownerId, 81, "Prism Array", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{4}{U}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . CRYSTAL . createInstance (  ) , ColorsOfManaSpentToCastCount . getInstance (  ) , true ) , null, "<i>Converge</i> &mdash; {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it . ", null )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new RemoveCountersSourceCost ( CounterType . CRYSTAL . createInstance ( 1 )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ScryEffect ( 3 ) , new ManaCostsImpl ( "{W}{U}{B}{R}{G}" )  )  ) ; } public PrismArray ( final PrismArray card )  { super ( card ) ; } @Override public PrismArray copy (  )  { return new PrismArray ( this ) ; } } 
public class ProcessorAssault extends CardImpl { public ProcessorAssault ( UUID ownerId )  { super ( ownerId, 132, "Processor Assault", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{R}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addCost ( new ExileOpponentsCardFromExileToGraveyardCost ( false )  ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 5 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public ProcessorAssault ( final ProcessorAssault card )  { super ( card ) ; } @Override public ProcessorAssault copy (  )  { return new ProcessorAssault ( this ) ; } } 
public class QuarantineField extends CardImpl { public QuarantineField ( UUID ownerId )  { super ( ownerId, 43, "Quarantine Field", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT}, "{X}{X}{W}{W}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldAbility ( new EntersBattlefieldWithXCountersEffect ( new Counter ( "isolation" )  )  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new QuarantineFieldEffect (  ) , false ) ; ability . addEffect ( new CreateDelayedTriggeredAbilityEffect ( new OnLeaveReturnExiledToBattlefieldAbility (  )  )  ) ; this . addAbility ( ability ) ; } public QuarantineField ( final QuarantineField card )  { super ( card ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof EntersBattlefieldTriggeredAbility )  { Permanent sourceObject = game . getPermanent ( ability . getSourceId (  )  ) ; if  ( sourceObject != null )  { int isolationCounters = sourceObject . getCounters ( game )  . getCount ( "isolation" ) ; FilterNonlandPermanent filter = new FilterNonlandPermanent ( "up to " + isolationCounters + " nonland permanents controlled by any opponents" ) ; filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; ability . addTarget ( new TargetPermanent ( 0, isolationCounters, filter, false )  ) ; } } } @Override public QuarantineField copy (  )  { return new QuarantineField ( this ) ; } } class QuarantineFieldEffect extends OneShotEffect { public QuarantineFieldEffect (  )  { super ( Outcome . Exile ) ; this . staticText = "for each isolation counter on it, exile up to one target nonland permanent an opponenet controls until {this} leaves the battlefield"; } public QuarantineFieldEffect ( final QuarantineFieldEffect effect )  { super ( effect ) ; } @Override public QuarantineFieldEffect copy (  )  { return new QuarantineFieldEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { return new ExileTargetEffect ( CardUtil . getCardExileZoneId ( game, source ) , permanent . getIdName (  )  )  . apply ( game, source ) ; } return false; } } 
public class RadiantFlames extends CardImpl { public RadiantFlames ( UUID ownerId )  { super ( ownerId, 151, "Radiant Flames", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; getSpellAbility (  )  . setAbilityWord ( AbilityWord . CONVERGE ) ; getSpellAbility (  )  . addEffect ( new DamageAllEffect ( ColorsOfManaSpentToCastCount . getInstance (  ) , new FilterCreaturePermanent (  )  )  ) ; } public RadiantFlames ( final RadiantFlames card )  { super ( card ) ; } @Override public RadiantFlames copy (  )  { return new RadiantFlames ( this ) ; } } 
public class RecklessCohort extends CardImpl { private final static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another Ally" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new SubtypePredicate ( "Ally" )  ) ; } public RecklessCohort ( UUID ownerId )  { super ( ownerId, 152, "Reckless Cohort", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Effect effect = new ConditionalRequirementEffect (  new AttacksIfAbleSourceEffect ( Duration . WhileOnBattlefield, true ) , new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . FEWER_THAN, 1 )  ) ; effect . setText ( "{this} attacks each combat if able unless you control another Ally" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public RecklessCohort ( final RecklessCohort card )  { super ( card ) ; } @Override public RecklessCohort copy (  )  { return new RecklessCohort ( this ) ; } } 
public class ReclaimingVines extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "artifact, enchantment, or land" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . ARTIFACT ) , new CardTypePredicate ( CardType . ENCHANTMENT ) , new CardTypePredicate ( CardType . LAND )  )  ) ; } public ReclaimingVines ( UUID ownerId )  { super ( ownerId, 185, "Reclaiming Vines", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{G}{G}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; } public ReclaimingVines ( final ReclaimingVines card )  { super ( card ) ; } @Override public ReclaimingVines copy (  )  { return new ReclaimingVines ( this ) ; } } 
public class ResoluteBlademaster extends CardImpl { public ResoluteBlademaster ( UUID ownerId )  { super ( ownerId, 218, "Resolute Blademaster", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new AllyEntersBattlefieldTriggeredAbility (  new GainAbilityAllEffect ( DoubleStrikeAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "creatures you control" )  ) , false ) ; this . addAbility ( ability ) ; } public ResoluteBlademaster ( final ResoluteBlademaster card )  { super ( card ) ; } @Override public ResoluteBlademaster copy (  )  { return new ResoluteBlademaster ( this ) ; } } 
public class RetreatToCoralhelm extends CardImpl { public RetreatToCoralhelm ( UUID ownerId )  { super ( ownerId, 82, "Retreat to Coralhelm", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{U}" ) ; this . expansionSetCode = "BFZ"; LandfallAbility ability = new LandfallAbility ( new MayTapOrUntapTargetEffect (  ) , false ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new ScryEffect ( 1 )  ) ; ability . addMode ( mode ) ; this . addAbility ( ability ) ; } public RetreatToCoralhelm ( final RetreatToCoralhelm card )  { super ( card ) ; } @Override public RetreatToCoralhelm copy (  )  { return new RetreatToCoralhelm ( this ) ; } } 
public class RetreatToEmeria extends CardImpl { public RetreatToEmeria ( UUID ownerId )  { super ( ownerId, 44, "Retreat to Emeria", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}" ) ; this . expansionSetCode = "BFZ"; LandfallAbility ability = new LandfallAbility ( new CreateTokenEffect ( new KorAllyToken (  )  ) , false ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new BoostControlledEffect ( 1, 1, Duration . EndOfTurn )  ) ; ability . addMode ( mode ) ; this . addAbility ( ability ) ; } public RetreatToEmeria ( final RetreatToEmeria card )  { super ( card ) ; } @Override public RetreatToEmeria copy (  )  { return new RetreatToEmeria ( this ) ; } } class KorAllyToken extends Token { public KorAllyToken (  )  { super ( "Kor Ally", "1/1 white Kor Ally creature token" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Kor" ) ; subtype . add ( "Ally" ) ; color . setWhite ( true ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; } } 
public class RetreatToHagra extends CardImpl { public RetreatToHagra ( UUID ownerId )  { super ( ownerId, 121, "Retreat to Hagra", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; LandfallAbility ability = new LandfallAbility ( new BoostTargetEffect ( 1, 0, Duration . EndOfTurn ) , false ) ; ability . addEffect ( new GainAbilityTargetEffect ( DeathtouchAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new LoseLifeOpponentsEffect ( 1 )  ) ; Effect effect = new GainLifeEffect ( 1 ) ; effect . setText ( "and you gain 1 life" ) ; mode . getEffects (  )  . add ( effect ) ; ability . addMode ( mode ) ; this . addAbility ( ability ) ; } public RetreatToHagra ( final RetreatToHagra card )  { super ( card ) ; } @Override public RetreatToHagra copy (  )  { return new RetreatToHagra ( this ) ; } } 
public class RoilmagesTrick extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public RoilmagesTrick ( UUID ownerId )  { super ( ownerId, 83, "Roilmage's Trick", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . setAbilityWord ( AbilityWord . CONVERGE ) ; this . getSpellAbility (  )  . addEffect ( new BoostAllEffect (  new SignInversionDynamicValue ( ColorsOfManaSpentToCastCount . getInstance (  )  ) , new StaticValue ( -0 ) , Duration . EndOfTurn, filter, false, "Creatures your opponents control get -X/-0 until end of turn, where X is the number of colors of mana spent to cast {this} . <br>", true )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public RoilmagesTrick ( final RoilmagesTrick card )  { super ( card ) ; } @Override public RoilmagesTrick copy (  )  { return new RoilmagesTrick ( this ) ; } } 
public class RoilSpout extends CardImpl { public RoilSpout ( UUID ownerId )  { super ( ownerId, 219, "Roil Spout", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{W}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new AwakenAbility ( this, 4, "{4}{W}{U}" )  ) ; } public RoilSpout ( final RoilSpout card )  { super ( card ) ; } @Override public RoilSpout copy (  )  { return new RoilSpout ( this ) ; } } 
public class RoilsRetribution extends CardImpl { public RoilsRetribution ( UUID ownerId )  { super ( ownerId, 45, "Roil's Retribution", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{W}{W}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DamageMultiEffect ( 5 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanentAmount ( 5, new FilterAttackingOrBlockingCreature ( "attacking or blocking creatures" )  )  ) ; } public RoilsRetribution ( final RoilsRetribution card )  { super ( card ) ; } @Override public RoilsRetribution copy (  )  { return new RoilsRetribution ( this ) ; } } 
public class RotShambler extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public RotShambler ( UUID ownerId )  { super ( ownerId, 187, "Rot Shambler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Fungus" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false, filter )  ) ; } public RotShambler ( final RotShambler card )  { super ( card ) ; } @Override public RotShambler copy (  )  { return new RotShambler ( this ) ; } } 
public class RuinationGuide extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Other colorless creatures you control" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public RuinationGuide ( UUID ownerId )  { super ( ownerId, 64, "Ruination Guide", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new IngestAbility (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1, 0, Duration . WhileOnBattlefield, filter, true )  )  ) ; } public RuinationGuide ( final RuinationGuide card )  { super ( card ) ; } @Override public RuinationGuide copy (  )  { return new RuinationGuide ( this ) ; } } 
public class RuinousPath extends CardImpl { public RuinousPath ( UUID ownerId )  { super ( ownerId, 123, "Ruinous Path", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{1}{B}{B}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlaneswalker (  )  ) ; this . addAbility ( new AwakenAbility ( this, 4, "{5}{B}{B}" )  ) ; } public RuinousPath ( final RuinousPath card )  { super ( card ) ; } @Override public RuinousPath copy (  )  { return new RuinousPath ( this ) ; } } 
public class RuinProcessor extends CardImpl { public RuinProcessor ( UUID ownerId )  { super ( ownerId, 12, "Ruin Processor", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{7}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 8 ) ; this . addAbility ( new CastSourceTriggeredAbility (  new DoIfCostPaid ( new GainLifeEffect ( 5 ) , new ExileOpponentsCardFromExileToGraveyardCost ( true )  ) , false )  ) ; } public RuinProcessor ( final RuinProcessor card )  { super ( card ) ; } @Override public RuinProcessor copy (  )  { return new RuinProcessor ( this ) ; } } 
public class RushOfIce extends CardImpl { public RushOfIce ( UUID ownerId )  { super ( ownerId, 84, "Rush of Ice", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new TapTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DontUntapInControllersNextUntapStepTargetEffect ( "It" )  ) ; this . addAbility ( new AwakenAbility ( this, 3, "{4}{U}" )  ) ; } public RushOfIce ( final RushOfIce card )  { super ( card ) ; } @Override public RushOfIce copy (  )  { return new RushOfIce ( this ) ; } } 
public class SalvageDrone extends CardImpl { public SalvageDrone ( UUID ownerId )  { super ( ownerId, 65, "Salvage Drone", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new IngestAbility (  )  ) ; this . addAbility ( new DiesTriggeredAbility ( new DrawDiscardControllerEffect ( 1, 1, true ) , false )  ) ; } public SalvageDrone ( final SalvageDrone card )  { super ( card ) ; } @Override public SalvageDrone copy (  )  { return new SalvageDrone ( this ) ; } } 
public class SanctumOfUgin extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "colorless creature card" ) ; private static final FilterSpell filterSpells = new FilterSpell ( "colorless spell with converted mana cost 7 or greater" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; filterSpells . add ( new ColorlessPredicate (  )  ) ; filterSpells . add ( new ConvertedManaCostPredicate ( ComparisonType . GreaterThan, 6 )  ) ; } public SanctumOfUgin ( UUID ownerId )  { super ( ownerId, 242, "Sanctum of Ugin", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Effect effect = new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( filter ) , true ) ; effect . setText ( "search your library for a colorless creature card, reveal it, put it into your hand, then shuffle your library" ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new DoIfCostPaid ( effect, new SacrificeSourceCost (  )  ) , filterSpells, false )  ) ; } public SanctumOfUgin ( final SanctumOfUgin card )  { super ( card ) ; } @Override public SanctumOfUgin copy (  )  { return new SanctumOfUgin ( this ) ; } } 
public class SandstoneBridge extends CardImpl { public SandstoneBridge ( UUID ownerId )  { super ( ownerId, 243, "Sandstone Bridge", Rarity . COMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; Effect effect = new GainAbilityTargetEffect ( VigilanceAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains vigilance" ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new BoostTargetEffect ( 1, 1, Duration . EndOfTurn ) , false ) ; ability . addEffect ( effect ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new WhiteManaAbility (  )  ) ; } public SandstoneBridge ( final SandstoneBridge card )  { super ( card ) ; } @Override public SandstoneBridge copy (  )  { return new SandstoneBridge ( this ) ; } } 
public class ScatterToTheWinds extends CardImpl { public ScatterToTheWinds ( UUID ownerId )  { super ( ownerId, 85, "Scatter to the Winds", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{1}{U}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell (  )  ) ; this . addAbility ( new AwakenAbility ( this, 3, "{4}{U}{U}" )  ) ; } public ScatterToTheWinds ( final ScatterToTheWinds card )  { super ( card ) ; } @Override public ScatterToTheWinds copy (  )  { return new ScatterToTheWinds ( this ) ; } } 
public class ScourFromExistence extends CardImpl { public ScourFromExistence ( UUID ownerId )  { super ( ownerId, 13, "Scour from Existence", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{7}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new ExileTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; } public ScourFromExistence ( final ScourFromExistence card )  { super ( card ) ; } @Override public ScourFromExistence copy (  )  { return new ScourFromExistence ( this ) ; } } 
public class ScytheLeopard extends CardImpl { public ScytheLeopard ( UUID ownerId )  { super ( ownerId, 188, "Scythe Leopard", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Cat" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new LandfallAbility ( new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , false )  ) ; } public ScytheLeopard ( final ScytheLeopard card )  { super ( card ) ; } @Override public ScytheLeopard copy (  )  { return new ScytheLeopard ( this ) ; } } 
public class SeekTheWilds extends CardImpl { private static final FilterCard filter = new FilterCard ( "a creature or land card" ) ; static { filter . add ( Predicates . or ( new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . LAND )  )  ) ; } public SeekTheWilds ( UUID ownerId )  { super ( ownerId, 189, "Seek the Wilds", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{G}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new LookLibraryAndPickControllerEffect ( new StaticValue ( 4 ) , false, new StaticValue ( 1 ) , filter, false )  ) ; } public SeekTheWilds ( final SeekTheWilds card )  { super ( card ) ; } @Override public SeekTheWilds copy (  )  { return new SeekTheWilds ( this ) ; } } 
public class SereneSteward extends CardImpl { public SereneSteward ( UUID ownerId )  { super ( ownerId, 46, "Serene Steward", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new GainLifeControllerTriggeredAbility (  new DoIfCostPaid ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance (  )  ) , new ManaCostsImpl ( "{W}" )  ) , false ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public SereneSteward ( final SereneSteward card )  { super ( card ) ; } @Override public SereneSteward copy (  )  { return new SereneSteward ( this ) ; } } 
public class SerpentineSpike extends CardImpl { public SerpentineSpike ( UUID ownerId )  { super ( ownerId, 133, "Serpentine Spike", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{5}{R}{R}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new SerpentineSpikeEffect (  )  ) ; TargetCreaturePermanent target = new TargetCreaturePermanent ( new FilterCreaturePermanent ( "creature  ( 2 damage ) " )  ) ; target . setTargetTag ( 1 ) ; this . getSpellAbility (  )  . addTarget ( target ) ; FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another target creature  ( 3 damage ) " ) ; filter . add ( new AnotherTargetPredicate ( 2 )  ) ; target = new TargetCreaturePermanent ( filter ) ; target . setTargetTag ( 2 ) ; this . getSpellAbility (  )  . addTarget ( target ) ; filter = new FilterCreaturePermanent ( "another target creature  ( 4 damage ) " ) ; filter . add ( new AnotherTargetPredicate ( 3 )  ) ; target = new TargetCreaturePermanent ( filter ) ; target . setTargetTag ( 3 ) ; this . getSpellAbility (  )  . addTarget ( target ) ; Effect effect = new DealtDamageToCreatureBySourceDies ( this, Duration . EndOfTurn ) ; effect . setText ( "If a creature dealt damage this way would die this turn, exile it instead" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addWatcher ( new DamagedByWatcher (  )  ) ; } public SerpentineSpike ( final SerpentineSpike card )  { super ( card ) ; } @Override public SerpentineSpike copy (  )  { return new SerpentineSpike ( this ) ; } } class SerpentineSpikeEffect extends OneShotEffect { public SerpentineSpikeEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "{this} deals 2 damage to target creature, 3 damage to another target creature, and 4 damage to a third target creature"; } public SerpentineSpikeEffect ( final SerpentineSpikeEffect effect )  { super ( effect ) ; } @Override public SerpentineSpikeEffect copy (  )  { return new SerpentineSpikeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getTargets (  )  . get ( 0 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . damage ( 2, source . getSourceId (  ) , game, false, true ) ; } permanent = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . damage ( 3, source . getSourceId (  ) , game, false, true ) ; } permanent = game . getPermanent ( source . getTargets (  )  . get ( 2 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . damage ( 4, source . getSourceId (  ) , game, false, true ) ; } return true; } } 
public class ShadowGlider extends CardImpl { public ShadowGlider ( UUID ownerId )  { super ( ownerId, 47, "Shadow Glider", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } public ShadowGlider ( final ShadowGlider card )  { super ( card ) ; } @Override public ShadowGlider copy (  )  { return new ShadowGlider ( this ) ; } } 
public class ShrineOfTheForsakenGods extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "colorless spells" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public ShrineOfTheForsakenGods ( UUID ownerId )  { super ( ownerId, 245, "Shrine of the Forsaken Gods", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; this . addAbility ( new ActivateIfConditionManaAbility (  Zone . BATTLEFIELD, new AddConditionalColorlessManaEffect ( 2, new ConditionalSpellManaBuilder ( filter )  ) , new TapSourceCost (  ) , new PermanentsOnTheBattlefieldCondition ( new FilterControlledLandPermanent ( "you control seven or more lands" ) , PermanentsOnTheBattlefieldCondition . CountType . MORE_THAN, 6 )  )  ) ; } public ShrineOfTheForsakenGods ( final ShrineOfTheForsakenGods card )  { super ( card ) ; } @Override public ShrineOfTheForsakenGods copy (  )  { return new ShrineOfTheForsakenGods ( this ) ; } } 
public class SilentSkimmer extends CardImpl { public SilentSkimmer ( UUID ownerId )  { super ( ownerId, 96, "Silent Skimmer", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new AttacksTriggeredAbility ( new LoseLifeTargetEffect ( 2 ) , false, "Whenever {this} attacks, defending player loses 2 life", SetTargetPointer . PLAYER )  ) ; } public SilentSkimmer ( final SilentSkimmer card )  { super ( card ) ; } @Override public SilentSkimmer copy (  )  { return new SilentSkimmer ( this ) ; } } 
public class SireOfStagnation extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; private static final String rule = "Whenever a land enters the battlefield under an opponent's control, that player exiles the top two cards of his or her library and you draw two cards . "; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public SireOfStagnation ( UUID ownerId )  { super ( ownerId, 206, "Sire of Stagnation", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{U}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Ability ability = new EntersBattlefieldAllTriggeredAbility ( Zone . BATTLEFIELD, new ExileCardsFromTopOfLibraryTargetEffect ( 2, "that player" ) , filter, false, SetTargetPointer . PLAYER, rule, false ) ; ability . addEffect ( new DrawCardSourceControllerEffect ( 2 )  ) ; this . addAbility ( ability ) ; } public SireOfStagnation ( final SireOfStagnation card )  { super ( card ) ; } @Override public SireOfStagnation copy (  )  { return new SireOfStagnation ( this ) ; } } 
public class Skitterskin extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "you control another colorless creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new ColorlessPredicate (  )  ) ; } public Skitterskin ( UUID ownerId )  { super ( ownerId, 97, "Skitterskin", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new CantBlockAbility (  )  ) ; Ability ability = new ActivateIfConditionActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{1}{B}" ) , new PermanentsOnTheBattlefieldCondition ( filter )  ) ; this . addAbility ( ability ) ; } public Skitterskin ( final Skitterskin card )  { super ( card ) ; } @Override public Skitterskin copy (  )  { return new Skitterskin ( this ) ; } } 
public class SkylineCascade extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature an opponent controls" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public SkylineCascade ( UUID ownerId )  { super ( ownerId, 246, "Skyline Cascade", Rarity . COMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DontUntapInControllersNextUntapStepTargetEffect (  ) , false ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; this . addAbility ( new BlueManaAbility (  )  ) ; } public SkylineCascade ( final SkylineCascade card )  { super ( card ) ; } @Override public SkylineCascade copy (  )  { return new SkylineCascade ( this ) ; } } 
public class SkyriderElf extends CardImpl { public SkyriderElf ( UUID ownerId )  { super ( ownerId, 220, "Skyrider Elf", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{X}{G}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Warrior" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  ) , ColorsOfManaSpentToCastCount . getInstance (  ) , true ) , null, "<i>Converge</i> &mdash; {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it . ", null )  ) ; } public SkyriderElf ( final SkyriderElf card )  { super ( card ) ; } @Override public SkyriderElf copy (  )  { return new SkyriderElf ( this ) ; } } 
public class SlabHammer extends CardImpl { public SlabHammer ( UUID ownerId )  { super ( ownerId, 227, "Slab Hammer", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Equipment" ) ; Ability ability = new AttacksAttachedTriggeredAbility (  new DoIfCostPaid ( new BoostEquippedEffect ( 2, 2, Duration . EndOfTurn ) , new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( new FilterControlledLandPermanent (  )  )  ) , "Return a land you control to its owner's hand?  ( giving +2/+2 to the equipped creature ) " )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 )  )  ) ; } public SlabHammer ( final SlabHammer card )  { super ( card ) ; } @Override public SlabHammer copy (  )  { return new SlabHammer ( this ) ; } } 
public class SludgeCrawler extends CardImpl { public SludgeCrawler ( UUID ownerId )  { super ( ownerId, 98, "Sludge Crawler", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . addAbility ( new IngestAbility (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , new GenericManaCost ( 2 )  )  ) ; } public SludgeCrawler ( final SludgeCrawler card )  { super ( card ) ; } @Override public SludgeCrawler copy (  )  { return new SludgeCrawler ( this ) ; } } 
public class SmolderingMarsh extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public SmolderingMarsh ( UUID ownerId )  { super ( ownerId, 247, "Smoldering Marsh", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Swamp" ) ; this . subtype . add ( "Mountain" ) ; Condition controls = new InvertCondition ( new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . MORE_THAN, 1 )  ) ; String abilityText = "tapped unless you control two or more basic lands"; this . addAbility ( new EntersBattlefieldAbility ( new ConditionalOneShotEffect ( new TapSourceEffect (  ) , controls, abilityText ) , abilityText )  ) ; this . addAbility ( new BlackManaAbility (  )  ) ; this . addAbility ( new RedManaAbility (  )  ) ; } public SmolderingMarsh ( final SmolderingMarsh card )  { super ( card ) ; } @Override public SmolderingMarsh copy (  )  { return new SmolderingMarsh ( this ) ; } } 
public class SmotheringAbomination extends CardImpl { public SmotheringAbomination ( UUID ownerId )  { super ( ownerId, 99, "Smothering Abomination", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new SacrificeControllerEffect (  new FilterCreaturePermanent (  ) , 1, null ) , TargetController . YOU, false )  ) ; this . addAbility ( new SmotheringAbominationTriggeredAbility (  )  ) ; } public SmotheringAbomination ( final SmotheringAbomination card )  { super ( card ) ; } @Override public SmotheringAbomination copy (  )  { return new SmotheringAbomination ( this ) ; } } class SmotheringAbominationTriggeredAbility extends TriggeredAbilityImpl { public SmotheringAbominationTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 )  ) ; setLeavesTheBattlefieldTrigger ( true ) ; } public SmotheringAbominationTriggeredAbility ( final SmotheringAbominationTriggeredAbility ability )  { super ( ability ) ; } @Override public SmotheringAbominationTriggeredAbility copy (  )  { return new SmotheringAbominationTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SACRIFICED_PERMANENT; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { return event . getPlayerId (  )  . equals ( this . getControllerId (  )  )  && game . getLastKnownInformation ( event . getTargetId (  ) , Zone . BATTLEFIELD )  . getCardType (  )  . contains ( CardType . CREATURE ) ; } @Override public String getRule (  )  { return "Whenever you sacrifice a creature, " + super . getRule (  ) ; } } 
public class SnappingGnarlid extends CardImpl { public SnappingGnarlid ( UUID ownerId )  { super ( ownerId, 190, "Snapping Gnarlid", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new LandfallAbility ( new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , false )  ) ; } public SnappingGnarlid ( final SnappingGnarlid card )  { super ( card ) ; } @Override public SnappingGnarlid copy (  )  { return new SnappingGnarlid ( this ) ; } } 
public class SpawningBed extends CardImpl { public SpawningBed ( UUID ownerId )  { super ( ownerId, 248, "Spawning Bed", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new EldraziScionToken (  ) , 3 ) , new ManaCostsImpl ( "{6}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public SpawningBed ( final SpawningBed card )  { super ( card ) ; } @Override public SpawningBed copy (  )  { return new SpawningBed ( this ) ; } } 
public class SpellShrivel extends CardImpl { public SpellShrivel ( UUID ownerId )  { super ( ownerId, 66, "Spell Shrivel", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new SpellShrivelCounterUnlessPaysEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell (  )  ) ; } public SpellShrivel ( final SpellShrivel card )  { super ( card ) ; } @Override public SpellShrivel copy (  )  { return new SpellShrivel ( this ) ; } } class SpellShrivelCounterUnlessPaysEffect extends OneShotEffect { public SpellShrivelCounterUnlessPaysEffect (  )  { super ( Outcome . Detriment ) ; } public SpellShrivelCounterUnlessPaysEffect ( final SpellShrivelCounterUnlessPaysEffect effect )  { super ( effect ) ; } @Override public SpellShrivelCounterUnlessPaysEffect copy (  )  { return new SpellShrivelCounterUnlessPaysEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { StackObject spell = game . getStack (  )  . getStackObject ( targetPointer . getFirst ( game, source )  ) ; MageObject sourceObject = source . getSourceObject ( game ) ; if  ( spell != null &&  ( spell instanceof Spell )  && sourceObject != null )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { int amount = 4; if  ( amount > 0 )  { GenericManaCost cost = new GenericManaCost ( amount ) ; if  ( !cost . pay ( source, game, spell . getControllerId (  ) , spell . getControllerId (  ) , false )  )  { StackObject stackObject = game . getStack (  )  . getStackObject ( source . getFirstTarget (  )  ) ; if  ( stackObject != null && !game . replaceEvent ( GameEvent . getEvent ( GameEvent . EventType . COUNTER, source . getFirstTarget (  ) , source . getSourceId (  ) , stackObject . getControllerId (  )  )  )  )  { game . informPlayers ( sourceObject . getIdName (  )  + ": cost wasn't payed - countering " + stackObject . getName (  )  ) ; game . rememberLKI ( source . getFirstTarget (  ) , Zone . STACK,  ( Spell )  stackObject ) ; controller . moveCards (  ( Spell )  spell, null, Zone . EXILED, source, game ) ; game . fireEvent ( GameEvent . getEvent ( GameEvent . EventType . COUNTERED, source . getFirstTarget (  ) , source . getSourceId (  ) , stackObject . getControllerId (  )  )  ) ; return true; } return false; } } } } return false; } @Override public String getText ( Mode mode )  { return "Counter target spell unless its controller pays {4} .  If that spell is countered this way, exile it instead of putting it into its owner's graveyard"; } } 
public class StasisSnare extends CardImpl { private final static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature an opponent controls" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public StasisSnare ( UUID ownerId )  { super ( ownerId, 50, "Stasis Snare", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{W}" ) ; this . expansionSetCode = "BFZ"; this . addAbility ( FlashAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new StasisSnareExileEffect (  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; ability . addEffect ( new CreateDelayedTriggeredAbilityEffect ( new OnLeaveReturnExiledToBattlefieldAbility (  )  )  ) ; this . addAbility ( ability ) ; } public StasisSnare ( final StasisSnare card )  { super ( card ) ; } @Override public StasisSnare copy (  )  { return new StasisSnare ( this ) ; } } class StasisSnareExileEffect extends OneShotEffect { public StasisSnareExileEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "exile target creature an opponent controls until {this} leaves the battlefield"; } public StasisSnareExileEffect ( final StasisSnareExileEffect effect )  { super ( effect ) ; } @Override public StasisSnareExileEffect copy (  )  { return new StasisSnareExileEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { return new ExileTargetEffect ( CardUtil . getCardExileZoneId ( game, source ) , permanent . getIdName (  )  )  . apply ( game, source ) ; } return false; } } 
public class Stonefury extends CardImpl { public Stonefury ( UUID ownerId )  { super ( ownerId, 156, "Stonefury", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{R}{R}" ) ; this . expansionSetCode = "BFZ"; Effect effect = new DamageTargetEffect ( new PermanentsOnBattlefieldCount ( new FilterControlledLandPermanent ( "the number of lands you control" )  )  ) ; effect . setText ( "{this} deals damage to target creature equal to the number of lands you control" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public Stonefury ( final Stonefury card )  { super ( card ) ; } @Override public Stonefury copy (  )  { return new Stonefury ( this ) ; } } 
public class StoneHavenMedic extends CardImpl { public StoneHavenMedic ( UUID ownerId )  { super ( ownerId, 51, "Stone Haven Medic", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Kor" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 1 ) , new ManaCostsImpl ( "{W}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public StoneHavenMedic ( final StoneHavenMedic card )  { super ( card ) ; } @Override public StoneHavenMedic copy (  )  { return new StoneHavenMedic ( this ) ; } } 
public class SunkenHollow extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public SunkenHollow ( UUID ownerId )  { super ( ownerId, 249, "Sunken Hollow", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Island" ) ; this . subtype . add ( "Swamp" ) ; Condition controls = new InvertCondition ( new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . MORE_THAN, 1 )  ) ; String abilityText = "tapped unless you control two or more basic lands"; this . addAbility ( new EntersBattlefieldAbility ( new ConditionalOneShotEffect ( new TapSourceEffect (  ) , controls, abilityText ) , abilityText )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public SunkenHollow ( final SunkenHollow card )  { super ( card ) ; } @Override public SunkenHollow copy (  )  { return new SunkenHollow ( this ) ; } } 
public class SureStrike extends CardImpl { public SureStrike ( UUID ownerId )  { super ( ownerId, 157, "Sure Strike", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new BoostTargetEffect ( 3, 0, Duration . EndOfTurn ) ; effect . setText ( "Target creature gets +3/+0" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; effect = new GainAbilityTargetEffect ( FirstStrikeAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains first strike until end of turn" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public SureStrike ( final SureStrike card )  { super ( card ) ; } @Override public SureStrike copy (  )  { return new SureStrike ( this ) ; } } 
public class TajuruBeastmaster extends CardImpl { public TajuruBeastmaster ( UUID ownerId )  { super ( ownerId, 193, "Tajuru Beastmaster", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Warrior" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility ( new BoostControlledEffect ( 1, 1, Duration . EndOfTurn ) , false )  ) ; } public TajuruBeastmaster ( final TajuruBeastmaster card )  { super ( card ) ; } @Override public TajuruBeastmaster copy (  )  { return new TajuruBeastmaster ( this ) ; } } 
public class TajuruStalwart extends CardImpl { public TajuruStalwart ( UUID ownerId )  { super ( ownerId, 194, "Tajuru Stalwart", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Scout" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  ) , ColorsOfManaSpentToCastCount . getInstance (  ) , true ) , null, "<i>Converge</i> - {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it . ", null )  ) ; } public TajuruStalwart ( final TajuruStalwart card )  { super ( card ) ; } @Override public TajuruStalwart copy (  )  { return new TajuruStalwart ( this ) ; } } 
public class TajuruWarcaller extends CardImpl { public TajuruWarcaller ( UUID ownerId )  { super ( ownerId, 195, "Tajuru Warcaller", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Warrior" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new AllyEntersBattlefieldTriggeredAbility ( new BoostControlledEffect ( 2, 2, Duration . EndOfTurn ) , false )  ) ; } public TajuruWarcaller ( final TajuruWarcaller card )  { super ( card ) ; } @Override public TajuruWarcaller copy (  )  { return new TajuruWarcaller ( this ) ; } } 
public class TandemTactics extends CardImpl { public TandemTactics ( UUID ownerId )  { super ( ownerId, 52, "Tandem Tactics", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{W}" ) ; this . expansionSetCode = "BFZ"; Effect effect = new BoostTargetEffect ( 1, 2, Duration . EndOfTurn ) ; effect . setText ( "Up to two target creatures each get +1/+2 until end of turn" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 2 )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 2 )  ) ; } public TandemTactics ( final TandemTactics card )  { super ( card ) ; } @Override public TandemTactics copy (  )  { return new TandemTactics ( this ) ; } } 
public class TideDrifter extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "colorless creatures" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public TideDrifter ( UUID ownerId )  { super ( ownerId, 67, "Tide Drifter", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 0, 1, Duration . WhileOnBattlefield, filter, true )  )  ) ; } public TideDrifter ( final TideDrifter card )  { super ( card ) ; } @Override public TideDrifter copy (  )  { return new TideDrifter ( this ) ; } } 
public class TighteningCoils extends CardImpl { public TighteningCoils ( UUID ownerId )  { super ( ownerId, 86, "Tightening Coils", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( -6, 0, Duration . WhileOnBattlefield )  ) ; Effect effect = new LoseAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( "and loses flying" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public TighteningCoils ( final TighteningCoils card )  { super ( card ) ; } @Override public TighteningCoils copy (  )  { return new TighteningCoils ( this ) ; } } 
public class TitansPresence extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "a colorless creature card from your hand" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public TitansPresence ( UUID ownerId )  { super ( ownerId, 14, "Titan's Presence", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addCost ( new RevealTargetFromHandCost ( new TargetCardInHand ( filter )  )  ) ; this . getSpellAbility (  )  . addEffect ( new TitansPresenceEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public TitansPresence ( final TitansPresence card )  { super ( card ) ; } @Override public TitansPresence copy (  )  { return new TitansPresence ( this ) ; } } class TitansPresenceEffect extends OneShotEffect { public TitansPresenceEffect (  )  { super ( Outcome . Exile ) ; staticText = "Exile target creature if its power is less than or equal to the revealed card's power"; } public TitansPresenceEffect ( TitansPresenceEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { RevealTargetFromHandCost cost =  ( RevealTargetFromHandCost )  source . getCosts (  )  . get ( 0 ) ; Permanent creature = game . getPermanent ( getTargetPointer (  )  . getFirst ( game, source )  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( cost != null && creature != null && controller != null )  { List<Card> revealedCards = cost . getRevealedCards (  ) ; if  ( !revealedCards . isEmpty (  )  )  { Card card = revealedCards . iterator (  )  . next (  ) ; if  ( card != null && card . getPower (  )  . getValue (  )  >= creature . getPower (  )  . getValue (  )  )  { controller . moveCards ( creature, null, Zone . EXILED, source, game ) ; } } return true; } return false; } @Override public TitansPresenceEffect copy (  )  { return new TitansPresenceEffect ( this ) ; } } 
public class TouchOfTheVoid extends CardImpl { public TouchOfTheVoid ( UUID ownerId )  { super ( ownerId, 134, "Touch of the Void", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 3 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; Effect effect = new DealtDamageToCreatureBySourceDies ( this, Duration . EndOfTurn ) ; effect . setText ( "If a creature dealt damage this way would die this turn, exile it instead" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addWatcher ( new DamagedByWatcher (  )  ) ; } public TouchOfTheVoid ( final TouchOfTheVoid card )  { super ( card ) ; } @Override public TouchOfTheVoid copy (  )  { return new TouchOfTheVoid ( this ) ; } } 
public class TransgressTheMind extends CardImpl { private static final FilterCard filter = new FilterCard ( "a card from it with converted mana cost 3 or greater" ) ; static { filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . GreaterThan, 2 )  ) ; } public TransgressTheMind ( UUID ownerId )  { super ( ownerId, 101, "Transgress the Mind", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{B}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; Effect effect = new ExileCardYouChooseTargetOpponentEffect ( filter ) ; effect . setText ( "Target player reveals his or her hand .  You may choose a card from it with converted mana cost 3 or greater and exile that card" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public TransgressTheMind ( final TransgressTheMind card )  { super ( card ) ; } @Override public TransgressTheMind copy (  )  { return new TransgressTheMind ( this ) ; } } 
public class TunnelingGeopede extends CardImpl { public TunnelingGeopede ( UUID ownerId )  { super ( ownerId, 158, "Tunneling Geopede", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Insect" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new LandfallAbility ( new DamagePlayersEffect ( 1, TargetController . OPPONENT ) , false )  ) ; } public TunnelingGeopede ( final TunnelingGeopede card )  { super ( card ) ; } @Override public TunnelingGeopede copy (  )  { return new TunnelingGeopede ( this ) ; } } 
public class TurnAgainst extends CardImpl { public TurnAgainst ( UUID ownerId )  { super ( ownerId, 135, "Turn Against", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{R}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new DevoidAbility ( this . color ) ; ability . setRuleAtTheTop ( true ) ; this . addAbility ( ability ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainControlTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new UntapTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; } public TurnAgainst ( final TurnAgainst card )  { super ( card ) ; } @Override public TurnAgainst copy (  )  { return new TurnAgainst ( this ) ; } } 
public class UginsInsight extends CardImpl { public UginsInsight ( UUID ownerId )  { super ( ownerId, 87, "Ugin's Insight", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}{U}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new UginsInsightEffect (  )  ) ; } public UginsInsight ( final UginsInsight card )  { super ( card ) ; } @Override public UginsInsight copy (  )  { return new UginsInsight ( this ) ; } } class UginsInsightEffect extends OneShotEffect { public UginsInsightEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Scry X, where X is the highest converted mana cost among permanents you control, then draw three cards"; } public UginsInsightEffect ( final UginsInsightEffect effect )  { super ( effect ) ; } @Override public UginsInsightEffect copy (  )  { return new UginsInsightEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { int highCMC = new HighestConvertedManaCostValue (  )  . calculate ( game, source, this ) ; if  ( highCMC > 0 )  { controller . scry ( highCMC, source, game ) ; } controller . drawCards ( 3, game ) ; return true; } return false; } } 
public class UlamogsDespoiler extends CardImpl { public UlamogsDespoiler ( UUID ownerId )  { super ( ownerId, 16, "Ulamog's Despoiler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{6}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new EntersBattlefieldAbility ( new UlamogsDespoilerEffect (  ) , null, "As {this} enters the battlefield, you may put two cards your opponents own from exile into their owners' graveyards .  If you do, {this} enters the battlefield with four +1/+1 counters on it", null )  ) ; } public UlamogsDespoiler ( final UlamogsDespoiler card )  { super ( card ) ; } @Override public UlamogsDespoiler copy (  )  { return new UlamogsDespoiler ( this ) ; } } class UlamogsDespoilerEffect extends OneShotEffect { private final static FilterCard filter = new FilterCard ( "cards your opponents own from exile" ) ; static { filter . add ( new OwnerPredicate ( TargetController . OPPONENT )  ) ; } public UlamogsDespoilerEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "you may put two cards your opponents own from exile into their owners' graveyards .  If you do, {this} enters the battlefield with four +1/+1 counters on it"; } public UlamogsDespoilerEffect ( final UlamogsDespoilerEffect effect )  { super ( effect ) ; } @Override public UlamogsDespoilerEffect copy (  )  { return new UlamogsDespoilerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Target target = new TargetCardInExile ( 2, 2, filter, null ) ; if  ( target . canChoose ( source . getSourceId (  ) , source . getControllerId (  ) , game )  )  { if  ( controller . chooseTarget ( outcome, target, source, game )  )  { Cards cardsToGraveyard = new CardsImpl ( target . getTargets (  )  ) ; controller . moveCards ( cardsToGraveyard, null, Zone . GRAVEYARD, source, game ) ; return new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 4 )  )  . apply ( game, source ) ; } } return true; } return false; } } 
public class UlamogsNullifier extends CardImpl { public UlamogsNullifier ( UUID ownerId )  { super ( ownerId, 207, "Ulamog's Nullifier", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new UlamogsNullifierEffect (  ) , true ) ; ability . addTarget ( new TargetSpell (  )  ) ; this . addAbility ( ability ) ; } public UlamogsNullifier ( final UlamogsNullifier card )  { super ( card ) ; } @Override public UlamogsNullifier copy (  )  { return new UlamogsNullifier ( this ) ; } } class UlamogsNullifierEffect extends OneShotEffect { private final static FilterCard filter = new FilterCard ( "cards your opponents own from exile" ) ; static { filter . add ( new OwnerPredicate ( TargetController . OPPONENT )  ) ; } public UlamogsNullifierEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "you may put two cards your opponents own from exile into their owners' graveyards .  If you do, counter target spell . "; } public UlamogsNullifierEffect ( final UlamogsNullifierEffect effect )  { super ( effect ) ; } @Override public UlamogsNullifierEffect copy (  )  { return new UlamogsNullifierEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Spell spell = game . getStack (  )  . getSpell ( source . getFirstTarget (  )  ) ; if  ( controller != null && spell != null )  { Target target = new TargetCardInExile ( 2, 2, filter, null ) ; if  ( target . canChoose ( source . getSourceId (  ) , source . getControllerId (  ) , game )  )  { if  ( controller . chooseTarget ( outcome, target, source, game )  )  { Cards cardsToGraveyard = new CardsImpl ( target . getTargets (  )  ) ; controller . moveCards ( cardsToGraveyard, null, Zone . GRAVEYARD, source, game ) ; game . getStack (  )  . counter ( source . getFirstTarget (  ) , source . getSourceId (  ) , game ) ; return true; } } } return false; } } 
public class UlamogsReclaimer extends CardImpl { public UlamogsReclaimer ( UUID ownerId )  { super ( ownerId, 68, "Ulamog's Reclaimer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility (  new DoIfCostPaid ( new ReturnFromGraveyardToHandTargetEffect (  ) , new ExileOpponentsCardFromExileToGraveyardCost ( true )  ) , false ) ; ability . addTarget ( new TargetCardInYourGraveyard ( new FilterInstantOrSorceryCard ( "instant or sorcery card from your graveyard" )  )  ) ; this . addAbility ( ability ) ; } public UlamogsReclaimer ( final UlamogsReclaimer card )  { super ( card ) ; } @Override public UlamogsReclaimer copy (  )  { return new UlamogsReclaimer ( this ) ; } } 
public class UlamogTheCeaselessHunger extends CardImpl { public UlamogTheCeaselessHunger ( UUID ownerId )  { super ( ownerId, 15, "Ulamog, the Ceaseless Hunger", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{10}" ) ; this . expansionSetCode = "BFZ"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 10 ) ; this . toughness = new MageInt ( 10 ) ; this . addAbility ( new UlamogExilePermanentsOnCastAbility (  )  ) ; this . addAbility ( IndestructibleAbility . getInstance (  )  ) ; Effect effect = new UlamogExileLibraryEffect (  ) ; effect . setText ( "defending player exiles the top twenty cards of his or her library" ) ; this . addAbility ( new UlamogAttackTriggeredAbility ( effect )  ) ; } public UlamogTheCeaselessHunger ( final UlamogTheCeaselessHunger card )  { super ( card ) ; } @Override public UlamogTheCeaselessHunger copy (  )  { return new UlamogTheCeaselessHunger ( this ) ; } } class UlamogExilePermanentsOnCastAbility extends TriggeredAbilityImpl { UlamogExilePermanentsOnCastAbility (  )  { super ( Zone . STACK, new ExileTargetEffect ( "exile two target permanents" )  ) ; this . addTarget ( new TargetPermanent ( 2, new FilterPermanent (  )  )  ) ; } UlamogExilePermanentsOnCastAbility ( UlamogExilePermanentsOnCastAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SPELL_CAST; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Spell spell =  ( Spell )  game . getObject ( event . getTargetId (  )  ) ; return this . getSourceId (  )  . equals ( spell . getSourceId (  )  ) ; } @Override public UlamogExilePermanentsOnCastAbility copy (  )  { return new UlamogExilePermanentsOnCastAbility ( this ) ; } @Override public String getRule (  )  { return "When you cast {this}, " + super . getRule (  ) ; } } class UlamogAttackTriggeredAbility extends TriggeredAbilityImpl { public UlamogAttackTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect ) ; } public UlamogAttackTriggeredAbility ( final UlamogAttackTriggeredAbility ability )  { super ( ability ) ; } @Override public UlamogAttackTriggeredAbility copy (  )  { return new UlamogAttackTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent sourcePermanent = game . getPermanent ( this . getSourceId (  )  ) ; if  ( sourcePermanent != null && event . getSourceId (  )  != null && event . getSourceId (  )  . equals ( this . getSourceId (  )  )  )  { UUID defender = game . getCombat (  )  . getDefendingPlayerId ( this . getSourceId (  ) , game ) ; this . getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( defender )  ) ; return true; } return false; } @Override public String getRule (  )  { return new StringBuilder ( "Whenever {this} attacks, " )  . append ( super . getRule (  )  )  . toString (  ) ; } } class UlamogExileLibraryEffect extends OneShotEffect { public UlamogExileLibraryEffect (  )  { super ( Outcome . Exile ) ; this . staticText = "defending player exiles the top twenty cards of his or her library"; } public UlamogExileLibraryEffect ( final UlamogExileLibraryEffect effect )  { super ( effect ) ; } @Override public UlamogExileLibraryEffect copy (  )  { return new UlamogExileLibraryEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player defender = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( defender != null )  { int count = Math . min ( defender . getLibrary (  )  . size (  ) , 20 ) ; for  ( int i = 0; i < count; i++ )  { Card card = defender . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { card . moveToExile ( null, null, source . getSourceId (  ) , game ) ; } } return true; } return false; } } 
public class UndergrowthChampion extends CardImpl { public UndergrowthChampion ( UUID ownerId )  { super ( ownerId, 197, "Undergrowth Champion", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new UndergrowthChampionPreventionEffect (  )  )  ) ; this . addAbility ( new LandfallAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; } public UndergrowthChampion ( final UndergrowthChampion card )  { super ( card ) ; } @Override public UndergrowthChampion copy (  )  { return new UndergrowthChampion ( this ) ; } } class UndergrowthChampionPreventionEffect extends PreventionEffectImpl { private int turn = 0; private Step combatPhaseStep = null; public UndergrowthChampionPreventionEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "If damage would be dealt to {this} while it has a +1/+1 counter on it, prevent that damage and remove a +1/+1 counter from {this}"; } public UndergrowthChampionPreventionEffect ( final UndergrowthChampionPreventionEffect effect )  { super ( effect ) ; this . turn = effect . turn; this . combatPhaseStep = effect . combatPhaseStep; } @Override public UndergrowthChampionPreventionEffect copy (  )  { return new UndergrowthChampionPreventionEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { boolean removeCounter = true; if  ( game . getTurn (  )  . getPhase (  )  . getStep (  )  . getType (  )  . equals ( PhaseStep . COMBAT_DAMAGE )  )  { if  ( game . getTurnNum (  )  == turn && game . getTurn (  )  . getStep (  )  . equals ( combatPhaseStep )  )  { removeCounter = false; } else { turn = game . getTurnNum (  ) ; combatPhaseStep = game . getTurn (  )  . getStep (  ) ; } } if ( removeCounter && permanent . getCounters (  )  . containsKey ( CounterType . P1P1 )  )  { preventDamageAction ( event, source, game ) ; StringBuilder sb = new StringBuilder ( permanent . getName (  )  )  . append ( ": " ) ; permanent . removeCounters ( CounterType . P1P1 . createInstance (  ) , game ) ; sb . append ( "Removed a +1/+1 counter " ) ; game . informPlayers ( sb . toString (  )  ) ; } } return false; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( super . applies ( event, source, game )  )  { if  ( event . getTargetId (  )  . equals ( source . getSourceId (  )  )  )  { return true; } } return false; } } 
public class UnifiedFront extends CardImpl { public UnifiedFront ( UUID ownerId )  { super ( ownerId, 53, "Unified Front", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{W}" ) ; this . expansionSetCode = "BFZ"; getSpellAbility (  )  . setAbilityWord ( AbilityWord . CONVERGE ) ; Effect effect = new CreateTokenEffect ( new KorAllyToken (  ) , ColorsOfManaSpentToCastCount . getInstance (  )  ) ; effect . setText ( "Put a 1/1 white Kor Ally creature token onto the battlefield for each color of mana spent to cast {this}" ) ; getSpellAbility (  )  . addEffect ( effect ) ; } public UnifiedFront ( final UnifiedFront card )  { super ( card ) ; } @Override public UnifiedFront copy (  )  { return new UnifiedFront ( this ) ; } } 
public class ValakutPredator extends CardImpl { public ValakutPredator ( UUID ownerId )  { super ( ownerId, 160, "Valakut Predator", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new LandfallAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , false )  ) ; } public ValakutPredator ( final ValakutPredator card )  { super ( card ) ; } @Override public ValakutPredator copy (  )  { return new ValakutPredator ( this ) ; } } 
public class VampiricRites extends CardImpl { public VampiricRites ( UUID ownerId )  { super ( ownerId, 124, "Vampiric Rites", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}" ) ; this . expansionSetCode = "BFZ"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 1 ) , new ManaCostsImpl<> ( "{1}{B}" )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( new FilterControlledCreaturePermanent ( "a creature" )  )  )  ) ; Effect effect = new DrawCardSourceControllerEffect ( 1 ) ; effect . setText ( "and draw a card" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public VampiricRites ( final VampiricRites card )  { super ( card ) ; } @Override public VampiricRites copy (  )  { return new VampiricRites ( this ) ; } } 
public class VestigeOfEmrakul extends CardImpl { public VestigeOfEmrakul ( UUID ownerId )  { super ( ownerId, 136, "Vestige of Emrakul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; } public VestigeOfEmrakul ( final VestigeOfEmrakul card )  { super ( card ) ; } @Override public VestigeOfEmrakul copy (  )  { return new VestigeOfEmrakul ( this ) ; } } 
public class VileAggregate extends CardImpl { private final static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "colorless creatures you control" ) ; static { filter . add ( new ColorlessPredicate (  )  ) ; } public VileAggregate ( UUID ownerId )  { super ( ownerId, 137, "Vile Aggregate", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Drone" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new SetPowerSourceEffect ( new PermanentsOnBattlefieldCount ( filter ) , Duration . EndOfGame ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, effect )  ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new IngestAbility (  )  ) ; } public VileAggregate ( final VileAggregate card )  { super ( card ) ; } @Override public VileAggregate copy (  )  { return new VileAggregate ( this ) ; } } 
public class VoidAttendant extends CardImpl { public VoidAttendant ( UUID ownerId )  { super ( ownerId, 169, "Void Attendant", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Effect effect = new CreateTokenEffect ( new EldraziScionToken (  )  ) ; effect . setText ( "put a 1/1 colorless Eldrazi Scion creature token onto the battlefield .  It has \"Sacrifice this creature: Add {C} to your mana pool . \"" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{1}{G}" )  ) ; ability . addCost ( new ExileOpponentsCardFromExileToGraveyardCost ( true )  ) ; this . addAbility ( ability ) ; } public VoidAttendant ( final VoidAttendant card )  { super ( card ) ; } @Override public VoidAttendant copy (  )  { return new VoidAttendant ( this ) ; } } 
public class VoidWinnower extends CardImpl { public VoidWinnower ( UUID ownerId )  { super ( ownerId, 17, "Void Winnower", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{9}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . power = new MageInt ( 11 ) ; this . toughness = new MageInt ( 9 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new VoidWinnowerCantCastEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new VoidWinnowerCantBlockEffect (  )  )  ) ; } public VoidWinnower ( final VoidWinnower card )  { super ( card ) ; } @Override public VoidWinnower copy (  )  { return new VoidWinnower ( this ) ; } } class VoidWinnowerCantCastEffect extends ContinuousRuleModifyingEffectImpl { public VoidWinnowerCantCastEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Your opponent can't cast spells with even converted mana costs .  <i> ( Zero is even .  ) </i>"; } public VoidWinnowerCantCastEffect ( final VoidWinnowerCantCastEffect effect )  { super ( effect ) ; } @Override public VoidWinnowerCantCastEffect copy (  )  { return new VoidWinnowerCantCastEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public String getInfoMessage ( Ability source, GameEvent event, Game game )  { MageObject mageObject = game . getObject ( source . getSourceId (  )  ) ; if  ( mageObject != null )  { return "You can't cast spells with even converted mana costs  ( " + mageObject . getIdName (  )  + " )  . "; } return null; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . CAST_SPELL_LATE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( game . getOpponents ( source . getControllerId (  )  )  . contains ( event . getPlayerId (  )  )  )  { Spell spell = game . getStack (  )  . getSpell ( event . getTargetId (  )  ) ; if  ( spell != null )  { return  ( spell . getConvertedManaCost (  )  & 1 )  == 0; } } return false; } } class VoidWinnowerCantBlockEffect extends RestrictionEffect { public VoidWinnowerCantBlockEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "Your opponents can't block with creatures with even converted mana costs"; } public VoidWinnowerCantBlockEffect ( final VoidWinnowerCantBlockEffect effect )  { super ( effect ) ; } @Override public VoidWinnowerCantBlockEffect copy (  )  { return new VoidWinnowerCantBlockEffect ( this ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { if  ( game . getOpponents ( source . getControllerId (  )  )  . contains ( permanent . getControllerId (  )  )  )  { return  ( permanent . getManaCost (  )  . convertedManaCost (  )  & 1 )  == 0; } return false; } @Override public boolean canBlock ( Permanent attacker, Permanent blocker, Ability source, Game game )  { return false; } } 
public class VolcanicUpheaval extends CardImpl { public VolcanicUpheaval ( UUID ownerId )  { super ( ownerId, 161, "Volcanic Upheaval", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{R}" ) ; this . expansionSetCode = "BFZ"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetLandPermanent (  )  ) ; } public VolcanicUpheaval ( final VolcanicUpheaval card )  { super ( card ) ; } @Override public VolcanicUpheaval copy (  )  { return new VolcanicUpheaval ( this ) ; } } 
public class VoraciousNull extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public VoraciousNull ( UUID ownerId )  { super ( ownerId, 125, "Voracious Null", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new ActivateAsSorceryActivatedAbility ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  ) , new ManaCostsImpl ( "{1}{B}" )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( 1, 1, filter, false )  )  ) ; this . addAbility ( ability ) ; } public VoraciousNull ( final VoraciousNull card )  { super ( card ) ; } @Override public VoraciousNull copy (  )  { return new VoraciousNull ( this ) ; } } 
public class WastelandStrangler extends CardImpl { public WastelandStrangler ( UUID ownerId )  { super ( ownerId, 102, "Wasteland Strangler", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Eldrazi" ) ; this . subtype . add ( "Processor" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DevoidAbility ( this . color )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility (  new DoIfCostPaid ( new BoostTargetEffect ( -3, -3, Duration . EndOfTurn ) , new ExileOpponentsCardFromExileToGraveyardCost ( true )  ) , false ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public WastelandStrangler ( final WastelandStrangler card )  { super ( card ) ; } @Override public WastelandStrangler copy (  )  { return new WastelandStrangler ( this ) ; } } 
public class WaveWingElemental extends CardImpl { public WaveWingElemental ( UUID ownerId )  { super ( ownerId, 88, "Wave-Wing Elemental", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new LandfallAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , false )  ) ; } public WaveWingElemental ( final WaveWingElemental card )  { super ( card ) ; } @Override public WaveWingElemental copy (  )  { return new WaveWingElemental ( this ) ; } } 
public class WindriderPatrol extends CardImpl { public WindriderPatrol ( UUID ownerId )  { super ( ownerId, 89, "Windrider Patrol", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}{U}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new ScryEffect ( 2 ) , false )  ) ; } public WindriderPatrol ( final WindriderPatrol card )  { super ( card ) ; } @Override public WindriderPatrol copy (  )  { return new WindriderPatrol ( this ) ; } } 
public class WoodlandWanderer extends CardImpl { public WoodlandWanderer ( UUID ownerId )  { super ( ownerId, 198, "Woodland Wanderer", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  ) , ColorsOfManaSpentToCastCount . getInstance (  ) , true ) , null, "<i>Converge</i> &mdash; {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it . ", null )  ) ; } public WoodlandWanderer ( final WoodlandWanderer card )  { super ( card ) ; } @Override public WoodlandWanderer copy (  )  { return new WoodlandWanderer ( this ) ; } } 
public class ZadaHedronGrinder extends CardImpl { public ZadaHedronGrinder ( UUID ownerId )  { super ( ownerId, 162, "Zada, Hedron Grinder", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "BFZ"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new ZadaHedronGrinderTriggeredAbility (  )  ) ; } public ZadaHedronGrinder ( final ZadaHedronGrinder card )  { super ( card ) ; } @Override public ZadaHedronGrinder copy (  )  { return new ZadaHedronGrinder ( this ) ; } } class ZadaHedronGrinderTriggeredAbility extends TriggeredAbilityImpl { ZadaHedronGrinderTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new ZadaHedronGrinderEffect (  ) , false ) ; } ZadaHedronGrinderTriggeredAbility ( final ZadaHedronGrinderTriggeredAbility ability )  { super ( ability ) ; } @Override public ZadaHedronGrinderTriggeredAbility copy (  )  { return new ZadaHedronGrinderTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . SPELL_CAST; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getPlayerId (  )  . equals ( this . getControllerId (  )  )  )  { Spell spell = game . getStack (  )  . getSpell ( event . getTargetId (  )  ) ; if  ( isControlledInstantOrSorcery ( spell )  )  { boolean targetsSource = false; for  ( Mode mode : spell . getSpellAbility (  )  . getModes (  )  . getSelectedModes (  )  )  { for  ( Target target : mode . getTargets (  )  )  { for  ( UUID targetId : target . getTargets (  )  )  { if  ( targetId . equals ( getSourceId (  )  )  )  { targetsSource = true; } else { return false; } } } } if  ( targetsSource )  { this . getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( spell . getId (  )  )  ) ; return true; } } } return false; } private boolean isControlledInstantOrSorcery ( Spell spell )  { return spell != null &&  ( spell . getControllerId (  )  . equals ( this . getControllerId (  )  )  )  &&  ( spell . getCardType (  )  . contains ( CardType . INSTANT )  || spell . getCardType (  )  . contains ( CardType . SORCERY )  ) ; } @Override public String getRule (  )  { return "Whenever you cast an instant or sorcery spell that targets only {this}, copy that spell for each other creature you control that the spell could target .  Each copy targets a different one of those creatures . "; } } class ZadaHedronGrinderEffect extends OneShotEffect { public ZadaHedronGrinderEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "copy that spell for each other creature you control that the spell could target .  Each copy targets a different one of those creatures"; } public ZadaHedronGrinderEffect ( final ZadaHedronGrinderEffect effect )  { super ( effect ) ; } @Override public ZadaHedronGrinderEffect copy (  )  { return new ZadaHedronGrinderEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Spell spell = game . getStack (  )  . getSpell ( targetPointer . getFirst ( game, source )  ) ; if  ( spell == null )  { spell =  ( Spell )  game . getLastKnownInformation ( targetPointer . getFirst ( game, source ) , Zone . STACK ) ; } Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( spell != null && controller != null )  { Target usedTarget = null; setUsedTarget: for  ( Mode mode : spell . getSpellAbility (  )  . getModes (  )  . getSelectedModes (  )  )  { for  ( Target target : mode . getTargets (  )  )  { if  ( target . getFirstTarget (  )  . equals ( source . getSourceId (  )  )  )  { usedTarget = target . copy (  ) ; usedTarget . clearChosen (  ) ; break setUsedTarget; } } } if  ( usedTarget == null )  { return false; } for  ( Permanent creature : game . getState (  )  . getBattlefield (  )  . getAllActivePermanents ( new FilterCreaturePermanent (  ) , source . getControllerId (  ) , game )  )  { if  ( !creature . getId (  )  . equals ( source . getSourceId (  )  )  && usedTarget . canTarget ( source . getControllerId (  ) , creature . getId (  ) , source, game )  )  { Spell copy = spell . copySpell (  ) ; setTarget: for  ( Mode mode : spell . getSpellAbility (  )  . getModes (  )  . getSelectedModes (  )  )  { for  ( Target target : mode . getTargets (  )  )  { if  ( target . getClass (  )  . equals ( usedTarget . getClass (  )  )  )  { target . clearChosen (  ) ;  
public class ZulaportCutthroat extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public ZulaportCutthroat ( UUID ownerId )  { super ( ownerId, 126, "Zulaport Cutthroat", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "BFZ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Rogue" ) ; this . subtype . add ( "Ally" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new DiesThisOrAnotherCreatureTriggeredAbility ( new LoseLifeOpponentsEffect ( 1 ) , false, filter ) ; Effect effect = new GainLifeEffect ( 1 ) ; effect . setText ( "and you gain 1 life" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public ZulaportCutthroat ( final ZulaportCutthroat card )  { super ( card ) ; } @Override public ZulaportCutthroat copy (  )  { return new ZulaportCutthroat ( this ) ; } } 
public class AkkiBlizzardHerder extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent (  ) ; public AkkiBlizzardHerder ( UUID ownerId )  { super ( ownerId, 91, "Akki Blizzard-Herder", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DiesTriggeredAbility ( new SacrificeAllEffect ( filter )  )  ) ; } public AkkiBlizzardHerder ( final AkkiBlizzardHerder card )  { super ( card ) ; } @Override public AkkiBlizzardHerder copy (  )  { return new AkkiBlizzardHerder ( this ) ; } } 
public class AkkiRaider extends CardImpl { public AkkiRaider ( UUID ownerId )  { super ( ownerId, 92, "Akki Raider", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new ZoneChangeAllTriggeredAbility ( Zone . BATTLEFIELD, Zone . BATTLEFIELD, Zone . GRAVEYARD, new BoostSourceEffect ( 1,0,Duration . EndOfTurn ) , new FilterLandPermanent (  ) , "Whenever a land is put into a graveyard from the battlefield, ", false )  ) ; } public AkkiRaider ( final AkkiRaider card )  { super ( card ) ; } @Override public AkkiRaider copy (  )  { return new AkkiRaider ( this ) ; } } 
public class AshenMonstrosity extends CardImpl { public AshenMonstrosity ( UUID ownerId )  { super ( ownerId, 93, "Ashen Monstrosity", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new AttacksEachTurnStaticAbility (  )  ) ; } public AshenMonstrosity ( final AshenMonstrosity card )  { super ( card ) ; } @Override public AshenMonstrosity copy (  )  { return new AshenMonstrosity ( this ) ; } } 
public class AuraBarbs extends CardImpl { public AuraBarbs ( UUID ownerId )  { super ( ownerId, 94, "Aura Barbs", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new AuraBarbsEffect (  )  ) ; } public AuraBarbs ( final AuraBarbs card )  { super ( card ) ; } @Override public AuraBarbs copy (  )  { return new AuraBarbs ( this ) ; } private class AuraBarbsEffect extends OneShotEffect { public AuraBarbsEffect (  )  { super ( Outcome . Detriment ) ; staticText = "Each enchantment deals 2 damage to its controller, then each Aura attached to a creature deals 2 damage to the creature it's attached to"; } public AuraBarbsEffect ( final AuraBarbsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { FilterPermanent filterEnchantments = new FilterPermanent (  ) ; filterEnchantments . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filterEnchantments, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { Player controller = game . getPlayer ( permanent . getControllerId (  )  ) ; if  ( controller != null )  { controller . damage ( 2, permanent . getId (  ) , game, false, true ) ; game . informPlayers ( "2 damage assigned to " + controller . getLogName (  )  + " from " + permanent . getName (  )  ) ; } } filterEnchantments . add ( new SubtypePredicate ( "Aura" )  ) ; for  ( Permanent auraEnchantment : game . getBattlefield (  )  . getActivePermanents ( filterEnchantments, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { if  ( auraEnchantment . getAttachedTo (  )  != null )  { Permanent attachedToCreature = game . getPermanent ( auraEnchantment . getAttachedTo (  )  ) ; if  ( attachedToCreature != null && attachedToCreature . getCardType (  )  . contains ( CardType . CREATURE )  )  { attachedToCreature . damage ( 2, auraEnchantment . getId (  ) , game, false, true ) ; game . informPlayers ( "2 damage assigned to " + attachedToCreature . getName (  )  + " from " + auraEnchantment . getName (  )  ) ; } } } return true; } @Override public AuraBarbsEffect copy (  )  { return new AuraBarbsEffect ( this ) ; } } } 
public class BlademaneBaku extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public BlademaneBaku ( UUID ownerId )  { super ( ownerId, 95, "Blademane Baku", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BlademaneBakuBoostEffect (  ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new RemoveVariableCountersSourceCost ( CounterType . KI . createInstance ( 1 )  )  ) ; this . addAbility ( ability ) ; } public BlademaneBaku ( final BlademaneBaku card )  { super ( card ) ; } @Override public BlademaneBaku copy (  )  { return new BlademaneBaku ( this ) ; } class BlademaneBakuBoostEffect extends OneShotEffect { public BlademaneBakuBoostEffect (  )  { super ( Outcome . UnboostCreature ) ; staticText = "For each counter removed, {this} gets +2/+0 until end of turn"; } public BlademaneBakuBoostEffect ( BlademaneBakuBoostEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { int numberToBoost = 0; for  ( Cost cost : source . getCosts (  )  )  { if  ( cost instanceof RemoveVariableCountersSourceCost )  { numberToBoost =  (  ( RemoveVariableCountersSourceCost ) cost )  . getAmount (  )  * 2; } } if  ( numberToBoost >= 0 )  { game . addEffect ( new BoostSourceEffect ( numberToBoost, 0, Duration . EndOfTurn ) , source ) ; return true; } return false; } @Override public BlademaneBakuBoostEffect copy (  )  { return new BlademaneBakuBoostEffect ( this ) ; } } } 
public class BlazingShoal extends CardImpl { public BlazingShoal ( UUID ownerId )  { super ( ownerId, 96, "Blazing Shoal", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{X}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; FilterOwnedCard filter = new FilterOwnedCard ( "a red card with converted mana cost X from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . RED )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class BlessingOfLeeches extends CardImpl { public BlessingOfLeeches ( UUID ownerId )  { super ( ownerId, 62, "Blessing of Leeches", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Regenerate )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new LoseLifeSourceControllerEffect ( 1 ) , TargetController . YOU, false )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateAttachedEffect ( AttachmentType . AURA ) ,new GenericManaCost ( 0 )  )  ) ; } public BlessingOfLeeches ( final BlessingOfLeeches card )  { super ( card ) ; } @Override public BlessingOfLeeches copy (  )  { return new BlessingOfLeeches ( this ) ; } } 
public class BlindingPowder extends CardImpl { public BlindingPowder ( UUID ownerId )  { super ( ownerId, 153, "Blinding Powder", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Equipment" ) ; Effect effect = new PreventCombatDamageToSourceEffect ( Duration . EndOfTurn ) ; effect . setText ( "Prevent all combat damage that would be dealt to this creature this turn" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new BlindingPowderUnattachCost ( getName (  ) , getId (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability, AttachmentType . EQUIPMENT, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . PreventDamage, new GenericManaCost ( 2 )  )  ) ; } public BlindingPowder ( final BlindingPowder card )  { super ( card ) ; } @Override public BlindingPowder copy (  )  { return new BlindingPowder ( this ) ; } } class BlindingPowderUnattachCost extends CostImpl { protected UUID sourceEquipmentId; public BlindingPowderUnattachCost ( String name, UUID sourceId )  { this . text = "Unattach " + name; this . sourceEquipmentId = sourceId; } public BlindingPowderUnattachCost ( final BlindingPowderUnattachCost cost )  { super ( cost ) ; this . sourceEquipmentId = cost . sourceEquipmentId; } @Override public boolean pay ( Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay )  { Permanent permanent = game . getPermanent ( sourceId ) ; if  ( permanent != null )  { for  ( UUID attachmentId : permanent . getAttachments (  )  )  { Permanent attachment = game . getPermanent ( attachmentId ) ; if  ( attachment != null && attachment . getId (  )  . equals ( sourceEquipmentId )  )  { paid = permanent . removeAttachment ( attachmentId, game ) ; if  ( paid )  { break; } } } } return paid; } @Override public boolean canPay ( Ability ability, UUID sourceId, UUID controllerId, Game game )  { Permanent permanent = game . getPermanent ( sourceId ) ; if  ( permanent != null )  { for  ( UUID attachmentId : permanent . getAttachments (  )  )  { Permanent attachment = game . getPermanent ( attachmentId ) ; if  ( attachment != null && attachment . getId (  )  . equals ( sourceEquipmentId )  )  { return true; } } } return false; } @Override public BlindingPowderUnattachCost copy (  )  { return new BlindingPowderUnattachCost ( this ) ; } } 
public class BodyOfJukai extends CardImpl { public BodyOfJukai ( UUID ownerId )  { super ( ownerId, 121, "Body of Jukai", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{7}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 8 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new SoulshiftAbility ( 8 )  ) ; } public BodyOfJukai ( final BodyOfJukai card )  { super ( card ) ; } @Override public BodyOfJukai copy (  )  { return new BodyOfJukai ( this ) ; } } 
public class BudokaPupil extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public BudokaPupil ( UUID ownerId )  { super ( ownerId, 122, "Budoka Pupil", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Monk" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . flipCard = true; this . flipCardName = "Ichiga, Who Topples Oaks"; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; this . addAbility ( new ConditionalTriggeredAbility (  new OnEventTriggeredAbility ( GameEvent . EventType . END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect ( new IchigaWhoTopplesOaks (  )  ) , true ) , new SourceHasCounterCondition ( CounterType . KI, 2, Integer . MAX_VALUE ) , "At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it . " )  ) ; } public BudokaPupil ( final BudokaPupil card )  { super ( card ) ; } @Override public BudokaPupil copy (  )  { return new BudokaPupil ( this ) ; } } class IchigaWhoTopplesOaks extends Token { IchigaWhoTopplesOaks (  )  { super ( "Ichiga, Who Topples Oaks", "" ) ; supertype . add ( "Legendary" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 4 ) ; toughness = new MageInt ( 3 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility (  Zone . BATTLEFIELD, new BoostTargetEffect ( 2, 2, Duration . EndOfTurn ) , new RemoveCountersSourceCost ( CounterType . KI . createInstance (  )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } } 
public class CallForBlood extends CardImpl { public CallForBlood ( UUID ownerId )  { super ( ownerId, 63, "Call for Blood", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{4}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; DynamicValue xValue = new CallForBloodDynamicValue (  ) ; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( xValue, xValue, Duration . EndOfTurn, true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public CallForBlood ( final CallForBlood card )  { super ( card ) ; } @Override public CallForBlood copy (  )  { return new CallForBlood ( this ) ; } } class CallForBloodDynamicValue implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { Card sourceCard = game . getCard ( sourceAbility . getSourceId (  )  ) ; if  ( sourceCard != null )  { for  ( Object cost: sourceAbility . getCosts (  )  )  { if  ( cost instanceof SacrificeTargetCost )  { Permanent p =  ( Permanent )  game . getLastKnownInformation (  (  ( SacrificeTargetCost )  cost )  . getPermanents (  )  . get ( 0 )  . getId (  ) , Zone . BATTLEFIELD ) ; if  ( p != null )  { return -1 * p . getPower (  )  . getValue (  ) ; } } } } return 0; } @Override public CallForBloodDynamicValue copy (  )  { return this; } @Override public String getMessage (  )  { return ", where X is the sacrificed creature's power"; } @Override public String toString (  )  { return "-X"; } } 
public class CallowJushi extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public CallowJushi ( UUID ownerId )  { super ( ownerId, 31, "Callow Jushi", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . flipCard = true; this . flipCardName = "Jaraku the Interloper"; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; this . addAbility ( new ConditionalTriggeredAbility (  new OnEventTriggeredAbility ( GameEvent . EventType . END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect ( new JarakuTheInterloper (  )  )  ) , new SourceHasCounterCondition ( CounterType . KI, 2, Integer . MAX_VALUE ) , "At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it . " )  ) ; } public CallowJushi ( final CallowJushi card )  { super ( card ) ; } @Override public CallowJushi copy (  )  { return new CallowJushi ( this ) ; } } class JarakuTheInterloper extends Token { JarakuTheInterloper (  )  { super ( "Jaraku the Interloper", "" ) ; supertype . add ( "Legendary" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlue ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 4 ) ; Ability ability = new SimpleActivatedAbility (  Zone . BATTLEFIELD, new CounterUnlessPaysEffect ( new GenericManaCost ( 2 )  ) , new RemoveCountersSourceCost ( CounterType . KI . createInstance (  )  )  ) ; ability . addTarget ( new TargetSpell (  )  ) ; this . addAbility ( ability ) ; } } 
public class ChildOfThorns extends CardImpl { public ChildOfThorns ( UUID ownerId )  { super ( ownerId, 123, "Child of Thorns", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 1, 1, Duration . EndOfTurn ) , new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public ChildOfThorns ( final ChildOfThorns card )  { super ( card ) ; } @Override public ChildOfThorns copy (  )  { return new ChildOfThorns ( this ) ; } } 
public class ChiseiHeartOfOceans extends CardImpl { private static final FilterPermanent filter = new FilterControlledPermanent ( "remove a counter from a permanent you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; filter . add ( new CounterAnyPredicate (  )  ) ; } public ChiseiHeartOfOceans ( UUID ownerId )  { super ( ownerId, 32, "Chisei, Heart of Oceans", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; TargetPermanent target = new TargetPermanent ( 1,1,filter,true ) ; target . setTargetName ( "a permanent you control" ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new SacrificeSourceUnlessPaysEffect ( new RemoveCounterCost ( target )  ) ,TargetController . YOU, false )  ) ; } public ChiseiHeartOfOceans ( final ChiseiHeartOfOceans card )  { super ( card ) ; } @Override public ChiseiHeartOfOceans copy (  )  { return new ChiseiHeartOfOceans ( this ) ; } } 
public class ClashOfRealities extends CardImpl { private static final FilterCreaturePermanent filterSpirit = new FilterCreaturePermanent ( "Spirit creature" ) ; private static final FilterCreaturePermanent filterNotSpirit = new FilterCreaturePermanent ( "non-Spirit creature" ) ; static { filterSpirit . add ( new SubtypePredicate ( "Spirit" )  ) ; filterNotSpirit . add ( Predicates . not ( new SubtypePredicate ( "Spirit" )  )  ) ; } public ClashOfRealities ( UUID ownerId )  { super ( ownerId, 97, "Clash of Realities", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{R}" ) ; this . expansionSetCode = "BOK"; Ability ability1 = new ClashOfRealitiesTriggeredAbility ( new DamageTargetEffect ( 3 ) , "When this permanent enters the battlefield, " ) ; ability1 . addTarget ( new TargetCreaturePermanent ( filterNotSpirit )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAllEffect ( ability1, Duration . WhileOnBattlefield, filterSpirit, "All Spirits have \"When this permanent enters the battlefield, you may have it deal 3 damage to target non-Spirit creature . \"" )  )  ) ; Ability ability2 = new ClashOfRealitiesTriggeredAbility ( new DamageTargetEffect ( 3 ) , "When this creature enters the battlefield, " ) ; ability2 . addTarget ( new TargetCreaturePermanent ( filterSpirit )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAllEffect ( ability2, Duration . WhileOnBattlefield, filterNotSpirit, "Non-Spirit creatures have \"When this creature enters the battlefield, you may have it deal 3 damage to target Spirit creature . \"" )  )  ) ; } public ClashOfRealities ( final ClashOfRealities card )  { super ( card ) ; } @Override public ClashOfRealities copy (  )  { return new ClashOfRealities ( this ) ; } private class ClashOfRealitiesTriggeredAbility extends ZoneChangeTriggeredAbility { public ClashOfRealitiesTriggeredAbility ( Effect effect, String rule )  { super ( Zone . BATTLEFIELD, effect, rule, true ) ; } public ClashOfRealitiesTriggeredAbility ( ClashOfRealitiesTriggeredAbility ability )  { super ( ability ) ; } @Override public ClashOfRealitiesTriggeredAbility copy (  )  { return new ClashOfRealitiesTriggeredAbility ( this ) ; } } } 
public class CrackTheEarth extends CardImpl { public CrackTheEarth ( UUID ownerId )  { super ( ownerId, 98, "Crack the Earth", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new SacrificeAllEffect ( 1, new FilterControlledPermanent ( "permanent" )  )  ) ; } public CrackTheEarth ( final CrackTheEarth card )  { super ( card ) ; } @Override public CrackTheEarth copy (  )  { return new CrackTheEarth ( this ) ; } } 
public class CrawlingFilth extends CardImpl { public CrawlingFilth ( UUID ownerId )  { super ( ownerId, 64, "Crawling Filth", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FearAbility . getInstance (  )  ) ; this . addAbility ( new SoulshiftAbility ( 5 )  ) ; } public CrawlingFilth ( final CrawlingFilth card )  { super ( card ) ; } @Override public CrawlingFilth copy (  )  { return new CrawlingFilth ( this ) ; } } 
public class CunningBandit extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public CunningBandit ( UUID ownerId )  { super ( ownerId, 99, "Cunning Bandit", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . flipCard = true; this . flipCardName = "Azamuki, Treachery Incarnate"; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; this . addAbility ( new ConditionalTriggeredAbility (  new OnEventTriggeredAbility ( GameEvent . EventType . END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect ( new AzamukiTreacheryIncarnate (  )  )  ) , new SourceHasCounterCondition ( CounterType . KI, 2, Integer . MAX_VALUE ) , "At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it . " )  ) ; } public CunningBandit ( final CunningBandit card )  { super ( card ) ; } @Override public CunningBandit copy (  )  { return new CunningBandit ( this ) ; } } class AzamukiTreacheryIncarnate extends Token { AzamukiTreacheryIncarnate (  )  { super ( "Azamuki, Treachery Incarnate", "" ) ; supertype . add ( "Legendary" ) ; cardType . add ( CardType . CREATURE ) ; color . setRed ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 5 ) ; toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility (  Zone . BATTLEFIELD, new GainControlTargetEffect ( Duration . EndOfTurn ) , new RemoveCountersSourceCost ( CounterType . KI . createInstance (  )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } } 
public class DayOfDestiny extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Legendary creatures" ) ; static { filter . add ( new SupertypePredicate ( "Legendary" )  ) ; } public DayOfDestiny ( UUID ownerId )  { super ( ownerId, 1, "Day of Destiny", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 2, 2, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public DayOfDestiny ( final DayOfDestiny card )  { super ( card ) ; } @Override public DayOfDestiny copy (  )  { return new DayOfDestiny ( this ) ; } } 
public class DisruptingShoal extends CardImpl { public DisruptingShoal ( UUID ownerId )  { super ( ownerId, 33, "Disrupting Shoal", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{X}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; FilterOwnedCard filter = new FilterOwnedCard ( "a blue card with converted mana cost X from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class EmptyShrineKannushi extends CardImpl { public EmptyShrineKannushi ( UUID ownerId )  { super ( ownerId, 2, "Empty-Shrine Kannushi", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EmptyShrineKannushiProtectionAbility (  )  ) ; } public EmptyShrineKannushi ( final EmptyShrineKannushi card )  { super ( card ) ; } @Override public EmptyShrineKannushi copy (  )  { return new EmptyShrineKannushi ( this ) ; } } class EmptyShrineKannushiProtectionAbility extends ProtectionAbility { public EmptyShrineKannushiProtectionAbility (  )  { super ( new FilterCard (  )  ) ; } public EmptyShrineKannushiProtectionAbility ( final EmptyShrineKannushiProtectionAbility ability )  { super ( ability ) ; } @Override public EmptyShrineKannushiProtectionAbility copy (  )  { return new EmptyShrineKannushiProtectionAbility ( this ) ; } @Override public boolean canTarget ( MageObject source, Game game )  { ObjectColor color = new ObjectColor (  ) ; for  ( Permanent permanent: game . getBattlefield (  )  . getAllActivePermanents ( controllerId )  )  { ObjectColor permanentColor = permanent . getColor ( game ) ; if  ( permanentColor . isColorless (  )  )  { continue; } if  ( permanentColor . isBlack (  )  )  { color . setBlack ( true ) ; } if  ( permanentColor . isBlue (  )  )  { color . setBlue ( true ) ; } if  ( permanentColor . isGreen (  )  )  { color . setGreen ( true ) ; } if  ( permanentColor . isRed (  )  )  { color . setRed ( true ) ; } if  ( permanentColor . isWhite (  )  )  { color . setWhite ( true ) ; } } ArrayList<Predicate<MageObject>> colorPredicates = new ArrayList<Predicate<MageObject>> (  ) ; if  ( color . isBlack (  )  )  { colorPredicates . add ( new ColorPredicate ( ObjectColor . BLACK )  ) ; } if  ( color . isBlue (  )  )  { colorPredicates . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; } if  ( color . isGreen (  )  )  { colorPredicates . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; } if  ( color . isRed (  )  )  { colorPredicates . add ( new ColorPredicate ( ObjectColor . RED )  ) ; } if  ( color . isWhite (  )  )  { colorPredicates . add ( new ColorPredicate ( ObjectColor . WHITE )  ) ; } Filter protectionFilter = new FilterObject ( "the colors of permanents you control" ) ; protectionFilter . add ( Predicates . or ( colorPredicates )  ) ; this . filter = protectionFilter; return super . canTarget ( source, game ) ; } @Override public String getRule (  )  { return "Empty-Shrine Kannushi has protection from the colors of permanents you control . "; } } 
public class EnshrinedMemories extends CardImpl { public EnshrinedMemories ( UUID ownerId )  { super ( ownerId, 124, "Enshrined Memories", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{G}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new RevealLibraryPutIntoHandEffect ( new ManacostVariableValue (  ) , new FilterCreatureCard ( "all creature cards" ) ,true )  ) ; } public EnshrinedMemories ( final EnshrinedMemories card )  { super ( card ) ; } @Override public EnshrinedMemories copy (  )  { return new EnshrinedMemories ( this ) ; } } 
public class FinalJudgment extends CardImpl { public FinalJudgment ( UUID ownerId )  { super ( ownerId, 4, "Final Judgment", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{4}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new FinalJudgmentEffect (  )  ) ; } public FinalJudgment ( final FinalJudgment card )  { super ( card ) ; } @Override public FinalJudgment copy (  )  { return new FinalJudgment ( this ) ; } } class FinalJudgmentEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterPermanent ( "" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public FinalJudgmentEffect (  )  { super ( Outcome . Exile ) ; staticText = "Exile all creatures"; } public FinalJudgmentEffect ( final FinalJudgmentEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . moveToExile ( null, null,source . getSourceId (  ) , game ) ; } return true; } @Override public FinalJudgmentEffect copy (  )  { return new FinalJudgmentEffect ( this ) ; } } 
public class FirstVolley extends CardImpl { public FirstVolley ( UUID ownerId )  { super ( ownerId, 100, "First Volley", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 1 )  ) ; Effect effect = new DamageTargetControllerEffect ( 1 ) ; effect . setText ( "and 1 damage to that creature's controller" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public FirstVolley ( final FirstVolley card )  { super ( card ) ; } @Override public FirstVolley copy (  )  { return new FirstVolley ( this ) ; } } 
public class FlamesOfTheBloodHand extends CardImpl { public FlamesOfTheBloodHand ( UUID ownerId )  { super ( ownerId, 101, "Flames of the Blood Hand", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{R}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 4, false )  ) ; this . getSpellAbility (  )  . addEffect ( new FlamesOfTheBloodHandReplacementEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public FlamesOfTheBloodHand ( final FlamesOfTheBloodHand card )  { super ( card ) ; } @Override public FlamesOfTheBloodHand copy (  )  { return new FlamesOfTheBloodHand ( this ) ; } } class FlamesOfTheBloodHandReplacementEffect extends ReplacementEffectImpl { public FlamesOfTheBloodHandReplacementEffect (  )  { super ( Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "If that player would gain life this turn, that player gains no life instead"; } public FlamesOfTheBloodHandReplacementEffect ( final FlamesOfTheBloodHandReplacementEffect effect )  { super ( effect ) ; } @Override public FlamesOfTheBloodHandReplacementEffect copy (  )  { return new FlamesOfTheBloodHandReplacementEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . GAIN_LIFE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getPlayerId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  ) ; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { return true; } } 
public class Floodbringer extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a land you control  ( return to hand ) " ) ; public Floodbringer ( UUID ownerId )  { super ( ownerId, 34, "Floodbringer", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Moonfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new GenericManaCost ( 2 )  ) ; ReturnToHandChosenControlledPermanentCost cost = new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  ) ; cost . setText ( "Return a land you control to its owner's hand" ) ; ability . addCost ( cost ) ; ability . addTarget ( new TargetLandPermanent (  )  ) ; this . addAbility ( ability ) ; } public Floodbringer ( final Floodbringer card )  { super ( card ) ; } @Override public Floodbringer copy (  )  { return new Floodbringer ( this ) ; } } 
public class ForkedBranchGarami extends CardImpl { public ForkedBranchGarami ( UUID ownerId )  { super ( ownerId, 125, "Forked-Branch Garami", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SoulshiftAbility ( 4 )  ) ; this . addAbility ( new SoulshiftAbility ( 4 )  ) ; } public ForkedBranchGarami ( final ForkedBranchGarami card )  { super ( card ) ; } @Override public ForkedBranchGarami copy (  )  { return new ForkedBranchGarami ( this ) ; } } 
public class Frostling extends CardImpl { public Frostling ( UUID ownerId )  { super ( ownerId, 103, "Frostling", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public Frostling ( final Frostling card )  { super ( card ) ; } @Override public Frostling copy (  )  { return new Frostling ( this ) ; } } 
public class FrostOgre extends CardImpl { public FrostOgre ( UUID ownerId )  { super ( ownerId, 102, "Frost Ogre", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 3 ) ; } public FrostOgre ( final FrostOgre card )  { super ( card ) ; } @Override public FrostOgre copy (  )  { return new FrostOgre ( this ) ; } } 
public class FumikoTheLowblood extends CardImpl { public FumikoTheLowblood ( UUID ownerId )  { super ( ownerId, 104, "Fumiko the Lowblood", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new BushidoAbility ( new AttackingCreatureCount ( "the number of attacking creatures" )  )  ) ; FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AttacksIfAbleAllEffect ( filter )  ) , new AttackedThisTurnWatcher (  )  ) ; } public FumikoTheLowblood ( final FumikoTheLowblood card )  { super ( card ) ; } @Override public FumikoTheLowblood copy (  )  { return new FumikoTheLowblood ( this ) ; } } 
public class GenjuOfTheCedars extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent ( "Forest" ) ; static { filter . add ( new SubtypePredicate ( "Forest" )  ) ; } public GenjuOfTheCedars ( UUID ownerId )  { super ( ownerId, 126, "Genju of the Cedars", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent ( filter ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . PutCreatureInPlay )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability ability2 = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureAttachedEffect ( new SpiritToken (  ) , "Enchanted Forest becomes a 4/4 green Spirit creature until end of turn .  It's still a land", Duration . EndOfTurn ) , new GenericManaCost ( 2 )  ) ; this . addAbility ( ability2 ) ; Effect effect = new ReturnToHandSourceEffect ( false, true ) ; effect . setText ( "you may return {this} from your graveyard to your hand" ) ; Ability ability3 = new DiesAttachedTriggeredAbility ( effect, "enchanted Forest", true, false ) ; this . addAbility ( ability3 ) ; } public GenjuOfTheCedars ( final GenjuOfTheCedars card )  { super ( card ) ; } @Override public GenjuOfTheCedars copy (  )  { return new GenjuOfTheCedars ( this ) ; } private class SpiritToken extends Token { SpiritToken (  )  { super ( "", "4/4 green Spirit creature" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 4 ) ; toughness = new MageInt ( 4 ) ; } } } 
public class GenjuOfTheFalls extends CardImpl { private static final FilterLandPermanent FILTER = new FilterLandPermanent ( "Island" ) ; static { FILTER . add ( new SubtypePredicate ( "Island" )  ) ; } public GenjuOfTheFalls ( UUID ownerId )  { super ( ownerId, 35, "Genju of the Falls", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent ( FILTER ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . PutCreatureInPlay )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability ability2 = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureAttachedEffect ( new SpiritToken (  ) , "Enchanted Island becomes a 3/2 blue Spirit creature with flying until end of turn .  It's still a land", Duration . EndOfTurn ) , new GenericManaCost ( 2 )  ) ; this . addAbility ( ability2 ) ; Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandSourceEffect ( false, true ) , "enchanted Island", true, false ) ; this . addAbility ( ability3 ) ; } public GenjuOfTheFalls ( final GenjuOfTheFalls card )  { super ( card ) ; } @Override public GenjuOfTheFalls copy (  )  { return new GenjuOfTheFalls ( this ) ; } private class SpiritToken extends Token { SpiritToken (  )  { super ( "Spirit", "3/2 blue Spirit creature with flying" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlue ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 2 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; } } } 
public class GenjuOfTheFens extends CardImpl { private static final FilterLandPermanent FILTER = new FilterLandPermanent ( "Swamp" ) ; static { FILTER . add ( new SubtypePredicate ( "Swamp" )  ) ; } public GenjuOfTheFens ( UUID ownerId )  { super ( ownerId, 66, "Genju of the Fens", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent ( FILTER ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . PutCreatureInPlay )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability ability2 = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureAttachedEffect ( new SpiritToken (  ) , "Until end of turn, enchanted Swamp becomes a 2/2 black Spirit creature with \"{B}: This creature gets +1/+1 until end of turn . \" It's still a land", Duration . EndOfTurn ) , new GenericManaCost ( 2 )  ) ; this . addAbility ( ability2 ) ; Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandSourceEffect ( false, true ) , "enchanted Swamp", true, false ) ; this . addAbility ( ability3 ) ; } public GenjuOfTheFens ( final GenjuOfTheFens card )  { super ( card ) ; } @Override public GenjuOfTheFens copy (  )  { return new GenjuOfTheFens ( this ) ; } private class SpiritToken extends Token { SpiritToken (  )  { super ( "Spirit", "2/2 black Spirit creature with \"{B}: This creature gets +1/+1 until end of turn . \"" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 2 ) ; addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , new ManaCostsImpl ( "{B}" )  )  ) ; } } } 
public class GenjuOfTheFields extends CardImpl { private static final FilterLandPermanent FILTER = new FilterLandPermanent ( "Plains" ) ; static { FILTER . add ( new SubtypePredicate ( "Plains" )  ) ; } public GenjuOfTheFields ( UUID ownerId )  { super ( ownerId, 5, "Genju of the Fields", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent ( FILTER ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . PutCreatureInPlay )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Effect effect = new BecomesCreatureAttachedEffect ( new SpiritToken (  ) , "Until end of turn, enchanted Plains becomes a 2/5 white Spirit creature", Duration . EndOfTurn ) ; Ability ability2 = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new GenericManaCost ( 2 )  ) ; effect = new GainAbilityAttachedEffect ( new DealsDamageGainLifeSourceTriggeredAbility (  ) , AttachmentType . AURA, Duration . EndOfTurn ) ; effect . setText ( "with \"Whenever this creature deals damage, its controller gains that much life . \" .  It's still a land" ) ; ability2 . addEffect ( effect ) ; this . addAbility ( ability2 ) ; Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandSourceEffect ( false, true ) , "enchanted Plains", true, false ) ; this . addAbility ( ability3 ) ; } public GenjuOfTheFields ( final GenjuOfTheFields card )  { super ( card ) ; } @Override public GenjuOfTheFields copy (  )  { return new GenjuOfTheFields ( this ) ; } private class SpiritToken extends Token { SpiritToken (  )  { super ( "Spirit", "2/5 white Spirit creature" ) ; cardType . add ( CardType . CREATURE ) ; color . setWhite ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 5 ) ; } } } 
public class GenjuOfTheRealm extends CardImpl { private static final FilterLandPermanent FILTER = new FilterLandPermanent (  ) ; public GenjuOfTheRealm ( UUID ownerId )  { super ( ownerId, 151, "Genju of the Realm", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{W}{U}{B}{R}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; this . supertype . add ( "Legendary" ) ; TargetPermanent auraTarget = new TargetLandPermanent ( FILTER ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . PutCreatureInPlay )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability ability2 = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureAttachedEffect ( new SpiritToken (  ) , "Enchanted land becomes a legendary 8/12 Spirit creature with trample until end of turn .  It's still a land", Duration . EndOfTurn ) , new GenericManaCost ( 2 )  ) ; this . addAbility ( ability2 ) ; Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandSourceEffect ( false, true ) , "enchanted land", true, false ) ; this . addAbility ( ability3 ) ; } public GenjuOfTheRealm ( final GenjuOfTheRealm card )  { super ( card ) ; } @Override public GenjuOfTheRealm copy (  )  { return new GenjuOfTheRealm ( this ) ; } private class SpiritToken extends Token { SpiritToken (  )  { super ( "Spirit", "legendary 8/12 Spirit creature with trample" ) ; supertype . add ( "Legendary" ) ; cardType . add ( CardType . CREATURE ) ; this . color . setWhite ( true ) ; this . color . setBlue ( true ) ; this . color . setBlack ( true ) ; this . color . setRed ( true ) ; this . color . setGreen ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 8 ) ; toughness = new MageInt ( 12 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; } } } 
public class GenjuOfTheSpires extends CardImpl { private static final FilterLandPermanent FILTER = new FilterLandPermanent ( "Mountain" ) ; static { FILTER . add ( new SubtypePredicate ( "Mountain" )  ) ; } public GenjuOfTheSpires ( UUID ownerId )  { super ( ownerId, 105, "Genju of the Spires", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent ( FILTER ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . PutCreatureInPlay )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability ability2 = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureAttachedEffect ( new SpiritToken (  ) , "Enchanted Mountain becomes a 6/1 red Spirit creature until end of turn .  It's still a land", Duration . EndOfTurn ) , new GenericManaCost ( 2 )  ) ; this . addAbility ( ability2 ) ; Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandSourceEffect ( false, true ) , "enchanted Mountain", true, false ) ; this . addAbility ( ability3 ) ; } public GenjuOfTheSpires ( final GenjuOfTheSpires card )  { super ( card ) ; } @Override public GenjuOfTheSpires copy (  )  { return new GenjuOfTheSpires ( this ) ; } private class SpiritToken extends Token { SpiritToken (  )  { super ( "Spirit", "6/1 red Spirit creature" ) ; cardType . add ( CardType . CREATURE ) ; color . setRed ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 6 ) ; toughness = new MageInt ( 1 ) ; } } } 
public class GnarledMass extends CardImpl { public GnarledMass ( UUID ownerId )  { super ( ownerId, 127, "Gnarled Mass", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; } public GnarledMass ( final GnarledMass card )  { super ( card ) ; } @Override public GnarledMass copy (  )  { return new GnarledMass ( this ) ; } } 
public class GoblinCohort extends CardImpl { public GoblinCohort ( UUID ownerId )  { super ( ownerId, 106, "Goblin Cohort", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GoblinCohortEffect (  )  ) , new PlayerCastCreatureWatcher (  )  ) ; } public GoblinCohort ( final GoblinCohort card )  { super ( card ) ; } @Override public GoblinCohort copy (  )  { return new GoblinCohort ( this ) ; } } class GoblinCohortEffect extends RestrictionEffect { public GoblinCohortEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "{this} can't attack unless you've cast a creature spell this turn"; } public GoblinCohortEffect ( final GoblinCohortEffect effect )  { super ( effect ) ; } @Override public GoblinCohortEffect copy (  )  { return new GoblinCohortEffect ( this ) ; } @Override public boolean canAttack ( Game game )  { return false; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { if  ( permanent . getId (  )  . equals ( source . getSourceId (  )  )  )  { PlayerCastCreatureWatcher watcher =  ( PlayerCastCreatureWatcher )  game . getState (  )  . getWatchers (  )  . get ( "PlayerCastCreature" ) ; if  ( watcher != null && !watcher . playerDidCastCreatureThisTurn ( source . getControllerId (  )  )  )  { return true; } } return false; } } 
public class GodsEyeGateToTheReikai extends CardImpl { public GodsEyeGateToTheReikai ( UUID ownerId )  { super ( ownerId, 164, "Gods' Eye, Gate to the Reikai", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; this . addAbility ( new PutIntoGraveFromBattlefieldSourceTriggeredAbility ( new CreateTokenEffect ( new SpiritToken (  ) , 1 ) , false )  ) ; } public GodsEyeGateToTheReikai ( final GodsEyeGateToTheReikai card )  { super ( card ) ; } @Override public GodsEyeGateToTheReikai copy (  )  { return new GodsEyeGateToTheReikai ( this ) ; } } 
public class GoryosVengeance extends CardImpl { private static final FilterCard filter = new FilterCard ( "legendary creature card" ) ; static { filter . add ( new SupertypePredicate ( "Legendary" )  ) ; } public GoryosVengeance ( UUID ownerId )  { super ( ownerId, 67, "Goryo's Vengeance", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{1}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new GoryosVengeanceEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( filter )  ) ; this . addAbility ( new SpliceOntoArcaneAbility ( "{2}{B}" )  ) ; } public GoryosVengeance ( final GoryosVengeance card )  { super ( card ) ; } @Override public GoryosVengeance copy (  )  { return new GoryosVengeance ( this ) ; } } class GoryosVengeanceEffect extends OneShotEffect { public GoryosVengeanceEffect (  )  { super ( Outcome . PutCardInPlay ) ; this . staticText = "Return target legendary creature card from your graveyard to the battlefield .  That creature gains haste .  Exile it at the beginning of the next end step"; } public GoryosVengeanceEffect ( final GoryosVengeanceEffect effect )  { super ( effect ) ; } @Override public GoryosVengeanceEffect copy (  )  { return new GoryosVengeanceEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Card card = game . getCard ( targetPointer . getFirst ( game, source )  ) ; if  ( card != null )  { if  ( controller . moveCards ( card, Zone . BATTLEFIELD, source, game )  )  { Permanent permanent = game . getPermanent ( card . getId (  )  ) ; if  ( permanent != null )  { ContinuousEffect effect = new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . Custom ) ; effect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; game . addEffect ( effect, source ) ; Effect exileEffect = new ExileTargetEffect ( "Exile " + permanent . getName (  )  + " at the beginning of the next end step" ) ; exileEffect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( exileEffect ) ; delayedAbility . setSourceId ( source . getSourceId (  )  ) ; delayedAbility . setControllerId ( source . getControllerId (  )  ) ; delayedAbility . setSourceObject ( source . getSourceObject ( game ) , game ) ; game . addDelayedTriggeredAbility ( delayedAbility ) ; return true; } } } } return false; } } 
public class HeartOfLight extends CardImpl { public HeartOfLight ( UUID ownerId )  { super ( ownerId, 6, "Heart of Light", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new HeartOfLightEffect (  )  )  ) ; } public HeartOfLight ( final HeartOfLight card )  { super ( card ) ; } @Override public HeartOfLight copy (  )  { return new HeartOfLight ( this ) ; } } class HeartOfLightEffect extends PreventionEffectImpl { public HeartOfLightEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "Prevent all damage that would be dealt to and dealt by enchanted creature"; } public HeartOfLightEffect ( final HeartOfLightEffect effect )  { super ( effect ) ; } @Override public HeartOfLightEffect copy (  )  { return new HeartOfLightEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { GameEvent preventEvent = new GameEvent ( GameEvent . EventType . PREVENT_DAMAGE, source . getFirstTarget (  ) , source . getSourceId (  ) , source . getControllerId (  ) , event . getAmount (  ) , false ) ; if  ( !game . replaceEvent ( preventEvent )  )  { int damage = event . getAmount (  ) ; event . setAmount ( 0 ) ; game . fireEvent ( GameEvent . getEvent ( GameEvent . EventType . PREVENTED_DAMAGE, source . getFirstTarget (  ) , source . getSourceId (  ) , source . getControllerId (  ) , damage )  ) ; } return false; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( super . applies ( event, source, game )  && event instanceof DamageEvent )  { Permanent aura = game . getPermanent ( source . getSourceId (  )  ) ; if  ( aura != null && aura . getAttachedTo (  )  != null )  { if  ( event . getSourceId (  )  . equals ( aura . getAttachedTo (  )  )  || event . getTargetId (  )  . equals ( aura . getAttachedTo (  )  )  )  { return true; } } } return false; } } 
public class HeedTheMists extends CardImpl { public HeedTheMists ( UUID ownerId )  { super ( ownerId, 36, "Heed the Mists", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new HeedTheMistsEffect (  )  ) ; } public HeedTheMists ( final HeedTheMists card )  { super ( card ) ; } @Override public HeedTheMists copy (  )  { return new HeedTheMists ( this ) ; } private class HeedTheMistsEffect extends OneShotEffect { public HeedTheMistsEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Put the top card of your library into your graveyard, then draw cards equal to that card's converted mana cost"; } public HeedTheMistsEffect ( HeedTheMistsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { boolean result = false; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Card card = controller . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { int cmc = card . getManaCost (  )  . convertedManaCost (  ) ; controller . moveCards ( card, Zone . LIBRARY, Zone . GRAVEYARD, source, game ) ; controller . drawCards ( cmc, game ) ; } } return result; } @Override public HeedTheMistsEffect copy (  )  { return new HeedTheMistsEffect ( this ) ; } } } 
public class HerosDemise extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "legendary creature" ) ; static { filter . add ( new SupertypePredicate ( "Legendary" )  ) ; } public HerosDemise ( UUID ownerId )  { super ( ownerId, 68, "Hero's Demise", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{1}{B}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public HerosDemise ( final HerosDemise card )  { super ( card ) ; } @Override public HerosDemise copy (  )  { return new HerosDemise ( this ) ; } } 
public class HigureTheStillWind extends CardImpl { private static final FilterCard filter = new FilterCard ( "Ninja card" ) ; private static final FilterCreaturePermanent filterCreature = new FilterCreaturePermanent ( "Ninja creature" ) ; static { filter . add (  ( new SubtypePredicate ( "Ninja" )  )  ) ; filterCreature . add (  ( new SubtypePredicate ( "Ninja" )  )  ) ; } public HigureTheStillWind ( UUID ownerId )  { super ( ownerId, 37, "Higure, the Still Wind", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Ninja" ) ; this . supertype . add ( "Legendary" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{2}{U}{U}" )  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( filter )  ) , true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBeBlockedTargetEffect (  ) , new GenericManaCost ( 2 )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filterCreature )  ) ; this . addAbility ( ability ) ; } public HigureTheStillWind ( final HigureTheStillWind card )  { super ( card ) ; } @Override public HigureTheStillWind copy (  )  { return new HigureTheStillWind ( this ) ; } } 
public class HiredMuscle extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public HiredMuscle ( UUID ownerId )  { super ( ownerId, 69, "Hired Muscle", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . flipCard = true; this . flipCardName = "Scarmaker"; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; this . addAbility ( new ConditionalTriggeredAbility (  new OnEventTriggeredAbility ( GameEvent . EventType . END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect ( new Scarmaker (  )  )  ) , new SourceHasCounterCondition ( CounterType . KI, 2, Integer . MAX_VALUE ) , "At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it . " )  ) ; } public HiredMuscle ( final HiredMuscle card )  { super ( card ) ; } @Override public HiredMuscle copy (  )  { return new HiredMuscle ( this ) ; } } class Scarmaker extends Token { Scarmaker (  )  { super ( "Scarmaker", "" ) ; supertype . add ( "Legendary" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 4 ) ; toughness = new MageInt ( 4 ) ; Ability ability = new SimpleActivatedAbility (  Zone . BATTLEFIELD, new GainAbilityTargetEffect ( FearAbility . getInstance (  ) , Duration . EndOfTurn ) , new RemoveCountersSourceCost ( CounterType . KI . createInstance (  )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } } 
public class HokoriDustDrinker extends CardImpl { public HokoriDustDrinker ( UUID ownerId )  { super ( ownerId, 7, "Hokori, Dust Drinker", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DontUntapInControllersUntapStepAllEffect ( Duration . WhileOnBattlefield, TargetController . ANY, new FilterLandPermanent ( "Lands" )  )  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new HokoriDustDrinkerUntapEffect (  ) , TargetController . ANY, false )  ) ; } public HokoriDustDrinker ( final HokoriDustDrinker card )  { super ( card ) ; } @Override public HokoriDustDrinker copy (  )  { return new HokoriDustDrinker ( this ) ; } } class HokoriDustDrinkerUntapEffect extends OneShotEffect { public HokoriDustDrinkerUntapEffect (  )  { super ( Outcome . Untap ) ; this . staticText = "that player untaps a land he or she controls"; } public HokoriDustDrinkerUntapEffect ( final HokoriDustDrinkerUntapEffect effect )  { super ( effect ) ; } @Override public HokoriDustDrinkerUntapEffect copy (  )  { return new HokoriDustDrinkerUntapEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( game . getActivePlayerId (  )  ) ; FilterLandPermanent filter = new FilterLandPermanent ( "land you control" ) ; filter . add ( new ControllerIdPredicate ( game . getActivePlayerId (  )  )  ) ; Target target = new TargetLandPermanent ( filter ) ; if  ( player != null && player . chooseTarget ( Outcome . Untap, target, source, game )  )  { for  ( UUID landId : target . getTargets (  )  )  { Permanent land = game . getPermanent ( landId ) ; if  ( land != null )  { land . untap ( game ) ; } } return true; } return false; } } 
public class HorobisWhisper extends CardImpl { private static final FilterCreaturePermanent filterTarget = new FilterCreaturePermanent ( "nonblack creature" ) ; private static final FilterLandPermanent filterCondition = new FilterLandPermanent ( "Swamp" ) ; static { filterTarget . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; filterCondition . add ( new SubtypePredicate ( "Swamp" )  ) ; } public HorobisWhisper ( UUID ownerId )  { super ( ownerId, 70, "Horobi's Whisper", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect ( new DestroyTargetEffect (  ) , new PermanentsOnTheBattlefieldCondition ( filterCondition ) ,"If you control a Swamp, destroy target nonblack creature" )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filterTarget )   ) ; this . addAbility ( new SpliceOntoArcaneAbility ( new ExileFromGraveCost ( new TargetCardInYourGraveyard ( 4,4, new FilterCard ( "cards" )  )  )  )  ) ; } public HorobisWhisper ( final HorobisWhisper card )  { super ( card ) ; } @Override public HorobisWhisper copy (  )  { return new HorobisWhisper ( this ) ; } } 
public class HundredTalonStrike extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped white creature you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; filter . add ( new ColorPredicate ( ObjectColor . WHITE )  ) ; } public HundredTalonStrike ( UUID ownerId )  { super ( ownerId, 8, "Hundred-Talon Strike", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; Effect effect = new BoostTargetEffect ( 1,0, Duration . EndOfTurn ) ; effect . setText ( "Target creature gets +1/+0" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; effect = new GainAbilityTargetEffect ( FirstStrikeAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains first strike until end of turn" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new SpliceOntoArcaneAbility ( new TapTargetCost ( new TargetControlledCreaturePermanent ( 1,1,filter,false )  )  )  ) ; } public HundredTalonStrike ( final HundredTalonStrike card )  { super ( card ) ; } @Override public HundredTalonStrike copy (  )  { return new HundredTalonStrike ( this ) ; } } 
public class IndebtedSamurai extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "a Samurai you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; filter . add ( new SubtypePredicate ( "Samurai" )  ) ; } public IndebtedSamurai ( UUID ownerId )  { super ( ownerId, 9, "Indebted Samurai", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new BushidoAbility ( 1 )  ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , true, filter )  ) ; } public IndebtedSamurai ( final IndebtedSamurai card )  { super ( card ) ; } @Override public IndebtedSamurai copy (  )  { return new IndebtedSamurai ( this ) ; } } 
public class InkEyesServantOfOni extends CardImpl { public InkEyesServantOfOni ( UUID ownerId )  { super ( ownerId, 71, "Ink-Eyes, Servant of Oni", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Rat" ) ; this . subtype . add ( "Ninja" ) ; this . supertype . add ( "Legendary" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{3}{B}{B}" )  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new InkEyesServantOfOniEffect (  ) , true, true )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{1}{B}" )  )  ) ; } public InkEyesServantOfOni ( final InkEyesServantOfOni card )  { super ( card ) ; } @Override public InkEyesServantOfOni copy (  )  { return new InkEyesServantOfOni ( this ) ; } } class InkEyesServantOfOniEffect extends OneShotEffect { public InkEyesServantOfOniEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "you may put target creature card from that player's graveyard onto the battlefield under your control"; } public InkEyesServantOfOniEffect ( final InkEyesServantOfOniEffect effect )  { super ( effect ) ; } @Override public InkEyesServantOfOniEffect copy (  )  { return new InkEyesServantOfOniEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player damagedPlayer = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; Player you = game . getPlayer ( source . getControllerId (  )  ) ; FilterCard filter = new FilterCard ( "creature in that player's graveyard" ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; filter . add ( new OwnerIdPredicate ( damagedPlayer . getId (  )  )  ) ; TargetCardInGraveyard target = new TargetCardInGraveyard ( filter ) ; if  ( target . canChoose ( source . getSourceId (  ) , you . getId (  ) , game )  )  { if  ( you . chooseTarget ( Outcome . PutCreatureInPlay, target, source, game )  )  { Card card = game . getCard ( target . getFirstTarget (  )  ) ; if  ( card != null )  { card . putOntoBattlefield ( game, Zone . GRAVEYARD, id, you . getId (  )  ) ; return true; } } } return false; } } 
public class InTheWebOfWar extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "a creature" ) ; public InTheWebOfWar ( UUID ownerId )  { super ( ownerId, 108, "In the Web of War", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{R}{R}" ) ; this . expansionSetCode = "BOK"; Effect effect = new BoostTargetEffect ( 2,0, Duration . EndOfTurn ) ; effect . setText ( "it gets +2/+0" ) ; Ability ability = new EntersBattlefieldControlledTriggeredAbility ( Zone . BATTLEFIELD, effect, filter, false, SetTargetPointer . PERMANENT, null ) ; effect = new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains haste until end of turn" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public InTheWebOfWar ( final InTheWebOfWar card )  { super ( card ) ; } @Override public InTheWebOfWar copy (  )  { return new InTheWebOfWar ( this ) ; } } 
public class IreOfKaminari extends CardImpl { private static final FilterCard filter = new FilterCard ( "Arcane" ) ; static { filter . add ( new SubtypePredicate ( "Arcane" )  ) ; } public IreOfKaminari ( UUID ownerId )  { super ( ownerId, 109, "Ire of Kaminari", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( new CardsInControllerGraveyardCount ( filter )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public IreOfKaminari ( final IreOfKaminari card )  { super ( card ) ; } @Override public IreOfKaminari copy (  )  { return new IreOfKaminari ( this ) ; } } 
public class IsaoEnlightenedBushi extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Samurai" ) ; static { filter . add ( new SubtypePredicate ( "Samurai" )  ) ; } public IsaoEnlightenedBushi ( UUID ownerId )  { super ( ownerId, 129, "Isao, Enlightened Bushi", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new CantBeCounteredAbility (  )  ) ; this . addAbility ( new BushidoAbility ( 2 )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateTargetEffect (  ) , new GenericManaCost ( 2 )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public IsaoEnlightenedBushi ( final IsaoEnlightenedBushi card )  { super ( card ) ; } @Override public IsaoEnlightenedBushi copy (  )  { return new IsaoEnlightenedBushi ( this ) ; } } 
public class IshiIshiAkkiCrackshot extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public IshiIshiAkkiCrackshot ( UUID ownerId )  { super ( ownerId, 110, "Ishi-Ishi, Akki Crackshot", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SpellCastOpponentTriggeredAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 2, true, "that player" ) , filter, false, SetTargetPointer . PLAYER )  ) ; } public IshiIshiAkkiCrackshot ( final IshiIshiAkkiCrackshot card )  { super ( card ) ; } @Override public IshiIshiAkkiCrackshot copy (  )  { return new IshiIshiAkkiCrackshot ( this ) ; } } 
public class IwamoriOfTheOpenFist extends CardImpl { public IwamoriOfTheOpenFist ( UUID ownerId )  { super ( ownerId, 130, "Iwamori of the Open Fist", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Monk" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new IwamoriOfTheOpenFistEffect (  ) , false )  ) ; } public IwamoriOfTheOpenFist ( final IwamoriOfTheOpenFist card )  { super ( card ) ; } @Override public IwamoriOfTheOpenFist copy (  )  { return new IwamoriOfTheOpenFist ( this ) ; } } class IwamoriOfTheOpenFistEffect extends OneShotEffect { private static final FilterCard filter = new FilterCard ( "legendary creature card" ) ; static { filter . add ( new SupertypePredicate ( "Legendary" )  ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public IwamoriOfTheOpenFistEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "each opponent may put a legendary creature card from his or her hand onto the battlefield"; } public IwamoriOfTheOpenFistEffect ( final IwamoriOfTheOpenFistEffect effect )  { super ( effect ) ; } @Override public IwamoriOfTheOpenFistEffect copy (  )  { return new IwamoriOfTheOpenFistEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Cards cards = new CardsImpl (  ) ; for  ( UUID playerId : game . getOpponents ( controller . getId (  )  )  )  { Player opponent = game . getPlayer ( playerId ) ; Target target = new TargetCardInHand ( filter ) ; if  ( opponent != null && target . canChoose ( source . getSourceId (  ) , opponent . getId (  ) , game )  )  { if  ( opponent . chooseUse ( Outcome . PutCreatureInPlay, "Put a legendary creature card from your hand onto the battlefield?", source, game )  )  { if  ( target . chooseTarget ( Outcome . PutCreatureInPlay, opponent . getId (  ) , source, game )  )  { Card card = game . getCard ( target . getFirstTarget (  )  ) ; if  ( card != null )  { cards . add ( card ) ; } } } } } controller . moveCards ( cards . getCards ( game ) , Zone . BATTLEFIELD, source, game, false, false, true, null ) ; return true; } return false; } } 
public class JettingGlasskite extends CardImpl { public JettingGlasskite ( UUID ownerId )  { super ( ownerId, 38, "Jetting Glasskite", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new JettingGlasskiteAbility (  )  ) ; } public JettingGlasskite ( final JettingGlasskite card )  { super ( card ) ; } @Override public JettingGlasskite copy (  )  { return new JettingGlasskite ( this ) ; } } class JettingGlasskiteAbility extends TriggeredAbilityImpl { protected int turnUsed; public JettingGlasskiteAbility (  )  { super ( Zone . BATTLEFIELD, new CounterTargetEffect (  ) , false ) ; } public JettingGlasskiteAbility ( final JettingGlasskiteAbility ability )  { super ( ability ) ; turnUsed = ability . turnUsed; } @Override public JettingGlasskiteAbility copy (  )  { return new JettingGlasskiteAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TARGETED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( this . getSourceId (  )  )  && game . getTurnNum (  )  > turnUsed )  { this . getTargets (  )  . clear (  ) ; TargetStackObject target = new TargetStackObject (  ) ; target . add ( event . getSourceId (  ) , game ) ; this . addTarget ( target ) ; turnUsed = game . getTurnNum (  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} becomes the target of a spell or ability for the first time in a turn, counter that spell or ability . "; } } 
public class KaijinOfTheVanishingTouch extends CardImpl { public KaijinOfTheVanishingTouch ( UUID ownerId )  { super ( ownerId, 39, "Kaijin of the Vanishing Touch", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; Effect effect = new ReturnToHandTargetEffect (  ) ; effect . setText ( "return that creature to its owner's hand at end of combat" ) ; this . addAbility ( new BlocksCreatureTriggeredAbility ( new CreateDelayedTriggeredAbilityEffect (  new AtTheEndOfCombatDelayedTriggeredAbility ( effect )  ) , false, true )  ) ; } public KaijinOfTheVanishingTouch ( final KaijinOfTheVanishingTouch card )  { super ( card ) ; } @Override public KaijinOfTheVanishingTouch copy (  )  { return new KaijinOfTheVanishingTouch ( this ) ; } } 
public class KamiOfFalseHope extends CardImpl { public KamiOfFalseHope ( UUID ownerId )  { super ( ownerId, 10, "Kami of False Hope", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventAllDamageByAllEffect ( Duration . EndOfTurn, true ) , new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public KamiOfFalseHope ( final KamiOfFalseHope card )  { super ( card ) ; } @Override public KamiOfFalseHope copy (  )  { return new KamiOfFalseHope ( this ) ; } } 
public class KentaroTheSmilingCat extends CardImpl { public KentaroTheSmilingCat ( UUID ownerId )  { super ( ownerId, 13, "Kentaro, the Smiling Cat", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BushidoAbility ( 1 )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new KentaroTheSmilingCatCastingEffect (  )  )  ) ; } public KentaroTheSmilingCat ( final KentaroTheSmilingCat card )  { super ( card ) ; } @Override public KentaroTheSmilingCat copy (  )  { return new KentaroTheSmilingCat ( this ) ; } } class KentaroTheSmilingCatCastingEffect extends ContinuousEffectImpl { private static final FilterCard filterSamurai = new FilterCard (  ) ; static { filterSamurai . add ( new SubtypePredicate ( "Samurai" )  ) ; } static final AlternativeCostSourceAbility alternativeCastingCostAbility = new AlternativeCostSourceAbility (  SourceIsSpellCondition . getInstance (  ) , null, filterSamurai, true, new ColorlessConvertedManaCost (  )  ) ; public KentaroTheSmilingCatCastingEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "You may pay {X} rather than pay the mana cost for Samurai spells you cast, where X is that spell's converted mana cost"; } public KentaroTheSmilingCatCastingEffect ( final KentaroTheSmilingCatCastingEffect effect )  { super ( effect ) ; } @Override public KentaroTheSmilingCatCastingEffect copy (  )  { return new KentaroTheSmilingCatCastingEffect ( this ) ; } @Override public boolean apply ( Layer layer, SubLayer sublayer, Ability source, Game game )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { controller . getAlternativeSourceCosts (  )  . add ( alternativeCastingCostAbility ) ; return true; } return false; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean hasLayer ( Layer layer )  { return layer == Layer . RulesEffects; } } class ColorlessConvertedManaCost implements DynamicCost { @Override public Cost getCost ( Ability ability, Game game )  { return new GenericManaCost ( ability . getManaCosts (  )  . convertedManaCost (  )  ) ; } @Override public String getText ( Ability ability, Game game )  { return "Pay " + getCost ( ability, game )  . getText (  )  + " rather than " + ability . getManaCosts (  )  . getText (  )  + " for Samurai card?"; } } 
public class KiraGreatGlassSpinner extends CardImpl { public KiraGreatGlassSpinner ( UUID ownerId )  { super ( ownerId, 40, "Kira, Great Glass-Spinner", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . supertype . add ( "Legendary" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Effect effect = new CounterTargetEffect (  ) ; effect . setText ( "counter that spell or ability" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( new KiraGreatGlassSpinnerAbility ( effect ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent ( "Creatures you control" )  )  ) , new CreatureWasTargetedThisTurnWatcher (  )  ) ; } public KiraGreatGlassSpinner ( final KiraGreatGlassSpinner card )  { super ( card ) ; } @Override public KiraGreatGlassSpinner copy (  )  { return new KiraGreatGlassSpinner ( this ) ; } } class KiraGreatGlassSpinnerAbility extends TriggeredAbilityImpl { public KiraGreatGlassSpinnerAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect, false ) ; } public KiraGreatGlassSpinnerAbility ( final KiraGreatGlassSpinnerAbility ability )  { super ( ability ) ; } @Override public KiraGreatGlassSpinnerAbility copy (  )  { return new KiraGreatGlassSpinnerAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TARGETED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( this . getSourceId (  )  )  )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null && permanent . getCardType (  )  . contains ( CardType . CREATURE )  )  { CreatureWasTargetedThisTurnWatcher watcher =  ( CreatureWasTargetedThisTurnWatcher )  game . getState (  )  . getWatchers (  )  . get ( "CreatureWasTargetedThisTurn" ) ; if  ( watcher != null && watcher . notMoreThanOnceTargetedThisTurn ( permanent, game )  )  { for  ( Effect effect : getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( event . getSourceId (  )  )  ) ; } return true; } } } return false; } @Override public String getRule (  )  { return "Whenever this creature becomes the target of a spell or ability for the first time in a turn, counter that spell or ability . "; } } class CreatureWasTargetedThisTurnWatcher extends Watcher { private final Map<MageObjectReference, Integer> creaturesTargeted = new HashMap<> (  ) ; public CreatureWasTargetedThisTurnWatcher (  )  { super ( "CreatureWasTargetedThisTurn", WatcherScope . GAME ) ; } public CreatureWasTargetedThisTurnWatcher ( final CreatureWasTargetedThisTurnWatcher watcher )  { super ( watcher ) ; this . creaturesTargeted . putAll ( creaturesTargeted ) ; } @Override public void watch ( GameEvent event, Game game )  { if  ( event . getType (  )  == GameEvent . EventType . TARGETED )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null && permanent . getCardType (  )  . contains ( CardType . CREATURE )  )  { MageObjectReference mor = new MageObjectReference ( permanent, game ) ; int amount = 0; if  ( creaturesTargeted . containsKey ( mor )  )  { amount = creaturesTargeted . get ( mor ) ; } creaturesTargeted . put ( mor, ++amount ) ; } } } public boolean notMoreThanOnceTargetedThisTurn ( Permanent creature, Game game )  { if  ( creaturesTargeted . containsKey ( new MageObjectReference ( creature, game )  )  )  { return creaturesTargeted . get ( new MageObjectReference ( creature, game )  )  < 2; } return true; } @Override public void reset (  )  { super . reset (  ) ; creaturesTargeted . clear (  ) ; } @Override public CreatureWasTargetedThisTurnWatcher copy (  )  { return new CreatureWasTargetedThisTurnWatcher ( this ) ; } } 
public class KitsunePalliator extends CardImpl { public KitsunePalliator ( UUID ownerId )  { super ( ownerId, 14, "Kitsune Palliator", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Fox" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new KitsunePalliatorEffect (  ) , new TapSourceCost (  )  )  ) ; } public KitsunePalliator ( final KitsunePalliator card )  { super ( card ) ; } @Override public KitsunePalliator copy (  )  { return new KitsunePalliator ( this ) ; } } class KitsunePalliatorEffect extends OneShotEffect { public KitsunePalliatorEffect (  )  { super ( Outcome . PreventDamage ) ; this . staticText = "Prevent the next 1 damage that would be dealt to each creature and each player this turn"; } public KitsunePalliatorEffect ( final KitsunePalliatorEffect effect )  { super ( effect ) ; } @Override public KitsunePalliatorEffect copy (  )  { return new KitsunePalliatorEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { PreventDamageToTargetEffect effect = new PreventDamageToTargetEffect ( Duration . EndOfTurn, 1 ) ; List<Permanent> permanents = game . getBattlefield (  )  . getActivePermanents ( new FilterCreaturePermanent (  ) , source . getControllerId (  ) , game ) ; for  ( Permanent permanent: permanents )  { effect . setTargetPointer ( new FixedTarget ( permanent . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } for  ( UUID playerId: game . getState (  )  . getPlayersInRange ( source . getControllerId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { effect . setTargetPointer ( new FixedTarget ( player . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } } return false; } } 
public class KodamaOfTheCenterTree extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "Spirits you control" ) ; static { filter . add ( new SubtypePredicate ( "Spirit" )  ) ; } public KodamaOfTheCenterTree ( UUID ownerId )  { super ( ownerId, 131, "Kodama of the Center Tree", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new SetPowerToughnessSourceEffect ( new PermanentsOnBattlefieldCount ( filter ) , Duration . EndOfGame )  )  ) ; this . addAbility ( new SoulshiftAbility ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public KodamaOfTheCenterTree ( final KodamaOfTheCenterTree card )  { super ( card ) ; } @Override public KodamaOfTheCenterTree copy (  )  { return new KodamaOfTheCenterTree ( this ) ; } } 
public class KumanosBlessing extends CardImpl { public KumanosBlessing ( UUID ownerId )  { super ( ownerId, 111, "Kumano's Blessing", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Benefit )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new KumanosBlessingEffect (  )  ) , new DamagedByEnchantedWatcher (  )  ) ; } public KumanosBlessing ( final KumanosBlessing card )  { super ( card ) ; } @Override public KumanosBlessing copy (  )  { return new KumanosBlessing ( this ) ; } } class KumanosBlessingEffect extends ReplacementEffectImpl { public KumanosBlessingEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Exile ) ; staticText = "If a creature dealt damage by enchanted creature this turn would die, exile it instead"; } public KumanosBlessingEffect ( final KumanosBlessingEffect effect )  { super ( effect ) ; } @Override public KumanosBlessingEffect copy (  )  { return new KumanosBlessingEffect ( this ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { Permanent permanent =  (  ( ZoneChangeEvent ) event )  . getTarget (  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null && permanent != null )  { return controller . moveCardToExileWithInfo ( permanent, null, null, source . getSourceId (  ) , game, Zone . BATTLEFIELD, true ) ; } return false; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { ZoneChangeEvent zce =  ( ZoneChangeEvent )  event; if  ( zce . isDiesEvent (  )  )  { DamagedByEnchantedWatcher watcher =  ( DamagedByEnchantedWatcher )  game . getState (  )  . getWatchers (  )  . get ( "DamagedByEnchantedWatcher", source . getSourceId (  )  ) ; if  ( watcher != null )  { return watcher . wasDamaged ( zce . getTarget (  ) , game ) ; } } return false; } } class DamagedByEnchantedWatcher extends Watcher { private final Set<MageObjectReference> damagedCreatures = new HashSet<> (  ) ; public DamagedByEnchantedWatcher (  )  { super ( "DamagedByEnchantedWatcher", WatcherScope . CARD ) ; } public DamagedByEnchantedWatcher ( final DamagedByEnchantedWatcher watcher )  { super ( watcher ) ; this . damagedCreatures . addAll ( watcher . damagedCreatures ) ; } @Override public DamagedByEnchantedWatcher copy (  )  { return new DamagedByEnchantedWatcher ( this ) ; } @Override public void watch ( GameEvent event, Game game )  { if  ( event . getType (  )  == EventType . DAMAGED_CREATURE )  { Permanent enchantment = game . getPermanent ( this . getSourceId (  )  ) ; if  ( enchantment != null && enchantment . getAttachedTo (  )  != null )  { if  ( enchantment . getAttachedTo (  )  . equals ( event . getSourceId (  )  )  )  { MageObjectReference mor = new MageObjectReference ( event . getTargetId (  ) , game ) ; if  ( !damagedCreatures . contains ( mor )  )  { damagedCreatures . add ( mor ) ; } } } } } @Override public void reset (  )  { super . reset (  ) ; damagedCreatures . clear (  ) ; } public boolean wasDamaged ( Permanent permanent, Game game )  { return damagedCreatures . contains ( new MageObjectReference ( permanent, game )  ) ; } } 
public class KyokiSanitysEclipse extends CardImpl { public KyokiSanitysEclipse ( UUID ownerId )  { super ( ownerId, 72, "Kyoki, Sanity's Eclipse", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Demon" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new SpellCastControllerTriggeredAbility ( new ExileFromZoneTargetEffect ( Zone . HAND, null, "", new FilterCard (  )  ) , new FilterSpiritOrArcaneCard (  ) , false ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public KyokiSanitysEclipse ( final KyokiSanitysEclipse card )  { super ( card ) ; } @Override public KyokiSanitysEclipse copy (  )  { return new KyokiSanitysEclipse ( this ) ; } } 
public class Lifegift extends CardImpl { public Lifegift ( UUID ownerId )  { super ( ownerId, 132, "Lifegift", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}" ) ; this . expansionSetCode = "BOK"; this . addAbility ( new EntersBattlefieldAllTriggeredAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 1 ) , new FilterLandPermanent ( "a land" ) , true )  ) ; } public Lifegift ( final Lifegift card )  { super ( card ) ; } @Override public Lifegift copy (  )  { return new Lifegift ( this ) ; } } 
public class Lifespinner extends CardImpl { private static final FilterPermanentCard filter = new FilterPermanentCard ( "legendary Spirit permanent card" ) ; static { filter . add ( new SupertypePredicate ( "Legendary" )  ) ; filter . add ( new SubtypePredicate ( "Spirit" )  ) ; } public Lifespinner ( UUID ownerId )  { super ( ownerId, 133, "Lifespinner", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; SimpleActivatedAbility ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SearchLibraryPutInPlayEffect ( new TargetCardInLibrary ( filter )  ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( 3, 3, new FilterControlledCreaturePermanent ( "Spirit", "three Spirits" ) , false )  )  ) ; this . addAbility ( ability ) ; } public Lifespinner ( final Lifespinner card )  { super ( card ) ; } @Override public Lifespinner copy (  )  { return new Lifespinner ( this ) ; } } 
public class LoamDweller extends CardImpl { public LoamDweller ( UUID ownerId )  { super ( ownerId, 134, "Loam Dweller", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new PutLandFromHandOntoBattlefieldEffect ( true ) , new FilterSpiritOrArcaneCard (  ) , true )  ) ; } public LoamDweller ( final LoamDweller card )  { super ( card ) ; } @Override public LoamDweller copy (  )  { return new LoamDweller ( this ) ; } } 
public class MannichiTheFeveredDream extends CardImpl { public MannichiTheFeveredDream ( UUID ownerId )  { super ( ownerId, 112, "Mannichi, the Fevered Dream", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SwitchPowerToughnessAllEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{1}{R}" )  )  ) ; } public MannichiTheFeveredDream ( final MannichiTheFeveredDream card )  { super ( card ) ; } @Override public MannichiTheFeveredDream copy (  )  { return new MannichiTheFeveredDream ( this ) ; } } 
public class MarkOfSakiko extends CardImpl { public MarkOfSakiko ( UUID ownerId )  { super ( ownerId, 135, "Mark of Sakiko", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Effect effect = new GainAbilityAttachedEffect ( new MarkOfSakikoTriggeredAbility (  ) , AttachmentType . AURA ) ; effect . setText ( "Enchanted creature has \"Whenever this creature deals combat damage to a player, add that much {G} to your mana pool .  Until end of turn, this mana doesn't empty from your mana pool as steps and phases end . \"" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public MarkOfSakiko ( final MarkOfSakiko card )  { super ( card ) ; } @Override public MarkOfSakiko copy (  )  { return new MarkOfSakiko ( this ) ; } } class MarkOfSakikoTriggeredAbility extends TriggeredAbilityImpl { public MarkOfSakikoTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, null, false ) ; } public MarkOfSakikoTriggeredAbility ( final MarkOfSakikoTriggeredAbility ability )  { super ( ability ) ; } @Override public MarkOfSakikoTriggeredAbility copy (  )  { return new MarkOfSakikoTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  (  (  ( DamagedEvent )  event )  . isCombatDamage (  )  )  { if  ( event . getSourceId (  )  . equals ( getSourceId (  )  )  )  { this . getEffects (  )  . clear (  ) ; Effect effect = new AddManaToManaPoolTargetControllerEffect ( new Mana ( 0,event . getAmount (  ) ,0,0,0,0,0, 0 ) , "that player", true ) ; effect . setTargetPointer ( new FixedTarget ( getControllerId (  )  )  ) ; effect . setText ( "add that much {G} to your mana pool .  Until end of turn, this mana doesn't empty from your mana pool as steps and phases end" ) ; this . addEffect ( effect ) ; return true; } } return false; } @Override public String getRule (  )  { return "Whenever this creature deals combat damage to a player, add that much {G} to your mana pool .  Until end of turn, this mana doesn't empty from your mana pool as steps and phases end . "; } } 
public class MarkOfTheOni extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "if you control no Demons" ) ; static { filter . add ( new SubtypePredicate ( "Demon" )  ) ; } public MarkOfTheOni ( UUID ownerId )  { super ( ownerId, 73, "Mark of the Oni", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . GainControl )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ControlEnchantedEffect (  )  )  ) ; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( Zone . BATTLEFIELD, new SacrificeSourceEffect (  ) , TargetController . ANY, new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . FEWER_THAN, 1 ) , false )  ) ; } public MarkOfTheOni ( final MarkOfTheOni card )  { super ( card ) ; } @Override public MarkOfTheOni copy (  )  { return new MarkOfTheOni ( this ) ; } } 
public class MatsuTribeSniper extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public MatsuTribeSniper ( UUID ownerId )  { super ( ownerId, 136, "Matsu-Tribe Sniper", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Snake" ) ; this . subtype . add ( "Warrior" ) ; this . subtype . add ( "Archer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; ability = new DealsDamageToACreatureTriggeredAbility ( new TapTargetEffect ( "that creature" ) , false, false, true ) ; ability . addEffect ( new DontUntapInControllersNextUntapStepTargetEffect ( "and it" )  ) ; this . addAbility ( ability ) ; } public MatsuTribeSniper ( final MatsuTribeSniper card )  { super ( card ) ; } @Override public MatsuTribeSniper copy (  )  { return new MatsuTribeSniper ( this ) ; } } 
public class MendingHands extends CardImpl { public MendingHands ( UUID ownerId )  { super ( ownerId, 15, "Mending Hands", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new PreventDamageToTargetEffect ( Duration . EndOfTurn, 4 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public MendingHands ( final MendingHands card )  { super ( card ) ; } @Override public MendingHands copy (  )  { return new MendingHands ( this ) ; } } 
public class MinamoSightbender extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with power X or less" ) ; private final UUID originalId; public MinamoSightbender ( UUID ownerId )  { super ( ownerId, 41, "Minamo Sightbender", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBeBlockedTargetEffect (  ) , new ManaCostsImpl ( "{X}" )  ) ; Target target = new TargetCreaturePermanent ( filter ) ; ability . addTarget ( target ) ; ability . addCost ( new TapSourceCost (  )  ) ; originalId = ability . getOriginalId (  ) ; this . addAbility ( ability ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability . getOriginalId (  )  . equals ( originalId )  )  { for  ( Effect effect : ability . getEffects (  )  )  { if  ( effect instanceof CantBeBlockedTargetEffect )  { int manaX = ability . getManaCostsToPay (  )  . getX (  ) ; ability . getTargets (  )  . clear (  ) ; FilterCreaturePermanent newFilter = new FilterCreaturePermanent ( new StringBuilder ( "creature with power " )  . append ( manaX )  . append ( " or less" )  . toString (  )  ) ; filter . add ( new PowerPredicate ( Filter . ComparisonType . LessThan, manaX + 1 )  ) ; Target target = new TargetCreaturePermanent ( newFilter ) ; ability . addTarget ( target ) ; break; } } } } public MinamoSightbender ( final MinamoSightbender card )  { super ( card ) ; this . originalId = card . originalId; } @Override public MinamoSightbender copy (  )  { return new MinamoSightbender ( this ) ; } } 
public class MinamosMeddling extends CardImpl { public MinamosMeddling ( UUID ownerId )  { super ( ownerId, 42, "Minamo's Meddling", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( new FilterSpell (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new MinamosMeddlingCounterTargetEffect (  )  ) ; } public MinamosMeddling ( final MinamosMeddling card )  { super ( card ) ; } @Override public MinamosMeddling copy (  )  { return new MinamosMeddling ( this ) ; } } class MinamosMeddlingCounterTargetEffect extends OneShotEffect { public MinamosMeddlingCounterTargetEffect (  )  { super ( Outcome . Benefit ) ; staticText = "Counter target spell .  That spell's controller reveals his or her hand, then discards each card with the same name as a card spliced onto that spell"; } public MinamosMeddlingCounterTargetEffect ( final MinamosMeddlingCounterTargetEffect effect )  { super ( effect ) ; } @Override public MinamosMeddlingCounterTargetEffect copy (  )  { return new MinamosMeddlingCounterTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( sourceObject != null )  { for  ( UUID targetId : getTargetPointer (  )  . getTargets ( game, source )   )  { Spell spell = game . getStack (  )  . getSpell ( targetId ) ; if  ( spell != null )  { game . getStack (  )  . counter ( targetId, source . getSourceId (  ) , game ) ; Player spellController = game . getPlayer ( spell . getControllerId (  )  ) ; if  ( spellController != null )  { spellController . revealCards ( sourceObject . getName (  ) , spellController . getHand (  ) , game ) ; Cards cardsToDiscard = new CardsImpl (  ) ; for  ( SpellAbility spellAbility : spell . getSpellAbilities (  )  )  { if  ( spellAbility . getSpellAbilityType (  )  . equals ( SpellAbilityType . SPLICE )  )  { for  ( Card card: spellController . getHand (  )  . getCards ( game )  )  { if  ( card . getName (  )  . equals ( spellAbility . getCardName (  )  )  && !cardsToDiscard . contains ( card . getId (  )  )  )  { cardsToDiscard . add ( card ) ; } } } } if  ( !cardsToDiscard . isEmpty (  )  )  { for  ( Card card :cardsToDiscard . getCards ( game )  )  { spellController . discard ( card, source, game ) ; } } } } } return true; } return false; } } 
public class MirrorGallery extends CardImpl { public MirrorGallery ( UUID ownerId )  { super ( ownerId, 154, "Mirror Gallery", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{5}" ) ; this . expansionSetCode = "BOK"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MirrorGalleryRuleEffect (  )  )  ) ; } public MirrorGallery ( final MirrorGallery card )  { super ( card ) ; } @Override public MirrorGallery copy (  )  { return new MirrorGallery ( this ) ; } } class MirrorGalleryRuleEffect extends ContinuousEffectImpl { public MirrorGalleryRuleEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Detriment ) ; staticText = "The \"legend rule\" doesn't apply"; } public MirrorGalleryRuleEffect ( final MirrorGalleryRuleEffect effect )  { super ( effect ) ; } @Override public MirrorGalleryRuleEffect copy (  )  { return new MirrorGalleryRuleEffect ( this ) ; } @Override public boolean apply ( Layer layer, SubLayer sublayer, Ability source, Game game )  { game . getState (  )  . setLegendaryRuleActive ( false ) ; return true; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean hasLayer ( Layer layer )  { return layer == Layer . RulesEffects; } } 
public class MistbladeShinobi extends CardImpl { public MistbladeShinobi ( UUID ownerId )  { super ( ownerId, 43, "Mistblade Shinobi", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Ninja" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{U}" )  )  ) ; this . addAbility ( new MistbladeShinobiTriggeredAbility (  )  ) ; } public MistbladeShinobi ( final MistbladeShinobi card )  { super ( card ) ; } @Override public MistbladeShinobi copy (  )  { return new MistbladeShinobi ( this ) ; } } class MistbladeShinobiTriggeredAbility extends TriggeredAbilityImpl { MistbladeShinobiTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new ReturnToHandTargetEffect (  ) , true ) ; } MistbladeShinobiTriggeredAbility ( final MistbladeShinobiTriggeredAbility ability )  { super ( ability ) ; } @Override public MistbladeShinobiTriggeredAbility copy (  )  { return new MistbladeShinobiTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  (  (  ( DamagedPlayerEvent )  event )  . isCombatDamage (  )  && event . getSourceId (  )  . equals ( sourceId )  )  { Player opponent = game . getPlayer ( event . getPlayerId (  )  ) ; if  ( opponent != null )  { FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature " + opponent . getLogName (  )  + " controls" ) ; filter . add ( new ControllerIdPredicate ( opponent . getId (  )  )  ) ; this . getTargets (  )  . clear (  ) ; this . addTarget ( new TargetCreaturePermanent ( filter )  ) ; return true; } } return false; } @Override public String getRule (  )  { return "Whenever {this} deals combat damage to a player, you may return target creature that player controls to its owner's hand . "; } } 
public class NezumiShadowWatcher extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Ninja" ) ; static { filter . add ( new SubtypePredicate ( "Ninja" )  ) ; } public NezumiShadowWatcher ( UUID ownerId )  { super ( ownerId, 74, "Nezumi Shadow-Watcher", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Rat" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public NezumiShadowWatcher ( final NezumiShadowWatcher card )  { super ( card ) ; } @Override public NezumiShadowWatcher copy (  )  { return new NezumiShadowWatcher ( this ) ; } } 
public class NinjaOfTheDeepHours extends CardImpl { public NinjaOfTheDeepHours ( UUID ownerId )  { super ( ownerId, 44, "Ninja of the Deep Hours", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Ninja" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{1}{U}" )  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , true, false )  ) ; } public NinjaOfTheDeepHours ( final NinjaOfTheDeepHours card )  { super ( card ) ; } @Override public NinjaOfTheDeepHours copy (  )  { return new NinjaOfTheDeepHours ( this ) ; } } 
public class NourishingShoal extends CardImpl { public NourishingShoal ( UUID ownerId )  { super ( ownerId, 137, "Nourishing Shoal", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{X}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; FilterOwnedCard filter = new FilterOwnedCard ( "a green card with converted mana cost X from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class OgreMarauder extends CardImpl { public OgreMarauder ( UUID ownerId )  { super ( ownerId, 75, "Ogre Marauder", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new AttacksTriggeredAbility ( new OgreMarauderEffect (  ) , false )  ) ; } public OgreMarauder ( final OgreMarauder card )  { super ( card ) ; } @Override public OgreMarauder copy (  )  { return new OgreMarauder ( this ) ; } } class OgreMarauderEffect extends OneShotEffect { public OgreMarauderEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "it gains \"{this} can't be blocked\" until end of turn unless defending player sacrifices a creature"; } public OgreMarauderEffect ( final OgreMarauderEffect effect )  { super ( effect ) ; } @Override public OgreMarauderEffect copy (  )  { return new OgreMarauderEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID defendingPlayerId = game . getCombat (  )  . getDefendingPlayerId ( source . getSourceId (  ) , game ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; Player defender = game . getPlayer ( defendingPlayerId ) ; if  ( defender != null && sourceObject != null )  { Cost cost = new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  ) ; if  ( cost . canPay ( source, source . getSourceId (  ) , defendingPlayerId, game )  && defender . chooseUse ( Outcome . LoseAbility, "Sacrifice a creature to prevent that " + sourceObject . getLogName (  )  + " can't be blocked?", source, game )  )  { if  ( !cost . pay ( source, game, source . getSourceId (  ) , defendingPlayerId, false, null )  )  { ContinuousEffect effect = new CantBeBlockedSourceEffect ( Duration . EndOfTurn ) ; game . addEffect ( effect, source ) ; } } return true; } return false; } } 
public class OgreRecluse extends CardImpl { public OgreRecluse ( UUID ownerId )  { super ( ownerId, 113, "Ogre Recluse", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SpellCastAllTriggeredAbility ( new TapSourceEffect (  ) , false )  ) ; } public OgreRecluse ( final OgreRecluse card )  { super ( card ) ; } @Override public OgreRecluse copy (  )  { return new OgreRecluse ( this ) ; } } 
public class OkibaGangShinobi extends CardImpl { public OkibaGangShinobi ( UUID ownerId )  { super ( ownerId, 76, "Okiba-Gang Shinobi", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Rat" ) ; this . subtype . add ( "Ninja" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{3}{B}" )  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new DiscardTargetEffect ( 2 ) , false, true )  ) ; } public OkibaGangShinobi ( final OkibaGangShinobi card )  { super ( card ) ; } @Override public OkibaGangShinobi copy (  )  { return new OkibaGangShinobi ( this ) ; } } 
public class OpalEyeKondasYojimbo extends CardImpl { public OpalEyeKondasYojimbo ( UUID ownerId )  { super ( ownerId, 17, "Opal-Eye, Konda's Yojimbo", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Fox" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( new BushidoAbility ( 1 )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new OpalEyeKondasYojimboRedirectionEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetSource (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToSourceEffect ( Duration . EndOfTurn, 1 ) , new ManaCostsImpl ( "{1}{W}" )  )  ) ; } public OpalEyeKondasYojimbo ( final OpalEyeKondasYojimbo card )  { super ( card ) ; } @Override public OpalEyeKondasYojimbo copy (  )  { return new OpalEyeKondasYojimbo ( this ) ; } } class OpalEyeKondasYojimboRedirectionEffect extends ReplacementEffectImpl { private final TargetSource target; OpalEyeKondasYojimboRedirectionEffect (  )  { super ( Duration . EndOfTurn, Outcome . RedirectDamage ) ; staticText = "The next time a source of your choice would deal damage this turn, that damage is dealt to {this} instead"; this . target = new TargetSource (  ) ; } OpalEyeKondasYojimboRedirectionEffect ( final OpalEyeKondasYojimboRedirectionEffect effect )  { super ( effect ) ; this . target = effect . target . copy (  ) ; } @Override public void init ( Ability source, Game game )  { this . target . choose ( Outcome . PreventDamage, source . getControllerId (  ) , source . getSourceId (  ) , game ) ; super . init ( source, game ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  . equals ( GameEvent . EventType . DAMAGE_CREATURE  )  || event . getType (  )  . equals ( GameEvent . EventType . DAMAGE_PLANESWALKER  )  || event . getType (  )  . equals ( GameEvent . EventType . DAMAGE_PLAYER  ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( event . getSourceId (  )  . equals ( target . getFirstTarget (  )  )  )  { MageObject object = game . getObject ( event . getSourceId (  )  ) ; if  ( object == null )  { game . informPlayers ( "Couldn't find source of damage" ) ; return false; } return true; } return false; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { DamageEvent damageEvent =  ( DamageEvent ) event; Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { Permanent targetPermanent = game . getPermanent ( event . getTargetId (  )  ) ; StringBuilder message = new StringBuilder (  ) ; message . append ( sourcePermanent . getName (  )  )  . append ( ": gets " ) ; message . append ( damageEvent . getAmount (  )  )  . append ( " damage redirected from " ) ; if  ( targetPermanent != null )  { message . append ( targetPermanent . getName (  )  ) ; } else { Player targetPlayer = game . getPlayer ( event . getTargetId (  )  ) ; if  ( targetPlayer != null )  { message . append ( targetPlayer . getLogName (  )  ) ; } else { message . append ( "unknown" ) ; } } game . informPlayers ( message . toString (  )  ) ; discard (  ) ; sourcePermanent . damage ( damageEvent . getAmount (  ) , damageEvent . getSourceId (  ) , game, damageEvent . isCombatDamage (  ) , damageEvent . isPreventable (  ) , event . getAppliedEffects (  )  ) ; return true; } return false; } @Override public OpalEyeKondasYojimboRedirectionEffect copy (  )  { return new OpalEyeKondasYojimboRedirectionEffect ( this ) ; } } 
public class OrbOfDreams extends CardImpl { public OrbOfDreams ( UUID ownerId )  { super ( ownerId, 156, "Orb of Dreams", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "BOK"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new OrbOfDreamsEffect (  )  )  ) ; } public OrbOfDreams ( final OrbOfDreams card )  { super ( card ) ; } @Override public OrbOfDreams copy (  )  { return new OrbOfDreams ( this ) ; } private class OrbOfDreamsEffect extends ReplacementEffectImpl { OrbOfDreamsEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Tap, false ) ; staticText = "Permanents enter the battlefield tapped"; } OrbOfDreamsEffect ( final OrbOfDreamsEffect effect )  { super ( effect ) ; } @Override public OrbOfDreamsEffect copy (  )  { return new OrbOfDreamsEffect ( this ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { Permanent permanent =  (  ( EntersTheBattlefieldEvent )  event )  . getTarget (  ) ; if  ( permanent != null )  { permanent . setTapped ( true ) ; } return false; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return true; } } } 
public class OrnateKanzashi extends CardImpl { public OrnateKanzashi ( UUID ownerId )  { super ( ownerId, 157, "Ornate Kanzashi", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{5}" ) ; this . expansionSetCode = "BOK"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new OrnateKanzashiEffect (  ) , new GenericManaCost ( 2 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public OrnateKanzashi ( final OrnateKanzashi card )  { super ( card ) ; } @Override public OrnateKanzashi copy (  )  { return new OrnateKanzashi ( this ) ; } } class OrnateKanzashiEffect extends OneShotEffect { public OrnateKanzashiEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "Target opponent exiles the top card of his or her library .  You may play that card this turn"; } public OrnateKanzashiEffect ( final OrnateKanzashiEffect effect )  { super ( effect ) ; } @Override public OrnateKanzashiEffect copy (  )  { return new OrnateKanzashiEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player opponent = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( sourceObject != null && opponent != null )  { if  ( opponent . getLibrary (  )  . size (  )  > 0 )  { Library library = opponent . getLibrary (  ) ; Card card = library . getFromTop ( game ) ; if  ( card != null )  { opponent . moveCardToExileWithInfo ( card, source . getSourceId (  ) , sourceObject . getName (  ) , source . getSourceId (  ) , game, Zone . LIBRARY, true ) ; ContinuousEffect effect = new OrnateKanzashiCastFromExileEffect (  ) ; effect . setTargetPointer ( new FixedTarget ( card . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } } return true; } return false; } } class OrnateKanzashiCastFromExileEffect extends AsThoughEffectImpl { public OrnateKanzashiCastFromExileEffect (  )  { super ( AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE, Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "You may play that card from exile this turn"; } public OrnateKanzashiCastFromExileEffect ( final OrnateKanzashiCastFromExileEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public OrnateKanzashiCastFromExileEffect copy (  )  { return new OrnateKanzashiCastFromExileEffect ( this ) ; } @Override public boolean applies ( UUID objectId, Ability source, UUID affectedControllerId, Game game )  { return source . getControllerId (  )  . equals ( affectedControllerId )  && objectId . equals ( getTargetPointer (  )  . getFirst ( game, source )  ) ; } } 
public class Overblaze extends CardImpl { public Overblaze ( UUID ownerId )  { super ( ownerId, 114, "Overblaze", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new FireServantEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( new SpliceOntoArcaneAbility ( "{2}{R}{R}" )  ) ; } public Overblaze ( final Overblaze card )  { super ( card ) ; } @Override public Overblaze copy (  )  { return new Overblaze ( this ) ; } } class FireServantEffect extends ReplacementEffectImpl { public FireServantEffect (  )  { super ( Duration . EndOfTurn, Outcome . Damage ) ; staticText = "Each time target permanent would deal damage to a creature or player this turn, it deals double that damage to that creature or player instead . "; } public FireServantEffect ( final FireServantEffect effect )  { super ( effect ) ; } @Override public FireServantEffect copy (  )  { return new FireServantEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  . equals ( GameEvent . EventType . DAMAGE_CREATURE )  || event . getType (  )  . equals ( GameEvent . EventType . DAMAGE_PLAYER ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getSourceId (  )  . equals ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { event . setAmount ( event . getAmount (  )  * 2 ) ; return false; } } 
public class OyobiWhoSplitTheHeavens extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public OyobiWhoSplitTheHeavens ( UUID ownerId )  { super ( ownerId, 18, "Oyobi, Who Split the Heavens", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{W}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new CreateTokenEffect ( new AnotherSpiritToken (  )  ) , filter, false )  ) ; } public OyobiWhoSplitTheHeavens ( final OyobiWhoSplitTheHeavens card )  { super ( card ) ; } @Override public OyobiWhoSplitTheHeavens copy (  )  { return new OyobiWhoSplitTheHeavens ( this ) ; } } class AnotherSpiritToken extends Token { AnotherSpiritToken (  )  { super ( "Spirit", "3/3 white Spirit creature token with flying" ) ; cardType . add ( CardType . CREATURE ) ; color . setWhite ( true ) ; subtype . add ( "Spirit" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class PatronOfTheAkki extends CardImpl { public PatronOfTheAkki ( UUID ownerId )  { super ( ownerId, 115, "Patron of the Akki", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new OfferingAbility ( "Goblin" )  ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostControlledEffect ( 2, 0, Duration . EndOfTurn, new FilterCreaturePermanent (  ) , false ) , false )  ) ; } public PatronOfTheAkki ( final PatronOfTheAkki card )  { super ( card ) ; } @Override public PatronOfTheAkki copy (  )  { return new PatronOfTheAkki ( this ) ; } } 
public class PatronOfTheKitsune extends CardImpl { public PatronOfTheKitsune ( UUID ownerId )  { super ( ownerId, 19, "Patron of the Kitsune", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( new OfferingAbility ( "Fox" )  ) ; this . addAbility ( new AttacksAllTriggeredAbility ( new GainLifeEffect ( 1 ) , true )  ) ; } public PatronOfTheKitsune ( final PatronOfTheKitsune card )  { super ( card ) ; } @Override public PatronOfTheKitsune copy (  )  { return new PatronOfTheKitsune ( this ) ; } } 
public class PatronOfTheMoon extends CardImpl { public PatronOfTheMoon ( UUID ownerId )  { super ( ownerId, 45, "Patron of the Moon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new OfferingAbility ( "Moonfolk" )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PatronOfTheMoonEffect (  ) , new ManaCostsImpl ( "{1}" )  ) ; this . addAbility ( ability ) ; } public PatronOfTheMoon ( final PatronOfTheMoon card )  { super ( card ) ; } @Override public PatronOfTheMoon copy (  )  { return new PatronOfTheMoon ( this ) ; } } class PatronOfTheMoonEffect extends OneShotEffect { PatronOfTheMoonEffect (  )  { super ( Outcome . PutLandInPlay ) ; staticText = "Put up to two land cards from your hand onto the battlefield tapped"; } PatronOfTheMoonEffect ( final PatronOfTheMoonEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { TargetCard target = new TargetCardInHand ( 0, 2, new FilterLandCard ( "up to two land cards to put onto the battlefield tapped" )  ) ; controller . chooseTarget ( outcome, controller . getHand (  ) , target, source, game ) ; return controller . moveCards ( new CardsImpl ( target . getTargets (  )  )  . getCards ( game ) , Zone . BATTLEFIELD, source, game, true, false, false, null ) ; } return false; } @Override public PatronOfTheMoonEffect copy (  )  { return new PatronOfTheMoonEffect ( this ) ; } } 
public class PatronOfTheNezumi extends CardImpl { public PatronOfTheNezumi ( UUID ownerId )  { super ( ownerId, 77, "Patron of the Nezumi", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( new OfferingAbility ( "Rat" )  ) ; this . addAbility ( new PatronOfTheNezumiTriggeredAbility ( new LoseLifeTargetEffect ( 1 )  )  ) ; } public PatronOfTheNezumi ( final PatronOfTheNezumi card )  { super ( card ) ; } @Override public PatronOfTheNezumi copy (  )  { return new PatronOfTheNezumi ( this ) ; } } class PatronOfTheNezumiTriggeredAbility extends TriggeredAbilityImpl { public PatronOfTheNezumiTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect, false ) ; } public PatronOfTheNezumiTriggeredAbility ( final PatronOfTheNezumiTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; if  ( zEvent . getFromZone (  )  == Zone . BATTLEFIELD && zEvent . getToZone (  )  == Zone . GRAVEYARD )  { Card card = game . getCard ( zEvent . getTargetId (  )  ) ; if  ( card != null && game . getOpponents ( controllerId )  . contains ( card . getOwnerId (  )  )  )  { this . getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( zEvent . getPlayerId (  )  )  ) ; return true; } } return false; } @Override public String getRule (  )  { return "Whenever a permanent is put into an opponent's graveyard, that player loses 1 life . "; } @Override public PatronOfTheNezumiTriggeredAbility copy (  )  { return new PatronOfTheNezumiTriggeredAbility ( this ) ; } } 
public class PatronOfTheOrochi extends CardImpl { public PatronOfTheOrochi ( UUID ownerId )  { super ( ownerId, 138, "Patron of the Orochi", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( new OfferingAbility ( "Snake" )  ) ; this . addAbility ( new LimitedTimesPerTurnActivatedAbility ( Zone . BATTLEFIELD, new PatronOfTheOrochiEffect (  ) , new TapSourceCost (  )  )  ) ; } public PatronOfTheOrochi ( final PatronOfTheOrochi card )  { super ( card ) ; } @Override public PatronOfTheOrochi copy (  )  { return new PatronOfTheOrochi ( this ) ; } } class PatronOfTheOrochiEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterPermanent (  ) ; static { filter . add ( Predicates . or (  new SubtypePredicate ( "Forest" ) , Predicates . and ( new CardTypePredicate ( CardType . CREATURE ) , new ColorPredicate ( ObjectColor . GREEN )  )   )  ) ; } public PatronOfTheOrochiEffect (  )  { super ( Outcome . Untap ) ; staticText = "Untap all Forests and all green creatures"; } public PatronOfTheOrochiEffect ( final PatronOfTheOrochiEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { for  ( Permanent permanent: game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . untap ( game ) ; } return true; } return false; } @Override public PatronOfTheOrochiEffect copy (  )  { return new PatronOfTheOrochiEffect ( this ) ; } } 
public class PetalmaneBaku extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public PetalmaneBaku ( UUID ownerId )  { super ( ownerId, 139, "Petalmane Baku", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; Ability ability = new DynamicManaAbility (  new Mana ( 0, 0, 0, 0, 0, 0, 1, 0 ) , new RemovedCountersForCostValue (  ) , new ManaCostsImpl<> ( "{1}" ) , "Add X mana of any one color to your mana pool", true, new CountersCount ( CounterType . KI )  ) ; ability . addCost ( new RemoveVariableCountersSourceCost ( CounterType . KI . createInstance (  ) , "Remove X ki counters from {this}" )  ) ; this . addAbility ( ability ) ; } public PetalmaneBaku ( final PetalmaneBaku card )  { super ( card ) ; } @Override public PetalmaneBaku copy (  )  { return new PetalmaneBaku ( this ) ; } private class PetalmaneBakuManaAbility extends BasicManaAbility { PetalmaneBakuManaAbility (  )  { super ( new PetalmaneBakuManaEffect (  )  ) ; this . addChoice ( new ChoiceColor (  )  ) ; } PetalmaneBakuManaAbility ( final PetalmaneBakuManaAbility ability )  { super ( ability ) ; } @Override public PetalmaneBakuManaAbility copy (  )  { return new PetalmaneBakuManaAbility ( this ) ; } } private class PetalmaneBakuManaEffect extends ManaEffect { PetalmaneBakuManaEffect (  )  { super (  ) ; staticText = "Add X mana of any one color to your mana pool"; } PetalmaneBakuManaEffect ( final PetalmaneBakuManaEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { ChoiceColor choice =  ( ChoiceColor )  source . getChoices (  )  . get ( 0 ) ; Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null && choice != null )  { int numberOfMana = 0; for  ( Cost cost : source . getCosts (  )  )  { if  ( cost instanceof RemoveVariableCountersSourceCost )  { numberOfMana =  (  ( RemoveVariableCountersSourceCost )  cost )  . getAmount (  ) ; } } if  ( choice . getColor (  )  . isBlack (  )  )  { player . getManaPool (  )  . addMana ( new Mana ( 0, 0, 0, 0, numberOfMana, 0, 0, 0 ) , game, source ) ; return true; } else if  ( choice . getColor (  )  . isBlue (  )  )  { player . getManaPool (  )  . addMana ( new Mana ( 0, 0, numberOfMana, 0, 0, 0, 0, 0 ) , game, source ) ; return true; } else if  ( choice . getColor (  )  . isRed (  )  )  { player . getManaPool (  )  . addMana ( new Mana ( numberOfMana, 0, 0, 0, 0, 0, 0, 0 ) , game, source ) ; return true; } else if  ( choice . getColor (  )  . isGreen (  )  )  { player . getManaPool (  )  . addMana ( new Mana ( 0, numberOfMana, 0, 0, 0, 0, 0, 0 ) , game, source ) ; return true; } else if  ( choice . getColor (  )  . isWhite (  )  )  { player . getManaPool (  )  . addMana ( new Mana ( 0, 0, 0, numberOfMana, 0, 0, 0, 0 ) , game, source ) ; return true; } } return false; } @Override public Mana getMana ( Game game, Ability source )  { return null; } @Override public PetalmaneBakuManaEffect copy (  )  { return new PetalmaneBakuManaEffect ( this ) ; } } } 
public class PhantomWings extends CardImpl { public PhantomWings ( UUID ownerId )  { super ( ownerId, 46, "Phantom Wings", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PhantomWingsReturnEffect (  ) , new SacrificeSourceCost (  )  )  ) ; } public PhantomWings ( final PhantomWings card )  { super ( card ) ; } @Override public PhantomWings copy (  )  { return new PhantomWings ( this ) ; } private class PhantomWingsReturnEffect extends OneShotEffect { public PhantomWingsReturnEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "Return enchanted creature to its owner's hand"; } public PhantomWingsReturnEffect ( final PhantomWingsReturnEffect effect )  { super ( effect ) ; } @Override public PhantomWingsReturnEffect copy (  )  { return new PhantomWingsReturnEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent =  ( Permanent )  game . getLastKnownInformation ( source . getSourceId (  ) , Zone . BATTLEFIELD ) ; if  ( permanent != null && permanent . getAttachedTo (  )  != null )  { Permanent enchantedCreature = game . getPermanent ( permanent . getAttachedTo (  )  ) ; if  ( enchantedCreature != null )  { return enchantedCreature . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; } } return false; } } } 
public class Quash extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant or sorcery spell" ) ; static { Predicates . or (  new CardTypePredicate ( CardType . INSTANT ) , new CardTypePredicate ( CardType . SORCERY )  ) ; } public Quash ( UUID ownerId )  { super ( ownerId, 47, "Quash", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new CounterTargetAndSearchGraveyardHandLibraryEffect (  )  ) ; } public Quash ( final Quash card )  { super ( card ) ; } @Override public Quash copy (  )  { return new Quash ( this ) ; } } 
public class QuillmaneBaku extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; private final UUID originalId; public QuillmaneBaku ( UUID ownerId )  { super ( ownerId, 48, "Quillmane Baku", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new QuillmaneBakuReturnEffect (  ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new RemoveVariableCountersSourceCost ( CounterType . KI . createInstance ( 1 )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; originalId = ability . getOriginalId (  ) ; this . addAbility ( ability ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability . getOriginalId (  )  . equals ( originalId )  )  { int maxConvManaCost = 0; for  ( Cost cost : ability . getCosts (  )  )  { if  ( cost instanceof RemoveVariableCountersSourceCost )  { maxConvManaCost =  (  ( RemoveVariableCountersSourceCost )  cost )  . getAmount (  ) ; } } ability . getTargets (  )  . clear (  ) ; FilterCreaturePermanent newFilter = new FilterCreaturePermanent ( "creature with converted mana cost " + maxConvManaCost + " or less" ) ; newFilter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, maxConvManaCost + 1 )  ) ; TargetCreaturePermanent target = new TargetCreaturePermanent ( newFilter ) ; ability . getTargets (  )  . add ( target ) ; } } public QuillmaneBaku ( final QuillmaneBaku card )  { super ( card ) ; this . originalId = card . originalId; } @Override public QuillmaneBaku copy (  )  { return new QuillmaneBaku ( this ) ; } class QuillmaneBakuReturnEffect extends OneShotEffect { public QuillmaneBakuReturnEffect (  )  { super ( Outcome . ReturnToHand ) ; this . staticText = "Return target creature with converted mana cost X or less to its owner's hand"; } public QuillmaneBakuReturnEffect ( final QuillmaneBakuReturnEffect effect )  { super ( effect ) ; } @Override public QuillmaneBakuReturnEffect copy (  )  { return new QuillmaneBakuReturnEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( permanent != null )  { controller . moveCards ( permanent, null, Zone . HAND, source, game ) ; } return true; } } } 
public class ReduceToDreams extends CardImpl { public ReduceToDreams ( UUID ownerId )  { super ( ownerId, 49, "Reduce to Dreams", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new ReduceToDreamsEffect (  )  ) ; } public ReduceToDreams ( final ReduceToDreams card )  { super ( card ) ; } @Override public ReduceToDreams copy (  )  { return new ReduceToDreams ( this ) ; } } class ReduceToDreamsEffect extends OneShotEffect { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "artifacts and enchantments" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . ARTIFACT ) , new CardTypePredicate ( CardType . ENCHANTMENT )   )  ) ; } public ReduceToDreamsEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "Return all artifacts and enchantments to their owners' hands"; } public ReduceToDreamsEffect ( final ReduceToDreamsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent creature : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { creature . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, true ) ; } return true; } @Override public ReduceToDreamsEffect copy (  )  { return new ReduceToDreamsEffect ( this ) ; } } 
public class RibbonsOfTheReikai extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "Spirit you control" ) ; static { filter . add ( new SubtypePredicate ( "Spirit" )  ) ; } public RibbonsOfTheReikai ( UUID ownerId )  { super ( ownerId, 50, "Ribbons of the Reikai", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public RibbonsOfTheReikai ( final RibbonsOfTheReikai card )  { super ( card ) ; } @Override public RibbonsOfTheReikai copy (  )  { return new RibbonsOfTheReikai ( this ) ; } } 
public class RoarOfJukai extends CardImpl { public RoarOfJukai ( UUID ownerId )  { super ( ownerId, 140, "Roar of Jukai", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new RoarOfJukaiEffect (  )  ) ; this . addAbility ( new SpliceOntoArcaneAbility ( new GainLifeOpponentCost ( 5 )  )  ) ; } public RoarOfJukai ( final RoarOfJukai card )  { super ( card ) ; } @Override public RoarOfJukai copy (  )  { return new RoarOfJukai ( this ) ; } } class RoarOfJukaiEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterPermanent ( "Forest" ) ; private static final FilterCreaturePermanent filterBlocked = new FilterCreaturePermanent ( "blocked creature" ) ; static { filter . add ( new SubtypePredicate ( "Forest" )  ) ; filterBlocked . add ( new BlockedPredicate (  )  ) ; } static { } public RoarOfJukaiEffect (  )  { super ( Outcome . BoostCreature ) ; this . staticText = "If you control a Forest, each blocked creature gets +2/+2 until end of turn"; } public RoarOfJukaiEffect ( final RoarOfJukaiEffect effect )  { super ( effect ) ; } @Override public RoarOfJukaiEffect copy (  )  { return new RoarOfJukaiEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { if  ( new PermanentsOnTheBattlefieldCondition ( filter, CountType . MORE_THAN, 0 )  . apply ( game, source )  )  { for ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filterBlocked, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { ContinuousEffect effect = new BoostTargetEffect ( 2,2, Duration . EndOfTurn ) ; effect . setTargetPointer ( new FixedTarget ( permanent . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } } return true; } return false; } } 
public class RoninCliffrider extends CardImpl { public RoninCliffrider ( UUID ownerId )  { super ( ownerId, 116, "Ronin Cliffrider", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new BushidoAbility ( 1 )  ) ; this . addAbility ( new AttacksTriggeredAbility ( new RoninCliffriderEffect (  ) , true )  ) ; } public RoninCliffrider ( final RoninCliffrider card )  { super ( card ) ; } @Override public RoninCliffrider copy (  )  { return new RoninCliffrider ( this ) ; } } class RoninCliffriderEffect extends OneShotEffect { public RoninCliffriderEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "you may have it deal 1 damage to each creature defending player controls"; } public RoninCliffriderEffect ( final RoninCliffriderEffect effect )  { super ( effect ) ; } @Override public RoninCliffriderEffect copy (  )  { return new RoninCliffriderEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID defenderId = game . getCombat (  )  . getDefenderId ( source . getSourceId (  )  ) ; if  ( defenderId != null )  { FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; filter . add ( new ControllerIdPredicate ( defenderId )  ) ; List<Permanent> permanents = game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game ) ; for  ( Permanent permanent : permanents )  { permanent . damage ( 1, source . getSourceId (  ) , game, false, true ) ; } return true; } return false; } } 
public class RoninWarclub extends CardImpl { public RoninWarclub ( UUID ownerId )  { super ( ownerId, 158, "Ronin Warclub", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 2, 1 )  )  ) ; Ability ability = new RoninWarclubTriggeredAbility (  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EquipAbility ( Outcome . BoostCreature, new GenericManaCost ( 5 )  )  ) ; } public RoninWarclub ( final RoninWarclub card )  { super ( card ) ; } @Override public RoninWarclub copy (  )  { return new RoninWarclub ( this ) ; } private class RoninWarclubTriggeredAbility extends TriggeredAbilityImpl { public RoninWarclubTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new RoninWarclubAttachEffect (  ) , false ) ; } public RoninWarclubTriggeredAbility ( RoninWarclubTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent . getCardType (  )  . contains ( CardType . CREATURE )  &&  ( permanent . getControllerId (  )  . equals ( this . controllerId )  )  )  { if  ( !this . getTargets (  )  . isEmpty (  )  )  { if  ( this . getTargets (  )  . get ( 0 )  . getTargets (  )  . size (  )  > 0 )  { this . getTargets (  )  . clear (  ) ; this . addTarget ( new TargetCreaturePermanent (  )  ) ; } Target target = this . getTargets (  )  . get ( 0 ) ; if  ( target instanceof TargetCreaturePermanent )  { target . add ( event . getTargetId (  ) , game ) ; } } return true; } return false; } @Override public RoninWarclubTriggeredAbility copy (  )  { return new RoninWarclubTriggeredAbility ( this ) ; } } private class RoninWarclubAttachEffect extends OneShotEffect { public RoninWarclubAttachEffect (  )  { super ( Outcome . BoostCreature ) ; this . staticText = "Whenever a creature enters the battlefield under your control, attach {this} to that creature"; } public RoninWarclubAttachEffect ( final RoninWarclubAttachEffect effect )  { super ( effect ) ; } @Override public RoninWarclubAttachEffect copy (  )  { return new RoninWarclubAttachEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; Permanent attachment = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null && attachment != null )  { if  ( attachment . getAttachedTo (  )  != null )  { Permanent oldTarget = game . getPermanent ( attachment . getAttachedTo (  )  ) ; if  ( oldTarget != null )  { oldTarget . removeAttachment ( source . getSourceId (  ) , game ) ; } } boolean result; result = permanent . addAttachment ( source . getSourceId (  ) , game ) ; return result; } return false; } } } 
public class SakikoMotherOfSummer extends CardImpl { public SakikoMotherOfSummer ( UUID ownerId )  { super ( ownerId, 141, "Sakiko, Mother of Summer", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Snake" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SakikoMotherOfSummerTriggeredAbility (  )  ) ; } public SakikoMotherOfSummer ( final SakikoMotherOfSummer card )  { super ( card ) ; } @Override public SakikoMotherOfSummer copy (  )  { return new SakikoMotherOfSummer ( this ) ; } } class SakikoMotherOfSummerTriggeredAbility extends TriggeredAbilityImpl { public SakikoMotherOfSummerTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, null, false ) ; } public SakikoMotherOfSummerTriggeredAbility ( final SakikoMotherOfSummerTriggeredAbility ability )  { super ( ability ) ; } @Override public SakikoMotherOfSummerTriggeredAbility copy (  )  { return new SakikoMotherOfSummerTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  (  (  ( DamagedPlayerEvent )  event )  . isCombatDamage (  )  )  { Permanent creature = game . getPermanent ( event . getSourceId (  )  ) ; if  ( creature != null && creature . getControllerId (  )  . equals ( controllerId )  )  { this . getEffects (  )  . clear (  ) ; Effect effect = new AddManaToManaPoolTargetControllerEffect ( new Mana ( 0,event . getAmount (  ) ,0,0,0,0,0, 0 ) , "that player", true ) ; effect . setTargetPointer ( new FixedTarget ( creature . getControllerId (  )  )  ) ; effect . setText ( "add that much {G} to your mana pool .  Until end of turn, this mana doesn't empty from your mana pool as steps and phases end" ) ; this . addEffect ( effect ) ; return true; } } return false; } @Override public String getRule (  )  { return "Whenever a creature you control deals combat damage to a player, add that much {G} to your mana pool .  Until end of turn, this mana doesn't empty from your mana pool as steps and phases end . "; } } 
public class SakuraTribeSpringcaller extends CardImpl { public SakuraTribeSpringcaller ( UUID ownerId )  { super ( ownerId, 142, "Sakura-Tribe Springcaller", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Snake" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; Effect effect = new AddManaToManaPoolTargetControllerEffect ( new Mana ( Mana . GreenMana ( 1 )  ) , "your", true ) ; effect . setText ( "add {G} to your mana pool .  Until end of turn, this mana doesn't empty from your mana pool as steps and phases end" ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, effect, TargetController . YOU, false )  ) ; } public SakuraTribeSpringcaller ( final SakuraTribeSpringcaller card )  { super ( card ) ; } @Override public SakuraTribeSpringcaller copy (  )  { return new SakuraTribeSpringcaller ( this ) ; } } 
public class ScaledHulk extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public ScaledHulk ( UUID ownerId )  { super ( ownerId, 143, "Scaled Hulk", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , filter, false )  ) ; } public ScaledHulk ( final ScaledHulk card )  { super ( card ) ; } @Override public ScaledHulk copy (  )  { return new ScaledHulk ( this ) ; } } 
public class Scour extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "enchantment" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public Scour ( UUID ownerId )  { super ( ownerId, 20, "Scour", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetAndSearchGraveyardHandLibraryEffect ( false, "its controller's","all cards with the same name as that enchantment" )  ) ; } public Scour ( final Scour card )  { super ( card ) ; } @Override public Scour copy (  )  { return new Scour ( this ) ; } } 
public class ScourgeOfNumai extends CardImpl { public ScourgeOfNumai ( UUID ownerId )  { super ( ownerId, 80, "Scourge of Numai", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Demon" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new ScourgeOfNumaiEffect (  ) , TargetController . YOU, false )  ) ; } public ScourgeOfNumai ( final ScourgeOfNumai card )  { super ( card ) ; } @Override public ScourgeOfNumai copy (  )  { return new ScourgeOfNumai ( this ) ; } } class ScourgeOfNumaiEffect extends OneShotEffect { public ScourgeOfNumaiEffect (  )  { super ( Outcome . LoseLife ) ; this . staticText = "you lose 2 life if you don't control an Ogre . "; } public ScourgeOfNumaiEffect ( final ScourgeOfNumaiEffect effect )  { super ( effect ) ; } @Override public ScourgeOfNumaiEffect copy (  )  { return new ScourgeOfNumaiEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { if  ( game . getBattlefield (  )  . countAll ( new FilterCreaturePermanent ( "Ogre", "Ogre" ) , source . getControllerId (  ) , game )  < 1 )  { controller . loseLife ( 2, game ) ; } return true; } return false; } } 
public class ShimmeringGlasskite extends CardImpl { public ShimmeringGlasskite ( UUID ownerId )  { super ( ownerId, 51, "Shimmering Glasskite", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new ShimmeringGlasskiteAbility (  )  ) ; } public ShimmeringGlasskite ( final ShimmeringGlasskite card )  { super ( card ) ; } @Override public ShimmeringGlasskite copy (  )  { return new ShimmeringGlasskite ( this ) ; } } class ShimmeringGlasskiteAbility extends TriggeredAbilityImpl { protected int turnUsed; public ShimmeringGlasskiteAbility (  )  { super ( Zone . BATTLEFIELD, new CounterTargetEffect (  ) , false ) ; } public ShimmeringGlasskiteAbility ( final ShimmeringGlasskiteAbility ability )  { super ( ability ) ; turnUsed = ability . turnUsed; } @Override public ShimmeringGlasskiteAbility copy (  )  { return new ShimmeringGlasskiteAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TARGETED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( this . getSourceId (  )  )  && game . getTurnNum (  )  > turnUsed )  { this . getTargets (  )  . clear (  ) ; TargetStackObject target = new TargetStackObject (  ) ; target . add ( event . getSourceId (  ) , game ) ; this . addTarget ( target ) ; turnUsed = game . getTurnNum (  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} becomes the target of a spell or ability for the first time in a turn, counter that spell or ability . "; } } 
public class ShiningShoal extends CardImpl { public ShiningShoal ( UUID ownerId )  { super ( ownerId, 21, "Shining Shoal", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{X}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; FilterOwnedCard filter = new FilterOwnedCard ( "a white card with converted mana cost X from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . WHITE )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class ShinkaGatekeeper extends CardImpl { public ShinkaGatekeeper ( UUID ownerId )  { super ( ownerId, 117, "Shinka Gatekeeper", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DealtDamageToSourceTriggeredAbility ( Zone . BATTLEFIELD, new ShinkaGatekeeperDealDamageEffect (  ) , false )  ) ; } public ShinkaGatekeeper ( final ShinkaGatekeeper card )  { super ( card ) ; } @Override public ShinkaGatekeeper copy (  )  { return new ShinkaGatekeeper ( this ) ; } } class ShinkaGatekeeperDealDamageEffect extends OneShotEffect { public ShinkaGatekeeperDealDamageEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "it deals that much damage to you"; } public ShinkaGatekeeperDealDamageEffect ( final ShinkaGatekeeperDealDamageEffect effect )  { super ( effect ) ; } @Override public ShinkaGatekeeperDealDamageEffect copy (  )  { return new ShinkaGatekeeperDealDamageEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int amount =  ( Integer )  getValue ( "damage" ) ; if  ( amount > 0 )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . damage ( amount, source . getSourceId (  ) , game, false, true ) ; return true; } } return false; } } 
public class ShireiShizosCaretaker extends CardImpl { public ShireiShizosCaretaker ( UUID ownerId )  { super ( ownerId, 81, "Shirei, Shizo's Caretaker", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new ShireiShizosCaretakerTriggeredAbility ( this . getId (  )  )  ) ; } public ShireiShizosCaretaker ( final ShireiShizosCaretaker card )  { super ( card ) ; } @Override public ShireiShizosCaretaker copy (  )  { return new ShireiShizosCaretaker ( this ) ; } } class ShireiShizosCaretakerTriggeredAbility extends TriggeredAbilityImpl { ShireiShizosCaretakerTriggeredAbility ( UUID shireiId )  { super ( Zone . BATTLEFIELD, new ShireiShizosCaretakerEffect ( shireiId ) , false ) ; } ShireiShizosCaretakerTriggeredAbility ( final ShireiShizosCaretakerTriggeredAbility ability )  { super ( ability ) ; } @Override public ShireiShizosCaretakerTriggeredAbility copy (  )  { return new ShireiShizosCaretakerTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; Permanent LKIpermanent = game . getPermanentOrLKIBattlefield ( zEvent . getTargetId (  )  ) ; Card card = game . getCard ( zEvent . getTargetId (  )  ) ; if  ( card != null && LKIpermanent != null && card . getOwnerId (  )  . equals ( this . controllerId )  && zEvent . getToZone (  )  == Zone . GRAVEYARD && zEvent . getFromZone (  )  == Zone . BATTLEFIELD && card . getCardType (  )  . contains ( CardType . CREATURE )  && LKIpermanent . getPower (  )  . getValue (  )  <= 1 )  { for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( zEvent . getTargetId (  )  )  ) ; } return true; } return false; } @Override public String getRule (  )  { return "Whenever a creature with power 1 or less is put into your graveyard from the battlefield, you may return that card to the battlefield at the beginning of the next end step if Shirei, Shizo's Caretaker is still on the battlefield . "; } } class ShireiShizosCaretakerEffect extends OneShotEffect { protected final UUID shireiId; ShireiShizosCaretakerEffect ( UUID shireiId )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "you may return that card to the battlefield at the beginning of the next end step if {this} is still on the battlefield . "; this . shireiId = shireiId; } ShireiShizosCaretakerEffect ( final ShireiShizosCaretakerEffect effect )  { super ( effect ) ; this . shireiId = effect . shireiId; } @Override public ShireiShizosCaretakerEffect copy (  )  { return new ShireiShizosCaretakerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card card = game . getCard ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( card != null )  { Effect effect = new ShireiShizosCaretakerReturnEffect ( shireiId ) ; effect . setText ( "return that card to the battlefield if {this} is still on the battlefield" ) ; DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( effect ) ; delayedAbility . getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( card . getId (  )  )  ) ; game . addDelayedTriggeredAbility ( delayedAbility, source ) ; return true; } return false; } } class ShireiShizosCaretakerReturnEffect extends ReturnToBattlefieldUnderYourControlTargetEffect { protected final UUID shireiId; ShireiShizosCaretakerReturnEffect ( UUID shireiId )  { this . shireiId = shireiId; } ShireiShizosCaretakerReturnEffect ( final ShireiShizosCaretakerReturnEffect effect )  { super ( effect ) ; this . shireiId = effect . shireiId; } @Override public ShireiShizosCaretakerReturnEffect copy (  )  { return new ShireiShizosCaretakerReturnEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { if  ( game . getBattlefield (  )  . containsPermanent ( shireiId )  )  { return super . apply ( game, source ) ; } return false; } } 
public class ShizukoCallerOfAutumn extends CardImpl { public ShizukoCallerOfAutumn ( UUID ownerId )  { super ( ownerId, 144, "Shizuko, Caller of Autumn", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Snake" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; Effect effect = new AddManaToManaPoolTargetControllerEffect ( new Mana ( 0,3,0,0,0,0,0, 0 ) , "that player", true ) ; effect . setText ( "that player adds {G}{G}{G} to his or her mana pool .  Until end of turn, this mana doesn't empty from that player's mana pool as steps and phases end" ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, effect, TargetController . ANY, false )  ) ; } public ShizukoCallerOfAutumn ( final ShizukoCallerOfAutumn card )  { super ( card ) ; } @Override public ShizukoCallerOfAutumn copy (  )  { return new ShizukoCallerOfAutumn ( this ) ; } } 
public class Shuko extends CardImpl { public Shuko ( UUID ownerId )  { super ( ownerId, 159, "Shuko", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 1, 0 )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . BoostCreature, new GenericManaCost ( 0 )  )  ) ; } public Shuko ( final Shuko card )  { super ( card ) ; } @Override public Shuko copy (  )  { return new Shuko ( this ) ; } } 
public class SilverstormSamurai extends CardImpl { public SilverstormSamurai ( UUID ownerId )  { super ( ownerId, 22, "Silverstorm Samurai", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Fox" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; this . addAbility ( new BushidoAbility ( 1 )  ) ; } public SilverstormSamurai ( final SilverstormSamurai card )  { super ( card ) ; } @Override public SilverstormSamurai copy (  )  { return new SilverstormSamurai ( this ) ; } } 
public class SkullmaneBaku extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public SkullmaneBaku ( UUID ownerId )  { super ( ownerId, 83, "Skullmane Baku", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SkullmaneBakuUnboostEffect (  ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new RemoveVariableCountersSourceCost ( CounterType . KI . createInstance ( 1 )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public SkullmaneBaku ( final SkullmaneBaku card )  { super ( card ) ; } @Override public SkullmaneBaku copy (  )  { return new SkullmaneBaku ( this ) ; } class SkullmaneBakuUnboostEffect extends OneShotEffect { public SkullmaneBakuUnboostEffect (  )  { super ( Outcome . UnboostCreature ) ; staticText = "Target creature gets -X/-X until end of turn"; } public SkullmaneBakuUnboostEffect ( SkullmaneBakuUnboostEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { int numberToUnboost = 0; for  ( Cost cost : source . getCosts (  )  )  { if  ( cost instanceof RemoveVariableCountersSourceCost )  { numberToUnboost =  (  ( RemoveVariableCountersSourceCost ) cost )  . getAmount (  )  * -1; } } Permanent creature = game . getPermanent ( targetPointer . getFirst ( game, source )  ) ; if  ( creature != null && numberToUnboost != 0 )  { creature . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( numberToUnboost, numberToUnboost, Duration . EndOfTurn )  ) , source . getSourceId (  ) , game, false ) ; } return true; } @Override public SkullmaneBakuUnboostEffect copy (  )  { return new SkullmaneBakuUnboostEffect ( this ) ; } } } 
public class Skullsnatcher extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "unblocked attacker you control" ) ; static { filter . add ( new UnblockedPredicate (  )  ) ; } public Skullsnatcher ( UUID ownerId )  { super ( ownerId, 84, "Skullsnatcher", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Rat" ) ; this . subtype . add ( "Ninja" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{B" )  )  ) ; Effect effect = new ExileTargetEffect ( null, "", Zone . GRAVEYARD ) ; effect . setText ( "exile up to two target cards from that player's graveyard" ) ; this . addAbility ( new SkullsnatcherTriggeredAbility ( effect )  ) ; } public Skullsnatcher ( final Skullsnatcher card )  { super ( card ) ; } @Override public Skullsnatcher copy (  )  { return new Skullsnatcher ( this ) ; } } class SkullsnatcherTriggeredAbility extends TriggeredAbilityImpl { SkullsnatcherTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect, false ) ; } SkullsnatcherTriggeredAbility ( final SkullsnatcherTriggeredAbility ability )  { super ( ability ) ; } @Override public SkullsnatcherTriggeredAbility copy (  )  { return new SkullsnatcherTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  (  (  ( DamagedPlayerEvent )  event )  . isCombatDamage (  )  && event . getSourceId (  )  . equals ( sourceId )  )  { FilterCard filter = new FilterCard ( "up to two target cards from that player's graveyard" ) ; filter . add ( new OwnerIdPredicate ( event . getPlayerId (  )  )  ) ; filter . setMessage ( "up to two cards in " + game . getPlayer ( event . getTargetId (  )  )  . getLogName (  )  + "'s graveyard" ) ; this . getTargets (  )  . clear (  ) ; this . addTarget ( new TargetCardInOpponentsGraveyard ( 0,2,filter )  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} deals combat damage to a player, " + super . getRule (  ) ; } } 
public class SlumberingTora extends CardImpl { private static final FilterCard filter = new FilterCard ( "Spirit or Arcane card" ) ; static { filter . add ( Predicates . or ( new SubtypePredicate ( "Spirit" ) ,new SubtypePredicate ( "Arcane" )  )  ) ; } public SlumberingTora ( UUID ownerId )  { super ( ownerId, 161, "Slumbering Tora", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "BOK"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SlumberingToraEffect (  ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addCost ( new DiscardTargetCost ( new TargetCardInHand ( filter )  )  ) ; this . addAbility ( ability ) ; } public SlumberingTora ( final SlumberingTora card )  { super ( card ) ; } @Override public SlumberingTora copy (  )  { return new SlumberingTora ( this ) ; } private class SlumberingToraEffect extends ContinuousEffectImpl { public SlumberingToraEffect (  )  { super ( Duration . EndOfTurn, Outcome . BecomeCreature ) ; setText (  ) ; } public SlumberingToraEffect ( final SlumberingToraEffect effect )  { super ( effect ) ; } @Override public SlumberingToraEffect copy (  )  { return new SlumberingToraEffect ( this ) ; } @Override public boolean apply ( Layer layer, SubLayer sublayer, Ability source, Game game )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { switch  ( layer )  { case TypeChangingEffects_4: if  ( sublayer == SubLayer . NA )  { permanent . getCardType (  )  . add ( CardType . CREATURE ) ; permanent . getSubtype (  )  . add ( "Cat" ) ; } break; case PTChangingEffects_7: if  ( sublayer == SubLayer . SetPT_7b )  { int convManaCosts = 0; for  ( Cost cost: source . getCosts (  )  )  { if  ( cost instanceof DiscardTargetCost &&  (  ( DiscardTargetCost ) cost )  . getCards (  )  . size (  )  > 0 )  { convManaCosts =  (  ( DiscardTargetCost ) cost )  . getCards (  )  . get ( 0 )  . getManaCost (  )  . convertedManaCost (  ) ; break; } } permanent . getPower (  )  . setValue ( convManaCosts ) ; permanent . getToughness (  )  . setValue ( convManaCosts ) ; } } return true; } return false; } @Override public boolean apply ( Game game, Ability source )  { return false; } private void setText (  )  { staticText = "{this} becomes an X/X Cat artifact creature until end of turn, where X is the discarded card's converted mana cost"; } @Override public boolean hasLayer ( Layer layer )  { return layer == Layer . PTChangingEffects_7 || layer == Layer . TypeChangingEffects_4; } } } 
public class SoratamiMindsweeper extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a land" ) ; public SoratamiMindsweeper ( UUID ownerId )  { super ( ownerId, 52, "Soratami Mindsweeper", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Moonfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD,new PutLibraryIntoGraveTargetEffect ( 2 ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public SoratamiMindsweeper ( final SoratamiMindsweeper card )  { super ( card ) ; } @Override public SoratamiMindsweeper copy (  )  { return new SoratamiMindsweeper ( this ) ; } } 
public class SosukesSummons extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nontoken Snake" ) ; static { filter . add ( new SubtypePredicate ( "Snake" )  ) ; filter . add ( Predicates . not ( new TokenPredicate (  )  )  ) ; } public SosukesSummons ( UUID ownerId )  { super ( ownerId, 145, "Sosuke's Summons", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{G}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new SnakeToken (  ) , 2 )  ) ; this . addAbility ( new CreatureEntersBattlefieldTriggeredAbility ( Zone . GRAVEYARD, new ReturnSourceFromGraveyardToHandEffect (  ) , filter, true, false )  ) ; } public SosukesSummons ( final SosukesSummons card )  { super ( card ) ; } @Override public SosukesSummons copy (  )  { return new SosukesSummons ( this ) ; } } 
public class SowingSalt extends CardImpl { public SowingSalt ( UUID ownerId )  { super ( ownerId, 118, "Sowing Salt", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{R}{R}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addTarget ( new TargetNonBasicLandPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetAndSearchGraveyardHandLibraryEffect ( false, "its controller's","all cards with the same name as that land" )  ) ; } public SowingSalt ( final SowingSalt card )  { super ( card ) ; } @Override public SowingSalt copy (  )  { return new SowingSalt ( this ) ; } } 
public class Splinter extends CardImpl { private static final FilterPermanent filter = new FilterArtifactPermanent (  ) ; public Splinter ( UUID ownerId )  { super ( ownerId, 146, "Splinter", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{G}{G}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetAndSearchGraveyardHandLibraryEffect ( false, "its controller's","all cards with the same name as that artifact" )  ) ; } public Splinter ( final Splinter card )  { super ( card ) ; } @Override public Splinter copy (  )  { return new Splinter ( this ) ; } } 
public class SplitTailMiko extends CardImpl { public SplitTailMiko ( UUID ownerId )  { super ( ownerId, 23, "Split-Tail Miko", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Fox" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 2 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public SplitTailMiko ( final SplitTailMiko card )  { super ( card ) ; } @Override public SplitTailMiko copy (  )  { return new SplitTailMiko ( this ) ; } } 
public class StirTheGrave extends CardImpl { public StirTheGrave ( UUID ownerId )  { super ( ownerId, 85, "Stir the Grave", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{X}{B}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToBattlefieldTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "creature card from your graveyard" )  )  ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { ability . getTargets (  )  . clear (  ) ; int xValue = ability . getManaCostsToPay (  )  . getX (  ) ; FilterCard filter = new FilterCreatureCard ( "creature card with converted mana cost " + xValue + " or less from your graveyard" ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, xValue + 1 )  ) ; ability . getTargets (  )  . add ( new TargetCardInYourGraveyard ( filter )  ) ; } public StirTheGrave ( final StirTheGrave card )  { super ( card ) ; } @Override public StirTheGrave copy (  )  { return new StirTheGrave ( this ) ; } } 
public class StreamOfConsciousness extends CardImpl { public StreamOfConsciousness ( UUID ownerId )  { super ( ownerId, 53, "Stream of Consciousness", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new StreamOfConsciousnessEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addTarget ( new StreamOfConsciousnessTarget (  )  ) ; } public StreamOfConsciousness ( final StreamOfConsciousness card )  { super ( card ) ; } @Override public StreamOfConsciousness copy (  )  { return new StreamOfConsciousness ( this ) ; } } class StreamOfConsciousnessEffect extends OneShotEffect { public StreamOfConsciousnessEffect (  )  { super ( Outcome . Neutral ) ; this . staticText = "Target player shuffles up to four target cards from his or her graveyard into his or her library"; } public StreamOfConsciousnessEffect ( final StreamOfConsciousnessEffect effect )  { super ( effect ) ; } @Override public StreamOfConsciousnessEffect copy (  )  { return new StreamOfConsciousnessEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null )  { List<UUID> targets = source . getTargets (  )  . get ( 1 )  . getTargets (  ) ; boolean shuffle = false; for  ( UUID targetId : targets )  { Card card = game . getCard ( targetId ) ; if  ( card != null )  { if  ( player . getGraveyard (  )  . contains ( card . getId (  )  )  )  { player . getGraveyard (  )  . remove ( card ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true ) ; shuffle = true; } } } if  ( shuffle )  { player . shuffleLibrary ( game ) ; } return true; } return false; } } class StreamOfConsciousnessTarget extends TargetCard { public StreamOfConsciousnessTarget (  )  { super ( 0, 4, Zone . GRAVEYARD, new FilterCard ( "cards from target player's graveyard" )  ) ; } public StreamOfConsciousnessTarget ( final StreamOfConsciousnessTarget target )  { super ( target ) ; } @Override public boolean canTarget ( UUID id, Ability source, Game game )  { Card card = game . getCard ( id ) ; if  ( card != null && game . getState (  )  . getZone ( card . getId (  )  )  == Zone . GRAVEYARD )  { UUID firstTarget = source . getFirstTarget (  ) ; if  ( firstTarget != null && game . getPlayer ( firstTarget )  . getGraveyard (  )  . contains ( id )  )  { return filter . match ( card, game ) ; } } return false; } @Override public StreamOfConsciousnessTarget copy (  )  { return new StreamOfConsciousnessTarget ( this ) ; } } 
public class SwayOfTheStars extends CardImpl { public SwayOfTheStars ( UUID ownerId )  { super ( ownerId, 54, "Sway of the Stars", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{8}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new SwayOfTheStarsEffect (  )  ) ; Effect effect = new DrawCardAllEffect ( 7 ) ; effect . setText ( ", then draws seven cards" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addEffect ( new SetPlayerLifeAllEffect ( 7 )  ) ; } public SwayOfTheStars ( final SwayOfTheStars card )  { super ( card ) ; } @Override public SwayOfTheStars copy (  )  { return new SwayOfTheStars ( this ) ; } } class SwayOfTheStarsEffect extends OneShotEffect { public SwayOfTheStarsEffect (  )  { super ( Outcome . Neutral ) ; staticText = "Each player shuffles his or her hand, graveyard, and permanents he or she owns into his or her library, then draws seven cards .  Each player's life total becomes 7"; } public SwayOfTheStarsEffect ( final SwayOfTheStarsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { player . moveCards ( player . getHand (  ) , Zone . HAND, Zone . LIBRARY, source, game ) ; player . moveCards ( player . getGraveyard (  ) , Zone . GRAVEYARD, Zone . LIBRARY, source, game ) ; FilterPermanent filter = new FilterPermanent (  ) ; filter . add ( new OwnerIdPredicate ( playerId )  ) ; for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, controller . getId (  ) , source . getSourceId (  ) , game )  )  { permanent . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true ) ; } player . shuffleLibrary ( game ) ; } } return true; } @Override public SwayOfTheStarsEffect copy (  )  { return new SwayOfTheStarsEffect ( this ) ; } } 
public class TakenosCavalry extends CardImpl { private static final FilterAttackingOrBlockingCreature filter = new FilterAttackingOrBlockingCreature ( "attacking or blocking Spirit" ) ; static { filter . add ( new SubtypePredicate ( "Spirit" )  ) ; } public TakenosCavalry ( UUID ownerId )  { super ( ownerId, 24, "Takeno's Cavalry", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Samurai" ) ; this . subtype . add ( "Archer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BushidoAbility ( 1 )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetAttackingOrBlockingCreature ( 1, 1, filter, false )  ) ; this . addAbility ( ability ) ; } public TakenosCavalry ( final TakenosCavalry card )  { super ( card ) ; } @Override public TakenosCavalry copy (  )  { return new TakenosCavalry ( this ) ; } } 
public class TakenumaBleeder extends CardImpl { public TakenumaBleeder ( UUID ownerId )  { super ( ownerId, 86, "Takenuma Bleeder", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new AttacksOrBlocksTriggeredAbility ( new TakenumaBleederEffect (  ) , false )  ) ; } public TakenumaBleeder ( final TakenumaBleeder card )  { super ( card ) ; } @Override public TakenumaBleeder copy (  )  { return new TakenumaBleeder ( this ) ; } } class TakenumaBleederEffect extends OneShotEffect { public TakenumaBleederEffect (  )  { super ( Outcome . LoseLife ) ; this . staticText = "you lose 1 life if you don't control a Demon"; } public TakenumaBleederEffect ( final TakenumaBleederEffect effect )  { super ( effect ) ; } @Override public TakenumaBleederEffect copy (  )  { return new TakenumaBleederEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { if  ( game . getBattlefield (  )  . countAll ( new FilterCreaturePermanent ( "Demon", "Demon" ) , source . getControllerId (  ) , game )  < 1 )  { controller . loseLife ( 1, game ) ; } return true; } return false; } } 
public class Tallowisp extends CardImpl { private static final FilterCard filterAura = new FilterCard ( "Aura card" ) ; private static final FilterSpell filterTrigger = new FilterSpiritOrArcaneCard (  ) ; static { filterAura . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filterAura . add ( new SubtypePredicate ( "Aura" )  ) ; filterAura . add ( new TallowispAbilityPredicate (  )  ) ; } public Tallowisp ( UUID ownerId )  { super ( ownerId, 25, "Tallowisp", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( filterAura ) , true, true ) , filterTrigger, true )  ) ; } public Tallowisp ( final Tallowisp card )  { super ( card ) ; } @Override public Tallowisp copy (  )  { return new Tallowisp ( this ) ; } } class TallowispAbilityPredicate implements Predicate<MageObject> { public TallowispAbilityPredicate (  )  { } @Override public boolean apply ( MageObject input, Game game )  { Abilities<Ability> abilities = input . getAbilities (  ) ; for  ( int i = 0; i < abilities . size (  ) ; i++ )  { if  ( abilities . get ( i )  instanceof EnchantAbility )  { String enchantText = abilities . get ( i )  . getRule (  ) ; if  ( enchantText . startsWith ( "Enchant" )  && enchantText . contains ( "creature" )  )  { return true; } } } return false; } @Override public String toString (  )  { return "Aura card with enchant creature"; } } 
public class TeardropKami extends CardImpl { public TeardropKami ( UUID ownerId )  { super ( ownerId, 55, "Teardrop Kami", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD,new MayTapOrUntapTargetEffect (  ) , new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public TeardropKami ( final TeardropKami card )  { super ( card ) ; } @Override public TeardropKami copy (  )  { return new TeardropKami ( this ) ; } } 
public class TendoIceBridge extends CardImpl { public TendoIceBridge ( UUID ownerId )  { super ( ownerId, 165, "Tendo Ice Bridge", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "BOK"; this . addAbility ( new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . CHARGE . createInstance ( 1 )  ) , "with a charge counter on it" )  ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new AnyColorManaAbility (  ) ; ability . addCost ( new RemoveCountersSourceCost ( CounterType . CHARGE . createInstance ( 1 )  )  ) ; this . addAbility ( ability ) ; } public TendoIceBridge ( final TendoIceBridge card )  { super ( card ) ; } @Override public TendoIceBridge copy (  )  { return new TendoIceBridge ( this ) ; } } 
public class TerashisGrasp extends CardImpl { public TerashisGrasp ( UUID ownerId )  { super ( ownerId, 26, "Terashi's Grasp", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( new FilterArtifactOrEnchantmentPermanent (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new TerashisGraspEffect (  )  ) ; } public TerashisGrasp ( final TerashisGrasp card )  { super ( card ) ; } @Override public TerashisGrasp copy (  )  { return new TerashisGrasp ( this ) ; } private class TerashisGraspEffect extends OneShotEffect { public TerashisGraspEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "You gain life equal to its converted mana cost"; } public TerashisGraspEffect ( TerashisGraspEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent targetPermanent = game . getPermanentOrLKIBattlefield ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( targetPermanent != null )  { int cost = targetPermanent . getManaCost (  )  . convertedManaCost (  ) ; Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . gainLife ( cost, game ) ; } } return true; } @Override public TerashisGraspEffect copy (  )  { return new TerashisGraspEffect ( this ) ; } } } 
public class ThreadsOfDisloyalty extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with converted mana cost 2 or less" ) ; static { filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, 3 )  ) ; } public ThreadsOfDisloyalty ( UUID ownerId )  { super ( ownerId, 56, "Threads of Disloyalty", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent ( filter ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . GainControl )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ControlEnchantedEffect (  )  )  ) ; } public ThreadsOfDisloyalty ( final ThreadsOfDisloyalty card )  { super ( card ) ; } @Override public ThreadsOfDisloyalty copy (  )  { return new ThreadsOfDisloyalty ( this ) ; } } 
public class ThreeTragedies extends CardImpl { public ThreeTragedies ( UUID ownerId )  { super ( ownerId, 87, "Three Tragedies", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new DiscardTargetEffect ( 3 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public ThreeTragedies ( final ThreeTragedies card )  { super ( card ) ; } @Override public ThreeTragedies copy (  )  { return new ThreeTragedies ( this ) ; } } 
public class ThroatSlitter extends CardImpl { public ThroatSlitter ( UUID ownerId )  { super ( ownerId, 88, "Throat Slitter", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{B}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Rat" ) ; this . subtype . add ( "Ninja" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{2}{B}" )  )  ) ; this . addAbility ( new ThroatSlitterTriggeredAbility (  )  ) ; } public ThroatSlitter ( final ThroatSlitter card )  { super ( card ) ; } @Override public ThroatSlitter copy (  )  { return new ThroatSlitter ( this ) ; } } class ThroatSlitterTriggeredAbility extends TriggeredAbilityImpl { ThroatSlitterTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , false ) ; } ThroatSlitterTriggeredAbility ( final ThroatSlitterTriggeredAbility ability )  { super ( ability ) ; } @Override public ThroatSlitterTriggeredAbility copy (  )  { return new ThroatSlitterTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  (  (  ( DamagedPlayerEvent )  event )  . isCombatDamage (  )  && event . getSourceId (  )  . equals ( sourceId )  )  { FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonblack creature that player controls" ) ; filter . add ( new ControllerIdPredicate ( event . getPlayerId (  )  )  ) ; filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; filter . setMessage ( "nonblack creature controlled by " + game . getPlayer ( event . getTargetId (  )  )  . getLogName (  )  ) ; this . getTargets (  )  . clear (  ) ; this . addTarget ( new TargetPermanent ( filter )  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} deals combat damage to a player, destroy target nonblack creature that player controls . "; } } 
public class ToilsOfNightAndDay extends CardImpl { public ToilsOfNightAndDay ( UUID ownerId )  { super ( ownerId, 57, "Toils of Night and Day", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new ToilsOfNightAndDayEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( 0, 2, new FilterPermanent (  ) , false )  ) ; } public ToilsOfNightAndDay ( final ToilsOfNightAndDay card )  { super ( card ) ; } @Override public ToilsOfNightAndDay copy (  )  { return new ToilsOfNightAndDay ( this ) ; } private class ToilsOfNightAndDayEffect extends OneShotEffect { public ToilsOfNightAndDayEffect (  )  { super ( Outcome . Tap ) ; this . staticText = "You may tap or untap target permanent, then you may tap or untap another target permanent"; } public ToilsOfNightAndDayEffect ( final ToilsOfNightAndDayEffect effect )  { super ( effect ) ; } @Override public ToilsOfNightAndDayEffect copy (  )  { return new ToilsOfNightAndDayEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { for  ( UUID targetId : source . getTargets (  )  . get ( 0 )  . getTargets (  )  )  { Permanent permanent = game . getPermanent ( targetId ) ; if  ( permanent != null )  { if  ( player . chooseUse ( Outcome . Tap, new StringBuilder ( "Tap " )  . append ( permanent . getName (  )  )  . append ( "?" )  . toString (  ) , source, game )  )  { permanent . tap ( game ) ; } else if  ( player . chooseUse ( Outcome . Untap, new StringBuilder ( "Untap " )  . append ( permanent . getName (  )  )  . append ( "?" )  . toString (  ) , source, game )  )  { permanent . untap ( game ) ; } } } return true; } return false; } } } 
public class TomorrowAzamisFamiliar extends CardImpl { public TomorrowAzamisFamiliar ( UUID ownerId )  { super ( ownerId, 58, "Tomorrow, Azami's Familiar", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{U}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new TomorrowAzamisFamiliarReplacementEffect (  )  )  ) ; } public TomorrowAzamisFamiliar ( final TomorrowAzamisFamiliar card )  { super ( card ) ; } @Override public TomorrowAzamisFamiliar copy (  )  { return new TomorrowAzamisFamiliar ( this ) ; } } class TomorrowAzamisFamiliarReplacementEffect extends ReplacementEffectImpl { TomorrowAzamisFamiliarReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "If you would draw a card, look at the top three cards of your library instead .  Put one of those cards into your hand and the rest on the bottom of your library in any order"; } TomorrowAzamisFamiliarReplacementEffect ( final TomorrowAzamisFamiliarReplacementEffect effect )  { super ( effect ) ; } @Override public TomorrowAzamisFamiliarReplacementEffect copy (  )  { return new TomorrowAzamisFamiliarReplacementEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { new LookLibraryAndPickControllerEffect ( new StaticValue ( 3 ) , false, new StaticValue ( 1 ) , new FilterCard (  ) , Zone . LIBRARY, false, false )   . apply ( game, source ) ; return true; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DRAW_CARD; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getPlayerId (  )  . equals ( source . getControllerId (  )  ) ; } } 
public class TorrentOfStone extends CardImpl { private static final FilterControlledLandPermanent filterSacrifice = new FilterControlledLandPermanent ( "two Mountains" ) ; static { filterSacrifice . add ( new SubtypePredicate ( "Mountain" )  ) ; } public TorrentOfStone ( UUID ownerId )  { super ( ownerId, 119, "Torrent of Stone", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{R}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 4 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new SpliceOntoArcaneAbility ( new SacrificeTargetCost ( new TargetControlledPermanent ( 2,2, filterSacrifice, false )  )  )  ) ; } public TorrentOfStone ( final TorrentOfStone card )  { super ( card ) ; } @Override public TorrentOfStone copy (  )  { return new TorrentOfStone ( this ) ; } } 
public class ToshiroUmezawa extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "a creature an opponent controls" ) ; private static final FilterCard filterInstant = new FilterCard ( "instant card from your graveyard" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; filterInstant . add ( new CardTypePredicate ( CardType . INSTANT )  ) ; } public ToshiroUmezawa ( UUID ownerId )  { super ( ownerId, 89, "Toshiro Umezawa", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Samurai" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new BushidoAbility ( 1 )  ) ; Ability ability = new DiesCreatureTriggeredAbility ( new ToshiroUmezawaEffect (  ) , true, filter ) ; ability . addTarget ( new TargetCardInYourGraveyard ( 1,1, filterInstant )  ) ; this . addAbility ( ability ) ; } public ToshiroUmezawa ( final ToshiroUmezawa card )  { super ( card ) ; } @Override public ToshiroUmezawa copy (  )  { return new ToshiroUmezawa ( this ) ; } } class ToshiroUmezawaEffect extends OneShotEffect { public ToshiroUmezawaEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "cast target instant card from your graveyard .  If that card would be put into a graveyard this turn, exile it instead"; } public ToshiroUmezawaEffect ( final ToshiroUmezawaEffect effect )  { super ( effect ) ; } @Override public ToshiroUmezawaEffect copy (  )  { return new ToshiroUmezawaEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Card card = game . getCard ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( card != null )  { controller . cast ( card . getSpellAbility (  ) , game, false ) ; game . addEffect ( new ToshiroUmezawaReplacementEffect ( card . getId (  )  ) , source ) ; } } return false; } } class ToshiroUmezawaReplacementEffect extends ReplacementEffectImpl { private final UUID cardId; public ToshiroUmezawaReplacementEffect ( UUID cardId )  { super ( Duration . EndOfTurn, Outcome . Exile ) ; this . cardId = cardId; } public ToshiroUmezawaReplacementEffect ( final ToshiroUmezawaReplacementEffect effect )  { super ( effect ) ; this . cardId = effect . cardId; } @Override public ToshiroUmezawaReplacementEffect copy (  )  { return new ToshiroUmezawaReplacementEffect ( this ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { UUID eventObject =  (  ( ZoneChangeEvent )  event )  . getTargetId (  ) ; StackObject card = game . getStack (  )  . getStackObject ( eventObject ) ; if  ( card != null )  { if  ( card instanceof Spell )  { game . rememberLKI ( card . getId (  ) , Zone . STACK,  ( Spell )  card ) ; } if  ( card instanceof Card && eventObject . equals ( cardId )  )  {  (  ( Card )  card )  . moveToExile ( null, null, source . getSourceId (  ) , game ) ; return true; } } return false; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; return zEvent . getToZone (  )  == Zone . GRAVEYARD &&  (  ( ZoneChangeEvent )  event )  . getTargetId (  )  . equals ( cardId ) ; } } 
public class TraprootKami extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "the number of Forests on the battlefield" ) ; static { filter . add ( new SubtypePredicate ( "Forest" )  ) ; } public TraprootKami ( UUID ownerId )  { super ( ownerId, 147, "Traproot Kami", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new SetToughnessSourceEffect ( new PermanentsOnBattlefieldCount ( filter ) , Duration . EndOfGame )  )  ) ; } public TraprootKami ( final TraprootKami card )  { super ( card ) ; } @Override public TraprootKami copy (  )  { return new TraprootKami ( this ) ; } } 
public class TwistAllegiance extends CardImpl { public TwistAllegiance ( UUID ownerId )  { super ( ownerId, 120, "Twist Allegiance", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{6}{R}" ) ; this . expansionSetCode = "BOK"; this . getSpellAbility (  )  . addEffect ( new TwistAllegianceEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public TwistAllegiance ( final TwistAllegiance card )  { super ( card ) ; } @Override public TwistAllegiance copy (  )  { return new TwistAllegiance ( this ) ; } } class TwistAllegianceEffect extends OneShotEffect { public TwistAllegianceEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "You and target opponent each gain control of all creatures the other controls until end of turn .  Untap those creatures .  Those creatures gain haste until end of turn"; } public TwistAllegianceEffect ( final TwistAllegianceEffect effect )  { super ( effect ) ; } @Override public TwistAllegianceEffect copy (  )  { return new TwistAllegianceEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetOpponent = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null )  { for  ( Permanent permanent: game . getBattlefield (  )  . getActivePermanents ( new FilterCreaturePermanent (  ) , source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { if  ( permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  || permanent . getControllerId (  )  . equals ( targetOpponent . getId (  )  )  )  { UUID newController = permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  ? targetOpponent . getId (  )  : source . getControllerId (  ) ; ContinuousEffect effect = new GainControlTargetEffect ( Duration . EndOfTurn, true, newController ) ; effect . setTargetPointer ( new FixedTarget ( permanent . getId (  )  )  ) ; game . addEffect ( effect, source ) ; permanent . untap ( game ) ; effect = new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setTargetPointer ( new FixedTarget ( permanent . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } } return true; } return false; } } 
public class UmezawasJitte extends CardImpl { public UmezawasJitte ( UUID ownerId )  { super ( ownerId, 163, "Umezawa's Jitte", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Equipment" ) ; this . addAbility ( new UmezawasJitteAbility (  )  ) ; Ability ability = new SimpleActivatedAbility (  Zone . BATTLEFIELD, new BoostEquippedEffect ( 2, 2, Duration . EndOfTurn ) , new RemoveCountersSourceCost ( CounterType . CHARGE . createInstance (  )  )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new BoostTargetEffect ( -1, -1, Duration . EndOfTurn )  ) ; mode . getTargets (  )  . add ( new TargetCreaturePermanent (  )  ) ; ability . addMode ( mode ) ; mode = new Mode (  ) ; mode . getEffects (  )  . add ( new GainLifeEffect ( 2 )  ) ; ability . addMode ( mode ) ; this . addAbility ( ability ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 )  )  ) ; } public UmezawasJitte ( final UmezawasJitte card )  { super ( card ) ; } @Override public UmezawasJitte copy (  )  { return new UmezawasJitte ( this ) ; } } class UmezawasJitteAbility extends TriggeredAbilityImpl { private boolean usedInPhase; public UmezawasJitteAbility (  )  { super ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . CHARGE . createInstance ( 2 )  )  ) ; this . usedInPhase = false; } public UmezawasJitteAbility ( final UmezawasJitteAbility ability )  { super ( ability ) ; this . usedInPhase = ability . usedInPhase; } @Override public UmezawasJitteAbility copy (  )  { return new UmezawasJitteAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { switch ( event . getType (  )  )  { case DAMAGED_CREATURE: case DAMAGED_PLANESWALKER: case DAMAGED_PLAYER: case COMBAT_DAMAGE_STEP_PRE: return true; } return false; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event instanceof DamagedEvent && !usedInPhase &&  (  ( DamagedEvent )  event )  . isCombatDamage (  )  )  { Permanent permanent = game . getPermanent ( event . getSourceId (  )  ) ; if  ( permanent != null && permanent . getAttachments (  )  . contains ( this . getSourceId (  )  )  )  { usedInPhase = true; return true; } } if  ( event . getType (  )  . equals ( EventType . COMBAT_DAMAGE_STEP_PRE )  )  { usedInPhase = false; } return false; } @Override public String getRule (  )  { return "Whenever equipped creature deals combat damage, " + super . getRule (  ) ; } } 
public class UncheckedGrowth extends CardImpl { public UncheckedGrowth ( UUID ownerId )  { super ( ownerId, 148, "Unchecked Growth", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( 4, 4, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new UncheckedGrowthTrampleEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public UncheckedGrowth ( final UncheckedGrowth card )  { super ( card ) ; } @Override public UncheckedGrowth copy (  )  { return new UncheckedGrowth ( this ) ; } private class UncheckedGrowthTrampleEffect extends ContinuousEffectImpl { public UncheckedGrowthTrampleEffect (  )  { super ( Duration . EndOfTurn, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; staticText = "If it's a Spirit, it gains trample until end of turn"; } public UncheckedGrowthTrampleEffect ( final UncheckedGrowthTrampleEffect effect )  { super ( effect ) ; } @Override public UncheckedGrowthTrampleEffect copy (  )  { return new UncheckedGrowthTrampleEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int affectedTargets = 0; for  ( UUID permanentId : targetPointer . getTargets ( game, source )  )  { Permanent permanent = game . getPermanent ( permanentId ) ; if  ( permanent != null && permanent . hasSubtype ( "Spirit" )  )  { permanent . addAbility ( TrampleAbility . getInstance (  ) , game ) ; affectedTargets++; } } return affectedTargets > 0; } } } 
public class Uproot extends CardImpl { public Uproot ( UUID ownerId )  { super ( ownerId, 149, "Uproot", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetLandPermanent (  )  ) ; } public Uproot ( final Uproot card )  { super ( card ) ; } @Override public Uproot copy (  )  { return new Uproot ( this ) ; } } 
public class VeilOfSecrecy extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "a blue creature" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; } public VeilOfSecrecy ( UUID ownerId )  { super ( ownerId, 59, "Veil of Secrecy", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; Effect effect = new GainAbilityTargetEffect ( ShroudAbility . getInstance (  ) , Duration . EndOfTurn ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; effect . setText ( "Target creature gains shroud until end of turn" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; effect = new CantBeBlockedTargetEffect (  ) ; effect . setText ( "and can't be blocked this turn" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . addAbility ( new SpliceOntoArcaneAbility ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledCreaturePermanent ( filter )  )  )  ) ; } public VeilOfSecrecy ( final VeilOfSecrecy card )  { super ( card ) ; } @Override public VeilOfSecrecy copy (  )  { return new VeilOfSecrecy ( this ) ; } } 
public class VitalSurge extends CardImpl { public VitalSurge ( UUID ownerId )  { super ( ownerId, 150, "Vital Surge", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{G}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Arcane" ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 3 )  ) ; this . addAbility ( new SpliceOntoArcaneAbility ( "{1}{G}" )  ) ; } public VitalSurge ( final VitalSurge card )  { super ( card ) ; } @Override public VitalSurge copy (  )  { return new VitalSurge ( this ) ; } } 
public class WalkerOfSecretWays extends CardImpl { private static final FilterControlledCreaturePermanent filterCreature = new FilterControlledCreaturePermanent ( "Ninja you control" ) ; static { filterCreature . add (  ( new SubtypePredicate ( "Ninja" )  )  ) ; } public WalkerOfSecretWays ( UUID ownerId )  { super ( ownerId, 60, "Walker of Secret Ways", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Ninja" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "{1}{U}" )  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new WalkerOfSecretWaysEffect (  ) , true, true )  ) ; Ability ability = new ActivateIfConditionActivatedAbility ( Zone . BATTLEFIELD, new ReturnToHandTargetEffect (  ) , new ManaCostsImpl ( "{1}{U}" ) , MyTurnCondition . getInstance (  )  ) ; ability . addTarget ( new TargetControlledCreaturePermanent ( 1,1, filterCreature, false )  ) ; this . addAbility ( ability ) ; } public WalkerOfSecretWays ( final WalkerOfSecretWays card )  { super ( card ) ; } @Override public WalkerOfSecretWays copy (  )  { return new WalkerOfSecretWays ( this ) ; } } class WalkerOfSecretWaysEffect extends OneShotEffect { WalkerOfSecretWaysEffect (  )  { super ( Outcome . Detriment ) ; staticText = "look at that player's hand"; } WalkerOfSecretWaysEffect ( final WalkerOfSecretWaysEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player player = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( player != null && controller != null )  { controller . lookAtCards ( "Walker of Secret Ways", player . getHand (  ) , game ) ; } return true; } @Override public WalkerOfSecretWaysEffect copy (  )  { return new WalkerOfSecretWaysEffect ( this ) ; } } 
public class WardOfPiety extends CardImpl { public WardOfPiety ( UUID ownerId )  { super ( ownerId, 28, "Ward of Piety", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . PreventDamage )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new WardOfPietyPreventDamageTargetEffect (  ) , new ManaCostsImpl ( "{1}{W}" )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public WardOfPiety ( final WardOfPiety card )  { super ( card ) ; } @Override public WardOfPiety copy (  )  { return new WardOfPiety ( this ) ; } } class WardOfPietyPreventDamageTargetEffect extends RedirectionEffect { protected MageObjectReference redirectToObject; public WardOfPietyPreventDamageTargetEffect (  )  { super ( Duration . EndOfTurn, 1, true ) ; staticText = "The next 1 damage that would be dealt to enchanted creature this turn is dealt to target creature or player instead"; } public WardOfPietyPreventDamageTargetEffect ( final WardOfPietyPreventDamageTargetEffect effect )  { super ( effect ) ; } @Override public WardOfPietyPreventDamageTargetEffect copy (  )  { return new WardOfPietyPreventDamageTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public void init ( Ability source, Game game )  { super . init ( source, game ) ; redirectToObject = new MageObjectReference ( source . getTargets (  )  . get ( 0 )  . getFirstTarget (  ) , game ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { Permanent enchantment = game . getPermanent ( source . getSourceId (  )  ) ; if  ( enchantment != null && event . getTargetId (  )  . equals ( enchantment . getAttachedTo (  )  )  )  { if  ( redirectToObject . equals ( new MageObjectReference ( source . getTargets (  )  . get ( 0 )  . getFirstTarget (  ) , game )  )  )  { redirectTarget = source . getTargets (  )  . get ( 0 ) ; return true; } } return false; } } 
public class WaxmaneBaku extends CardImpl { private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard (  ) ; public WaxmaneBaku ( UUID ownerId )  { super ( ownerId, 29, "Waxmane Baku", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "BOK"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . KI . createInstance (  )  ) , filter, true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new WaxmaneBakuTapEffect (  ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new RemoveVariableCountersSourceCost ( CounterType . KI . createInstance ( 1 )  )  ) ; this . addAbility ( ability ) ; } public WaxmaneBaku ( final WaxmaneBaku card )  { super ( card ) ; } @Override public WaxmaneBaku copy (  )  { return new WaxmaneBaku ( this ) ; } } class WaxmaneBakuTapEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterCreaturePermanent (  ) ; public WaxmaneBakuTapEffect (  )  { super ( Outcome . Tap ) ; staticText = "Tap X target creatures"; } public WaxmaneBakuTapEffect ( final WaxmaneBakuTapEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { int numberToTap = 0; for  ( Cost cost : source . getCosts (  )  )  { if  ( cost instanceof RemoveVariableCountersSourceCost )  { numberToTap =  (  ( RemoveVariableCountersSourceCost )  cost )  . getAmount (  ) ; } } TargetPermanent target = new TargetPermanent ( numberToTap, filter ) ; if  ( target . canChoose ( source . getControllerId (  ) , game )  && target . choose ( Outcome . Tap, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { if  ( !target . getTargets (  )  . isEmpty (  )  )  { List<UUID> targets = target . getTargets (  ) ; for  ( UUID targetId : targets )  { Permanent permanent = game . getPermanent ( targetId ) ; if  ( permanent != null )  { permanent . tap ( game ) ; } } } return true; } return false; } @Override public WaxmaneBakuTapEffect copy (  )  { return new WaxmaneBakuTapEffect ( this ) ; } } 
public class YomijiWhoBarsTheWay extends CardImpl { public YomijiWhoBarsTheWay ( UUID ownerId )  { super ( ownerId, 30, "Yomiji, Who Bars the Way", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{W}{W}" ) ; this . expansionSetCode = "BOK"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; FilterPermanent filter = new FilterPermanent ( "a legendary permanent other than " + getName (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new SupertypePredicate ( "Legendary" )  ) ; Effect effect = new ReturnToHandTargetEffect (  ) ; effect . setText ( "return that card to its owner's hand" ) ; this . addAbility ( new PutIntoGraveFromBattlefieldAllTriggeredAbility ( effect, false, filter, true )  ) ; } public YomijiWhoBarsTheWay ( final YomijiWhoBarsTheWay card )  { super ( card ) ; } @Override public YomijiWhoBarsTheWay copy (  )  { return new YomijiWhoBarsTheWay ( this ) ; } } 
public class AcolytesReward extends CardImpl { public AcolytesReward ( UUID ownerId )  { super ( ownerId, 1, "Acolyte's Reward", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{W}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new AcolytesRewardEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public AcolytesReward ( final AcolytesReward card )  { super ( card ) ; } @Override public AcolytesReward copy (  )  { return new AcolytesReward ( this ) ; } } class AcolytesRewardEffect extends PreventionEffectImpl { protected int amount = 0; public AcolytesRewardEffect (  )  { super ( Duration . EndOfTurn ) ; staticText = "Prevent the next X damage that would be dealt to target creature this turn, where X is your devotion to white .  If damage is prevented this way, {this} deals that much damage to target creature or player"; } public AcolytesRewardEffect ( final AcolytesRewardEffect effect )  { super ( effect ) ; this . amount = effect . amount; } @Override public AcolytesRewardEffect copy (  )  { return new AcolytesRewardEffect ( this ) ; } @Override public void init ( Ability source, Game game )  { super . init ( source, game ) ; amount = new DevotionCount ( ColoredManaSymbol . W )  . calculate ( game, source, this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { boolean result = false; int toPrevent = amount; if  ( event . getAmount (  )  < this . amount )  { toPrevent = event . getAmount (  ) ; amount -= event . getAmount (  ) ; } else { amount = 0; } GameEvent preventEvent = new GameEvent ( GameEvent . EventType . PREVENT_DAMAGE, source . getControllerId (  ) , source . getSourceId (  ) , source . getControllerId (  ) , toPrevent, false ) ; if  ( !game . replaceEvent ( preventEvent )  )  { Permanent targetCreature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( targetCreature != null )  { if  ( amount == 0 )  { this . used = true; this . discard (  ) ; } if  ( event . getAmount (  )  >= toPrevent )  { event . setAmount ( event . getAmount (  )  - toPrevent ) ; } else { event . setAmount ( 0 ) ; result = true; } if  ( toPrevent > 0 )  { game . informPlayers ( new StringBuilder ( "Acolyte's Reward " )  . append ( "prevented " )  . append ( toPrevent )  . append ( " to " )  . append ( targetCreature . getName (  )  )  . toString (  )  ) ; game . fireEvent ( GameEvent . getEvent ( GameEvent . EventType . PREVENTED_DAMAGE, source . getControllerId (  ) , source . getSourceId (  ) , source . getControllerId (  ) , toPrevent )  ) ; Player targetPlayer = game . getPlayer ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( targetPlayer != null )  { targetPlayer . damage ( toPrevent, source . getSourceId (  ) , game, false, true ) ; game . informPlayers ( new StringBuilder ( "Acolyte's Reward " )  . append ( "deals " )  . append ( toPrevent )  . append ( " damage to " )  . append ( targetPlayer . getLogName (  )  )  . toString (  )  ) ; } else { Permanent targetDamageCreature = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( targetDamageCreature != null )  { targetDamageCreature . damage ( toPrevent, source . getSourceId (  ) , game, false, true ) ; game . informPlayers ( new StringBuilder ( "Acolyte's Reward " )  . append ( "deals " )  . append ( toPrevent )  . append ( " damage to " )  . append ( targetDamageCreature . getName (  )  )  . toString (  )  ) ; } } } } } return result; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return !this . used && super . applies ( event, source, game )  && event . getTargetId (  )  . equals ( source . getFirstTarget (  )  ) ; } } 
public class AerieWorshippers extends CardImpl { public AerieWorshippers ( UUID ownerId )  { super ( ownerId, 30, "Aerie Worshippers", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new InspiredAbility ( new DoIfCostPaid ( new CreateTokenEffect ( new AerieWorshippersBirdToken (  )  ) , new ManaCostsImpl ( "{2}{U}" )  )  )  ) ; } public AerieWorshippers ( final AerieWorshippers card )  { super ( card ) ; } @Override public AerieWorshippers copy (  )  { return new AerieWorshippers ( this ) ; } } class AerieWorshippersBirdToken extends Token { public AerieWorshippersBirdToken (  )  { super ( "Bird", "2/2 blue Bird enchantment creature token with flying" ) ; cardType . add ( CardType . ENCHANTMENT ) ; cardType . add ( CardType . CREATURE ) ; color . setBlue ( true ) ; subtype . add ( "Bird" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . setOriginalExpansionSetCode ( "BNG" ) ; this . setTokenType ( 2 ) ; } } 
public class AkroanConscriptor extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another target creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public AkroanConscriptor ( UUID ownerId )  { super ( ownerId, 87, "Akroan Conscriptor", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new HeroicAbility ( new GainControlTargetEffect ( Duration . EndOfTurn, true ) , false ) ; Effect effect = new UntapTargetEffect (  ) ; effect . setText ( "Untap that creature" ) ; ability . addEffect ( effect ) ; effect = new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "It gains haste until end of turn" ) ; ability . addEffect ( effect ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; } public AkroanConscriptor ( final AkroanConscriptor card )  { super ( card ) ; } @Override public AkroanConscriptor copy (  )  { return new AkroanConscriptor ( this ) ; } } 
public class AkroanPhalanx extends CardImpl { public AkroanPhalanx ( UUID ownerId )  { super ( ownerId, 2, "Akroan Phalanx", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1,0, Duration . EndOfTurn ) , new ManaCostsImpl ( "{2}{R}" )  )  ) ; } public AkroanPhalanx ( final AkroanPhalanx card )  { super ( card ) ; } @Override public AkroanPhalanx copy (  )  { return new AkroanPhalanx ( this ) ; } } 
public class AkroanSkyguard extends CardImpl { public AkroanSkyguard ( UUID ownerId )  { super ( ownerId, 3, "Akroan Skyguard", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new HeroicAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  ) , true )  )  ) ; } public AkroanSkyguard ( final AkroanSkyguard card )  { super ( card ) ; } @Override public AkroanSkyguard copy (  )  { return new AkroanSkyguard ( this ) ; } } 
public class ArbiterOfTheIdeal extends CardImpl { public ArbiterOfTheIdeal ( UUID ownerId )  { super ( ownerId, 31, "Arbiter of the Ideal", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{U}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Sphinx" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new InspiredAbility ( new ArbiterOfTheIdealEffect (  )  )  ) ; } public ArbiterOfTheIdeal ( final ArbiterOfTheIdeal card )  { super ( card ) ; } @Override public ArbiterOfTheIdeal copy (  )  { return new ArbiterOfTheIdeal ( this ) ; } } class ArbiterOfTheIdealEffect extends OneShotEffect { private static final FilterCard filter = new FilterCard (  ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . ARTIFACT ) , new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . LAND )  )  ) ; } public ArbiterOfTheIdealEffect (  )  { super ( Outcome . PutCardInPlay ) ; this . staticText = "reveal the top card of your library .  If it's an artifact, creature, or land card, you may put it onto the battlefield with a manifestation counter on it .  It's an enchantment in addition to its other types"; } public ArbiterOfTheIdealEffect ( final ArbiterOfTheIdealEffect effect )  { super ( effect ) ; } @Override public ArbiterOfTheIdealEffect copy (  )  { return new ArbiterOfTheIdealEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player == null )  { return false; } if  ( player . getLibrary (  )  . size (  )  > 0 )  { Card card = player . getLibrary (  )  . getFromTop ( game ) ; Cards cards = new CardsImpl (  ) ; cards . add ( card ) ; player . revealCards ( "Arbiter of the Ideal", cards, game ) ; if  ( card != null )  { if  ( filter . match ( card, game )  && player . chooseUse ( outcome, new StringBuilder ( "Put " )  . append ( card . getName (  )  )  . append ( "onto battlefield?" )  . toString (  ) , source, game )  )  { card . putOntoBattlefield ( game, Zone . LIBRARY, source . getSourceId (  ) , source . getControllerId (  )  ) ; Permanent permanent = game . getPermanent ( card . getId (  )  ) ; if  ( permanent != null )  { permanent . addCounters ( new Counter ( "Manifestation" ) , game ) ; ContinuousEffect effect = new AddCardTypeTargetEffect ( CardType . ENCHANTMENT, Duration . Custom ) ; effect . setTargetPointer ( new FixedTarget ( permanent . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } } } return true; } return false; } } 
public class ArchetypeOfAggression extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public ArchetypeOfAggression ( UUID ownerId )  { super ( ownerId, 88, "Archetype of Aggression", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{R}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( TrampleAbility . getInstance (  ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent ( "Creatures" )  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect ( TrampleAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public ArchetypeOfAggression ( final ArchetypeOfAggression card )  { super ( card ) ; } @Override public ArchetypeOfAggression copy (  )  { return new ArchetypeOfAggression ( this ) ; } } 
public class ArchetypeOfCourage extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public ArchetypeOfCourage ( UUID ownerId )  { super ( ownerId, 4, "Archetype of Courage", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( FirstStrikeAbility . getInstance (  ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent ( "Creatures" )  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect ( FirstStrikeAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public ArchetypeOfCourage ( final ArchetypeOfCourage card )  { super ( card ) ; } @Override public ArchetypeOfCourage copy (  )  { return new ArchetypeOfCourage ( this ) ; } } 
public class ArchetypeOfEndurance extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public ArchetypeOfEndurance ( UUID ownerId )  { super ( ownerId, 116, "Archetype of Endurance", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{6}{G}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Boar" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( HexproofAbility . getInstance (  ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent ( "Creatures" )  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect ( HexproofAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public ArchetypeOfEndurance ( final ArchetypeOfEndurance card )  { super ( card ) ; } @Override public ArchetypeOfEndurance copy (  )  { return new ArchetypeOfEndurance ( this ) ; } } 
public class ArchetypeOfFinality extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public ArchetypeOfFinality ( UUID ownerId )  { super ( ownerId, 58, "Archetype of Finality", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{4}{B}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Gorgon" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( DeathtouchAbility . getInstance (  ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent ( "Creatures" )  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect ( DeathtouchAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public ArchetypeOfFinality ( final ArchetypeOfFinality card )  { super ( card ) ; } @Override public ArchetypeOfFinality copy (  )  { return new ArchetypeOfFinality ( this ) ; } } 
public class ArchetypeOfImagination extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public ArchetypeOfImagination ( UUID ownerId )  { super ( ownerId, 32, "Archetype of Imagination", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{4}{U}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( FlyingAbility . getInstance (  ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent ( "Creatures" )  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect ( FlyingAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public ArchetypeOfImagination ( final ArchetypeOfImagination card )  { super ( card ) ; } @Override public ArchetypeOfImagination copy (  )  { return new ArchetypeOfImagination ( this ) ; } } 
public class AshioksAdept extends CardImpl { public AshioksAdept ( UUID ownerId )  { super ( ownerId, 59, "Ashiok's Adept", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new HeroicAbility ( new DiscardEachPlayerEffect ( TargetController . OPPONENT )  )  ) ; } public AshioksAdept ( final AshioksAdept card )  { super ( card ) ; } @Override public AshioksAdept copy (  )  { return new AshioksAdept ( this ) ; } } 
public class AspectOfHydra extends CardImpl { public AspectOfHydra ( UUID ownerId )  { super ( ownerId, 117, "Aspect of Hydra", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{G}" ) ; this . expansionSetCode = "BNG"; DynamicValue greenDevotion = new DevotionCount ( ColoredManaSymbol . G ) ; Effect effect = new BoostTargetEffect ( greenDevotion, greenDevotion, Duration . EndOfTurn, true ) ; effect . setText ( "Target creature gets +X/+X until end of turn, where X is your devotion to green" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public AspectOfHydra ( final AspectOfHydra card )  { super ( card ) ; } @Override public AspectOfHydra copy (  )  { return new AspectOfHydra ( this ) ; } } 
public class Asphyxiate extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "untapped creature" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public Asphyxiate ( UUID ownerId )  { super ( ownerId, 60, "Asphyxiate", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{B}{B}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public Asphyxiate ( final Asphyxiate card )  { super ( card ) ; } @Override public Asphyxiate copy (  )  { return new Asphyxiate ( this ) ; } } 
public class AstralCornucopia extends CardImpl { public AstralCornucopia ( UUID ownerId )  { super ( ownerId, 157, "Astral Cornucopia", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{X}{X}{X}" ) ; this . expansionSetCode = "BNG"; this . addAbility ( new EntersBattlefieldAbility ( new EntersBattlefieldWithXCountersEffect ( CounterType . CHARGE . createInstance (  )  )  )  ) ; this . addAbility ( new AstralCornucopiaManaAbility (  )  ) ; } public AstralCornucopia ( final AstralCornucopia card )  { super ( card ) ; } @Override public AstralCornucopia copy (  )  { return new AstralCornucopia ( this ) ; } } class AstralCornucopiaManaAbility extends ManaAbility { public AstralCornucopiaManaAbility (  )  { super ( Zone . BATTLEFIELD, new AstralCornucopiaManaEffect (  ) , new TapSourceCost (  )  ) ; } public AstralCornucopiaManaAbility ( final AstralCornucopiaManaAbility ability )  { super ( ability ) ; } @Override public AstralCornucopiaManaAbility copy (  )  { return new AstralCornucopiaManaAbility ( this ) ; } @Override public List<Mana> getNetMana ( Game game )  { netMana . clear (  ) ; Permanent sourcePermanent = game . getPermanent ( getSourceId (  )  ) ; if  ( sourcePermanent != null )  { int counters = sourcePermanent . getCounters (  )  . getCount ( CounterType . CHARGE . getName (  )  ) ; if  ( counters > 0 )  { netMana . add ( new Mana ( 0, 0, 0, 0, 0, 0, counters, 0 )  ) ; } } return netMana; } } class AstralCornucopiaManaEffect extends ManaEffect { private final Mana computedMana; public AstralCornucopiaManaEffect (  )  { super (  ) ; computedMana = new Mana (  ) ; this . staticText = "Choose a color .  Add one mana of that color to your mana pool for each charge counter on {this}"; } public AstralCornucopiaManaEffect ( final AstralCornucopiaManaEffect effect )  { super ( effect ) ; this . computedMana = effect . computedMana . copy (  ) ; } @Override public AstralCornucopiaManaEffect copy (  )  { return new AstralCornucopiaManaEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { ChoiceColor choice = new ChoiceColor (  ) ; choice . setMessage ( "Choose a color to add mana of that color" ) ; if  ( controller . choose ( outcome, choice, game )  )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( choice . getChoice (  )  != null )  { String color = choice . getChoice (  ) ; int counters = sourcePermanent . getCounters (  )  . getCount ( CounterType . CHARGE . getName (  )  ) ; switch  ( color )  { case "Red": computedMana . setRed ( counters ) ; break; case "Blue": computedMana . setBlue ( counters ) ; break; case "White": computedMana . setWhite ( counters ) ; break; case "Black": computedMana . setBlack ( counters ) ; break; case "Green": computedMana . setGreen ( counters ) ; break; } } checkToFirePossibleEvents ( computedMana, game, source ) ; controller . getManaPool (  )  . addMana ( computedMana, game, source ) ; return true; } } return false; } @Override public Mana getMana ( Game game, Ability source )  { return null; } } 
public class BileBlight extends CardImpl { public BileBlight ( UUID ownerId )  { super ( ownerId, 61, "Bile Blight", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{B}{B}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new BileBlightEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public BileBlight ( final BileBlight card )  { super ( card ) ; } @Override public BileBlight copy (  )  { return new BileBlight ( this ) ; } } class BileBlightEffect extends BoostAllEffect { public BileBlightEffect (  )  { super ( -3, -3, Duration . EndOfTurn ) ; staticText = "Target creature and all creatures with the same name as that creature get -3/-3 until end of turn"; } public BileBlightEffect ( final BileBlightEffect effect )  { super ( effect ) ; } @Override public void init ( Ability source, Game game )  { super . init ( source, game ) ; affectedObjectList . clear (  ) ; if  ( this . affectedObjectsSet )  { Permanent target = game . getPermanent ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( target != null )  { if  ( target . getName (  )  . isEmpty (  )  )  {  
public class BlackOakOfOdunos extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another untapped creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public BlackOakOfOdunos ( UUID ownerId )  { super ( ownerId, 62, "Black Oak of Odunos", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Treefolk" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , new ManaCostsImpl ( "{B}" )  ) ; ability . addCost ( new TapTargetCost ( new TargetControlledCreaturePermanent ( 1, 1, filter, true )  )  ) ; this . addAbility ( ability ) ; } public BlackOakOfOdunos ( final BlackOakOfOdunos card )  { super ( card ) ; } @Override public BlackOakOfOdunos copy (  )  { return new BlackOakOfOdunos ( this ) ; } } 
public class BoltOfKeranos extends CardImpl { public BoltOfKeranos ( UUID ownerId )  { super ( ownerId, 89, "Bolt of Keranos", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{R}{R}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 3 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ScryEffect ( 1 )  ) ; } public BoltOfKeranos ( final BoltOfKeranos card )  { super ( card ) ; } @Override public BoltOfKeranos copy (  )  { return new BoltOfKeranos ( this ) ; } } 
public class ChargingBadger extends CardImpl { public ChargingBadger ( UUID ownerId )  { super ( ownerId, 118, "Charging Badger", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Badger" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; } public ChargingBadger ( final ChargingBadger card )  { super ( card ) ; } @Override public ChargingBadger copy (  )  { return new ChargingBadger ( this ) ; } } 
public class ChorusOfTheTides extends CardImpl { public ChorusOfTheTides ( UUID ownerId )  { super ( ownerId, 33, "Chorus of the Tides", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Siren" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new HeroicAbility ( new ScryEffect ( 1 )  )  ) ; } public ChorusOfTheTides ( final ChorusOfTheTides card )  { super ( card ) ; } @Override public ChorusOfTheTides copy (  )  { return new ChorusOfTheTides ( this ) ; } } 
public class Chromanticore extends CardImpl { public Chromanticore ( UUID ownerId )  { super ( ownerId, 144, "Chromanticore", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{W}{U}{B}{R}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Manticore" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new BestowAbility ( this, "{2}{W}{U}{B}{R}{G}" )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( LifelinkAbility . getInstance (  )  ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 4,4 )  ) ; Effect effect = new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( "and has flying" ) ; ability . addEffect ( effect ) ; effect = new GainAbilityAttachedEffect ( FirstStrikeAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( ", first strike" ) ; ability . addEffect ( effect ) ; effect = new GainAbilityAttachedEffect ( VigilanceAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( ", vigilance" ) ; ability . addEffect ( effect ) ; effect = new GainAbilityAttachedEffect ( TrampleAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( ", trample" ) ; ability . addEffect ( effect ) ; effect = new GainAbilityAttachedEffect ( LifelinkAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( "and lifelink" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public Chromanticore ( final Chromanticore card )  { super ( card ) ; } @Override public Chromanticore copy (  )  { return new Chromanticore ( this ) ; } } 
public class ClaimOfErebos extends CardImpl { public ClaimOfErebos ( UUID ownerId )  { super ( ownerId, 64, "Claim of Erebos", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability grantedAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new LoseLifeTargetEffect ( 2 ) , new ManaCostsImpl ( "{1}{B}" )  ) ; grantedAbility . addCost ( new TapSourceCost (  )  ) ; grantedAbility . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( grantedAbility, AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public ClaimOfErebos ( final ClaimOfErebos card )  { super ( card ) ; } @Override public ClaimOfErebos copy (  )  { return new ClaimOfErebos ( this ) ; } } 
public class CourserOfKruphix extends CardImpl { public CourserOfKruphix ( UUID ownerId )  { super ( ownerId, 119, "Courser of Kruphix", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Centaur" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new PlayWithTheTopCardRevealedEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new PlayTheTopCardEffect ( new FilterLandCard (  )  )  )  ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( new GainLifeEffect ( 1 ) , new FilterLandPermanent ( "a land" )  )  ) ; } public CourserOfKruphix ( final CourserOfKruphix card )  { super ( card ) ; } @Override public CourserOfKruphix copy (  )  { return new CourserOfKruphix ( this ) ; } } 
public class Crypsis extends CardImpl { public static final FilterCard filter = new FilterCard ( "creatures your opponents control" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public Crypsis ( UUID ownerId )  { super ( ownerId, 34, "Crypsis", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( new ProtectionAbility ( filter ) , Duration . EndOfTurn )  ) ; Effect effect = new UntapTargetEffect (  ) ; effect . setText ( "Untap it . " ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; } public Crypsis ( final Crypsis card )  { super ( card ) ; } @Override public Crypsis copy (  )  { return new Crypsis ( this ) ; } } 
public class CullingMark extends CardImpl { public CullingMark ( UUID ownerId )  { super ( ownerId, 120, "Culling Mark", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{G}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new BlocksIfAbleTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public CullingMark ( final CullingMark card )  { super ( card ) ; } @Override public CullingMark copy (  )  { return new CullingMark ( this ) ; } } 
public class CyclopsOfOneEyedPass extends CardImpl { public CyclopsOfOneEyedPass ( UUID ownerId )  { super ( ownerId, 90, "Cyclops of One-Eyed Pass", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Cyclops" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 2 ) ; } public CyclopsOfOneEyedPass ( final CyclopsOfOneEyedPass card )  { super ( card ) ; } @Override public CyclopsOfOneEyedPass copy (  )  { return new CyclopsOfOneEyedPass ( this ) ; } } 
public class DawnToDusk extends CardImpl { private static final FilterCard filterCard = new FilterCard ( "enchantment card from your graveyard" ) ; private static final FilterPermanent filter = new FilterPermanent ( "enchantment" ) ; static { filterCard . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public DawnToDusk ( UUID ownerId )  { super ( ownerId, 6, "Dawn to Dusk", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{W}{W}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . getModes (  )  . setMinModes ( 1 ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 2 ) ; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( filterCard )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new DestroyTargetEffect (  )  ) ; mode . getTargets (  )  . add ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addMode ( mode ) ; } public DawnToDusk ( final DawnToDusk card )  { super ( card ) ; } @Override public DawnToDusk copy (  )  { return new DawnToDusk ( this ) ; } } 
public class DeepwaterHypnotist extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature an opponent controls" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public DeepwaterHypnotist ( UUID ownerId )  { super ( ownerId, 35, "Deepwater Hypnotist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new InspiredAbility ( new BoostTargetEffect ( -3,0,Duration . EndOfTurn )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; } public DeepwaterHypnotist ( final DeepwaterHypnotist card )  { super ( card ) ; } @Override public DeepwaterHypnotist copy (  )  { return new DeepwaterHypnotist ( this ) ; } } 
public class DrownInSorrow extends CardImpl { public DrownInSorrow ( UUID ownerId )  { super ( ownerId, 65, "Drown in Sorrow", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{B}{B}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new BoostAllEffect ( -2, -2, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new ScryEffect ( 1 )  ) ; } public DrownInSorrow ( final DrownInSorrow card )  { super ( card ) ; } @Override public DrownInSorrow copy (  )  { return new DrownInSorrow ( this ) ; } } 
public class EaterOfHope extends CardImpl { private static final FilterControlledCreaturePermanent regenFilter = new FilterControlledCreaturePermanent ( "another creature" ) ; private static final FilterControlledCreaturePermanent destroyFilter = new FilterControlledCreaturePermanent ( "two other creatures" ) ; static { regenFilter . add ( new AnotherPredicate (  )  ) ; destroyFilter . add ( new AnotherPredicate (  )  ) ; } public EaterOfHope ( UUID ownerId )  { super ( ownerId, 66, "Eater of Hope", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{B}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability regenAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  ) ; regenAbility . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( 1, 1, regenFilter, true )  )  ) ; this . addAbility ( regenAbility ) ; Ability destroyAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new ManaCostsImpl ( "{2}{B}" )  ) ; destroyAbility . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( 2, 2, destroyFilter, true )  )  ) ; destroyAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( destroyAbility ) ; } public EaterOfHope ( final EaterOfHope card )  { super ( card ) ; } @Override public EaterOfHope copy (  )  { return new EaterOfHope ( this ) ; } } 
public class EidolonOfCountlessBattles extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent (  ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . CREATURE ) , new SubtypePredicate ( "Aura" )  )  ) ; } public EidolonOfCountlessBattles ( UUID ownerId )  { super ( ownerId, 7, "Eidolon of Countless Battles", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( new BestowAbility ( this, "{2}{W}{W}" )  ) ; PermanentsOnBattlefieldCount amount = new PermanentsOnBattlefieldCount ( filter, 1 ) ; Effect effect = new BoostSourceEffect ( amount, amount, Duration . WhileOnBattlefield ) ; effect . setText ( "{this} and enchanted creature get +1/+1 for each creature you control" ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, effect ) ; effect = new BoostEnchantedEffect ( amount, amount, Duration . WhileOnBattlefield ) ; effect . setText ( "and +1/+1 for each Aura you control" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public EidolonOfCountlessBattles ( final EidolonOfCountlessBattles card )  { super ( card ) ; } @Override public EidolonOfCountlessBattles copy (  )  { return new EidolonOfCountlessBattles ( this ) ; } } 
public class EliteSkirmisher extends CardImpl { public EliteSkirmisher ( UUID ownerId )  { super ( ownerId, 8, "Elite Skirmisher", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new HeroicAbility ( new TapTargetEffect (  ) , true ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public EliteSkirmisher ( final EliteSkirmisher card )  { super ( card ) ; } @Override public EliteSkirmisher copy (  )  { return new EliteSkirmisher ( this ) ; } } 
public class EpharaGodOfThePolis extends CardImpl { public EpharaGodOfThePolis ( UUID ownerId )  { super ( ownerId, 145, "Ephara, God of the Polis", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{2}{W}{U}" ) ; this . expansionSetCode = "BNG"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "God" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( IndestructibleAbility . getInstance (  )  ) ; Effect effect = new LoseCreatureTypeSourceEffect ( new DevotionCount ( ColoredManaSymbol . W, ColoredManaSymbol . U ) , 7 ) ; effect . setText ( "As long as your devotion to white and blue is less than seven, Ephara isn't a creature" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; this . addAbility ( new ConditionalTriggeredAbility (  new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , TargetController . ANY, false ) , HadAnotherCreatureEnterTheBattlefieldCondition . getInstance (  ) , "At the beginning of each upkeep, if you had another creature enter the battlefield under your control last turn, draw a card . " ) , new CreatureEnteredBattlefieldLastTurnWatcher (  )  ) ; } public EpharaGodOfThePolis ( final EpharaGodOfThePolis card )  { super ( card ) ; } @Override public EpharaGodOfThePolis copy (  )  { return new EpharaGodOfThePolis ( this ) ; } } class HadAnotherCreatureEnterTheBattlefieldCondition implements Condition { private static HadAnotherCreatureEnterTheBattlefieldCondition fInstance = new HadAnotherCreatureEnterTheBattlefieldCondition (  ) ; public static HadAnotherCreatureEnterTheBattlefieldCondition getInstance (  )  { return fInstance; } @Override public boolean apply ( Game game, Ability source )  { Watcher watcher = game . getState (  )  . getWatchers (  )  . get ( "CreatureEnteredBattlefieldLastTurnWatcher", source . getSourceId (  )  ) ; return watcher != null && watcher . conditionMet (  ) ; } } class CreatureEnteredBattlefieldLastTurnWatcher extends Watcher { private boolean anotherCreatureEntered = false; public CreatureEnteredBattlefieldLastTurnWatcher (  )  { super ( "CreatureEnteredBattlefieldLastTurnWatcher", WatcherScope . CARD ) ; } public CreatureEnteredBattlefieldLastTurnWatcher ( final CreatureEnteredBattlefieldLastTurnWatcher watcher )  { super ( watcher ) ; this . anotherCreatureEntered = watcher . anotherCreatureEntered; } @Override public void watch ( GameEvent event, Game game )  { if  ( !anotherCreatureEntered && event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD )  { if  ( !event . getTargetId (  )  . equals ( this . getSourceId (  )  )  && event . getPlayerId (  )  . equals ( this . getControllerId (  )  )  )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null && permanent . getCardType (  )  . contains ( CardType . CREATURE )  )  { anotherCreatureEntered = true; } } } } @Override public void reset (  )  { condition = anotherCreatureEntered; anotherCreatureEntered = false; } @Override public CreatureEnteredBattlefieldLastTurnWatcher copy (  )  { return new CreatureEnteredBattlefieldLastTurnWatcher ( this ) ; } } 
public class EpharasEnlightenment extends CardImpl { public EpharasEnlightenment ( UUID ownerId )  { super ( ownerId, 146, "Ephara's Enlightenment", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new AddCountersAttachedEffect ( CounterType . P1P1 . createInstance (  ) , "enchanted creature" ) , false )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( Zone . BATTLEFIELD, new ReturnToHandSourceEffect ( true ) , new FilterCreaturePermanent ( "a creature" ) , true )  ) ; } public EpharasEnlightenment ( final EpharasEnlightenment card )  { super ( card ) ; } @Override public EpharasEnlightenment copy (  )  { return new EpharasEnlightenment ( this ) ; } } 
public class EpharasRadiance extends CardImpl { public EpharasRadiance ( UUID ownerId )  { super ( ownerId, 9, "Ephara's Radiance", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 3 ) , new ManaCostsImpl ( "{1}{W}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability, AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public EpharasRadiance ( final EpharasRadiance card )  { super ( card ) ; } @Override public EpharasRadiance copy (  )  { return new EpharasRadiance ( this ) ; } } 
public class EpiphanyStorm extends CardImpl { public EpiphanyStorm ( UUID ownerId )  { super ( ownerId, 91, "Epiphany Storm", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability drawAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new ManaCostsImpl ( "{R}" )  ) ; drawAbility . addCost ( new TapSourceCost (  )  ) ; drawAbility . addCost ( new DiscardCardCost (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( drawAbility, AttachmentType . AURA )  )  ) ; } public EpiphanyStorm ( final EpiphanyStorm card )  { super ( card ) ; } @Override public EpiphanyStorm copy (  )  { return new EpiphanyStorm ( this ) ; } } 
public class Excoriate extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "tapped creature" ) ; static { filter . add ( new TappedPredicate (  )  ) ; } public Excoriate ( UUID ownerId )  { super ( ownerId, 10, "Excoriate", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{W}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new ExileTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public Excoriate ( final Excoriate card )  { super ( card ) ; } @Override public Excoriate copy (  )  { return new Excoriate ( this ) ; } } 
public class EyeGouge extends CardImpl { public EyeGouge ( UUID ownerId )  { super ( ownerId, 67, "Eye Gouge", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{B}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( -1,-1, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new ConditionalOneShotEffect ( new DestroyTargetEffect (  ) , new TargetHasSubtypeCondition ( "Cyclops" ) , "If it's a Cyclops, destroy it" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public EyeGouge ( final EyeGouge card )  { super ( card ) ; } @Override public EyeGouge copy (  )  { return new EyeGouge ( this ) ; } } 
public class FallOfTheHammer extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another target creature" ) ; public FallOfTheHammer ( UUID ownerId )  { super ( ownerId, 93, "Fall of the Hammer", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new FallOfTheHammerDamageEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addTarget ( new FallOfTheHammerTargetCreaturePermanent ( filter )  ) ; } public FallOfTheHammer ( final FallOfTheHammer card )  { super ( card ) ; } @Override public FallOfTheHammer copy (  )  { return new FallOfTheHammer ( this ) ; } } class FallOfTheHammerDamageEffect extends OneShotEffect { public FallOfTheHammerDamageEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "Target creature you control deals damage equal to its power to another target creature"; } public FallOfTheHammerDamageEffect ( final FallOfTheHammerDamageEffect effect )  { super ( effect ) ; } @Override public FallOfTheHammerDamageEffect copy (  )  { return new FallOfTheHammerDamageEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent ownCreature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( ownCreature != null )  { int damage = ownCreature . getPower (  )  . getValue (  ) ; Permanent targetCreature = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( targetCreature != null )  { targetCreature . damage ( damage, ownCreature . getId (  ) , game, false, true ) ; return true; } } return false; } } class FallOfTheHammerTargetCreaturePermanent extends TargetCreaturePermanent { public FallOfTheHammerTargetCreaturePermanent ( FilterCreaturePermanent filter )  { super ( filter ) ; } @Override public boolean canTarget ( UUID id, Ability source, Game game )  { if  ( source . getTargets (  )  . getFirstTarget (  )  . equals ( id )  )  { return false; } return super . canTarget ( id, source, game ) ; } @Override public boolean canTarget ( UUID controllerId, UUID id, Ability source, Game game )  { if  ( source . getTargets (  )  . getFirstTarget (  )  . equals ( id )  )  { return false; } return super . canTarget ( controllerId, id, source, game ) ; } } 
public class FanaticOfXenagos extends CardImpl { public FanaticOfXenagos ( UUID ownerId )  { super ( ownerId, 147, "Fanatic of Xenagos", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Centaur" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new TributeAbility ( 1 )  ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new BoostSourceEffect ( 1,1, Duration . EndOfTurn )  ) ; ability . addEffect (  new GainAbilitySourceEffect ( new GainAbilitySourceEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn )  )  ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, TributeNotPaidCondition . getInstance (  ) , "When {this} enters the battlefield, if its tribute wasn't paid, it gets +1/+1 and gains haste until end of turn . " )  ) ; } public FanaticOfXenagos ( final FanaticOfXenagos card )  { super ( card ) ; } @Override public FanaticOfXenagos copy (  )  { return new FanaticOfXenagos ( this ) ; } } 
public class FatedConflagration extends CardImpl { public FatedConflagration ( UUID ownerId )  { super ( ownerId, 94, "Fated Conflagration", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{1}{R}{R}{R}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 5 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlaneswalker (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect ( new ScryEffect ( 2 ) , MyTurnCondition . getInstance (  ) , "If it's your turn, scry 2" )  ) ; } public FatedConflagration ( final FatedConflagration card )  { super ( card ) ; } @Override public FatedConflagration copy (  )  { return new FatedConflagration ( this ) ; } } 
public class FatedInfatuation extends CardImpl { public FatedInfatuation ( UUID ownerId )  { super ( ownerId, 39, "Fated Infatuation", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{U}{U}{U}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new PutTokenOntoBattlefieldCopyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect ( new ScryEffect ( 2 ) , MyTurnCondition . getInstance (  ) , "If it's your turn, scry 2" )  ) ; } public FatedInfatuation ( final FatedInfatuation card )  { super ( card ) ; } @Override public FatedInfatuation copy (  )  { return new FatedInfatuation ( this ) ; } } 
public class FatedIntervention extends CardImpl { public FatedIntervention ( UUID ownerId )  { super ( ownerId, 121, "Fated Intervention", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{2}{G}{G}{G}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new CentaurEnchantmentCreatureToken (  ) , 2 )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect ( new ScryEffect ( 2 ) , MyTurnCondition . getInstance (  ) , "If it's your turn, scry 2" )  ) ; } public FatedIntervention ( final FatedIntervention card )  { super ( card ) ; } @Override public FatedIntervention copy (  )  { return new FatedIntervention ( this ) ; } } 
public class FatedRetribution extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "creatures and planeswalkers" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . PLANESWALKER )  )  ) ; } public FatedRetribution ( UUID ownerId )  { super ( ownerId, 11, "Fated Retribution", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{4}{W}{W}{W}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new DestroyAllEffect ( filter, false )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect ( new ScryEffect ( 2 ) , MyTurnCondition . getInstance (  ) , "If it's your turn, scry 2" )  ) ; } public FatedRetribution ( final FatedRetribution card )  { super ( card ) ; } @Override public FatedRetribution copy (  )  { return new FatedRetribution ( this ) ; } } 
public class FatedReturn extends CardImpl { public FatedReturn ( UUID ownerId )  { super ( ownerId, 69, "Fated Return", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{4}{B}{B}{B}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToBattlefieldTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInGraveyard ( new FilterCreatureCard ( "creature card from a graveyard" )  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( IndestructibleAbility . getInstance (  ) , Duration . Custom, "It gains indestructible" )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect ( new ScryEffect ( 2 ) , MyTurnCondition . getInstance (  ) , "If it's your turn, scry 2 <i> ( Look at the top two cards of your library, then put any number of them on the bottom of your library and the rest on top in any order .  ) </i>" )  ) ; } public FatedReturn ( final FatedReturn card )  { super ( card ) ; } @Override public FatedReturn copy (  )  { return new FatedReturn ( this ) ; } } 
public class FateUnraveler extends CardImpl { public FateUnraveler ( UUID ownerId )  { super ( ownerId, 68, "Fate Unraveler", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Hag" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new DrawCardOpponentTriggeredAbility ( new DamageTargetEffect ( 1, true, "that player" ) , false, true )  ) ; } public FateUnraveler ( final FateUnraveler card )  { super ( card ) ; } @Override public FateUnraveler copy (  )  { return new FateUnraveler ( this ) ; } } 
public class FearsomeTemper extends CardImpl { public FearsomeTemper ( UUID ownerId )  { super ( ownerId, 95, "Fearsome Temper", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Effect effect = new BoostEnchantedEffect ( 2,2, Duration . WhileOnBattlefield ) ; effect . setText ( "Enchanted creature gets +2/+2" ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, effect ) ; Ability grantedAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBeBlockedByTargetSourceEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{2}{R}" )  ) ; grantedAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; effect = new GainAbilityAttachedEffect ( grantedAbility, AttachmentType . AURA, Duration . WhileOnBattlefield ) ; effect . setText ( "and has \"{2}{R}: Target creature can't block this creature this turn" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public FearsomeTemper ( final FearsomeTemper card )  { super ( card ) ; } @Override public FearsomeTemper copy (  )  { return new FearsomeTemper ( this ) ; } } 
public class FelhideBrawler extends CardImpl { public FelhideBrawler ( UUID ownerId )  { super ( ownerId, 70, "Felhide Brawler", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Minotaur" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new FelhideBrawlerRestrictionEffect (  )  )  ) ; } public FelhideBrawler ( final FelhideBrawler card )  { super ( card ) ; } @Override public FelhideBrawler copy (  )  { return new FelhideBrawler ( this ) ; } } class FelhideBrawlerRestrictionEffect extends RestrictionEffect { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another Minotaur" ) ; static { filter . add ( new SubtypePredicate ( "Minotaur" )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public FelhideBrawlerRestrictionEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "{this} can't block unless you control another Minotaur"; } public FelhideBrawlerRestrictionEffect ( final FelhideBrawlerRestrictionEffect effect )  { super ( effect ) ; } @Override public FelhideBrawlerRestrictionEffect copy (  )  { return new FelhideBrawlerRestrictionEffect ( this ) ; } @Override public boolean canBlock ( Permanent attacker, Permanent blocker, Ability source, Game game )  { return false; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { if  ( permanent . getId (  )  . equals ( source . getSourceId (  )  )  && game . getBattlefield (  )  . count ( filter, source . getSourceId (  ) , source . getControllerId (  ) , game )  == 0 )  { return true; } return false; } } 
public class FelhideSpiritbinder extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public FelhideSpiritbinder ( UUID ownerId )  { super ( ownerId, 96, "Felhide Spiritbinder", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new InspiredAbility ( new DoIfCostPaid ( new FelhideSpiritbinderEffect (  ) , new ManaCostsImpl ( "{1}{R}" ) , "Use effect of {source}?" )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; } public FelhideSpiritbinder ( final FelhideSpiritbinder card )  { super ( card ) ; } @Override public FelhideSpiritbinder copy (  )  { return new FelhideSpiritbinder ( this ) ; } } class FelhideSpiritbinderEffect extends OneShotEffect { public FelhideSpiritbinderEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "put a token onto the battlefield that's a copy of another target creature except it's an enchantment in addition to its other types .  It gains haste .  Exile it at the beginning of the next end step"; } public FelhideSpiritbinderEffect ( final FelhideSpiritbinderEffect effect )  { super ( effect ) ; } @Override public FelhideSpiritbinderEffect copy (  )  { return new FelhideSpiritbinderEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanentOrLKIBattlefield ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect ( null, CardType . ENCHANTMENT, true ) ; effect . setTargetPointer ( getTargetPointer (  )  ) ; if  ( effect . apply ( game, source )  )  { for  ( Permanent tokenPermanent : effect . getAddedPermanent (  )  )  { ExileTargetEffect exileEffect = new ExileTargetEffect (  ) ; exileEffect . setTargetPointer ( new FixedTarget ( tokenPermanent, game )  ) ; DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( exileEffect ) ; game . addDelayedTriggeredAbility ( delayedAbility, source ) ; } return true; } } return false; } } 
public class FlameWreathedPhoenix extends CardImpl { public FlameWreathedPhoenix ( UUID ownerId )  { super ( ownerId, 97, "Flame-Wreathed Phoenix", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Phoenix" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new TributeAbility ( 2 )  ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new GainAbilitySourceEffect ( HasteAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; Effect effect = new GainAbilitySourceEffect ( new DiesTriggeredAbility ( new ReturnToHandSourceEffect (  )  )  ) ; ability . addEffect ( effect ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, TributeNotPaidCondition . getInstance (  ) , "When {this} enters the battlefield, if its tribute wasn't paid, it gains haste and \"When this creature dies, return it to its owner's hand . \"" )  ) ; } public FlameWreathedPhoenix ( final FlameWreathedPhoenix card )  { super ( card ) ; } @Override public FlameWreathedPhoenix copy (  )  { return new FlameWreathedPhoenix ( this ) ; } } 
public class FlitterstepEidolon extends CardImpl { public FlitterstepEidolon ( UUID ownerId )  { super ( ownerId, 40, "Flitterstep Eidolon", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BestowAbility ( this, "{5}{U}" )  ) ; this . addAbility ( new CantBeBlockedSourceAbility (  )  ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1,1, Duration . WhileOnBattlefield )  ) ; ability . addEffect ( new CantBeBlockedAttachedEffect ( AttachmentType . AURA )  ) ; this . addAbility ( ability ) ; } public FlitterstepEidolon ( final FlitterstepEidolon card )  { super ( card ) ; } @Override public FlitterstepEidolon copy (  )  { return new FlitterstepEidolon ( this ) ; } } 
public class FloodtideSerpent extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an enchantment you control" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public FloodtideSerpent ( UUID ownerId )  { super ( ownerId, 41, "Floodtide Serpent", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Serpent" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantAttackBlockUnlessPaysSourceEffect (  new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  ) , PayCostToAttackBlockEffectImpl . RestrictType . ATTACK )  )  ) ; } public FloodtideSerpent ( final FloodtideSerpent card )  { super ( card ) ; } @Override public FloodtideSerpent copy (  )  { return new FloodtideSerpent ( this ) ; } } class FloodtideSerpentReplacementEffect extends ReplacementEffectImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an enchantment you control" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } FloodtideSerpentReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Neutral ) ; staticText = "{this} can't attack unless you return an enchantment you control to its owner's hand <i> ( This cost is paid as attackers are declared .  ) </i>"; } FloodtideSerpentReplacementEffect ( FloodtideSerpentReplacementEffect effect )  { super ( effect ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { Player player = game . getPlayer ( event . getPlayerId (  )  ) ; if  ( player != null )  { ReturnToHandChosenControlledPermanentCost attackCost = new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  ) ; if  ( attackCost . canPay ( source, source . getSourceId (  ) , event . getPlayerId (  ) , game )  && player . chooseUse ( Outcome . Neutral, "Return an enchantment you control to hand to attack?", source, game )  )  { if  ( attackCost . pay ( source, game, source . getSourceId (  ) , event . getPlayerId (  ) , true, null )  )  { return false; } } return true; } return false; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DECLARE_ATTACKER; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getSourceId (  )  . equals ( source . getSourceId (  )  ) ; } @Override public FloodtideSerpentReplacementEffect copy (  )  { return new FloodtideSerpentReplacementEffect ( this ) ; } } 
public class ForgestokerDragon extends CardImpl { public ForgestokerDragon ( UUID ownerId )  { super ( ownerId, 98, "Forgestoker Dragon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{R}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new ActivateIfConditionActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new ManaCostsImpl ( "{1}{R}" ) , new SourceAttackingCondition (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new CantBlockTargetEffect ( Duration . EndOfCombat ) ; effect . setText ( "That creature can't block this combat" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public ForgestokerDragon ( final ForgestokerDragon card )  { super ( card ) ; } @Override public ForgestokerDragon copy (  )  { return new ForgestokerDragon ( this ) ; } } 
public class ForlornPseudamma extends CardImpl { public ForlornPseudamma ( UUID ownerId )  { super ( ownerId, 71, "Forlorn Pseudamma", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( IntimidateAbility . getInstance (  )  ) ; this . addAbility ( new InspiredAbility ( new DoIfCostPaid ( new CreateTokenEffect ( new ForlornPseudammaZombieToken (  )  ) , new ManaCostsImpl ( "{2}{B}" )  )  )  ) ; } public ForlornPseudamma ( final ForlornPseudamma card )  { super ( card ) ; } @Override public ForlornPseudamma copy (  )  { return new ForlornPseudamma ( this ) ; } } class ForlornPseudammaZombieToken extends Token { public ForlornPseudammaZombieToken (  )  { super ( "Zombie", "2/2 black Zombie enchantment creature token" ) ; cardType . add ( CardType . ENCHANTMENT ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Zombie" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 2 ) ; this . setOriginalExpansionSetCode ( "BNG" ) ; } } 
public class Gild extends CardImpl { public Gild ( UUID ownerId )  { super ( ownerId, 73, "Gild", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{B}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new ExileTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new CreateTokenEffect ( new GoldToken (  )  ) ; effect . setText ( "Put a colorless artifact token named Gold onto the battlefield .  It has \"Sacrifice this artifact: Add one mana of any color to your mana pool . \"" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public Gild ( final Gild card )  { super ( card ) ; } @Override public Gild copy (  )  { return new Gild ( this ) ; } } 
public class GlimpseTheSunGod extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creatures" ) ; public GlimpseTheSunGod ( UUID ownerId )  { super ( ownerId, 13, "Glimpse the Sun God", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{X}{W}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new TapTargetEffect ( "X target creatures" )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 1,filter, false )  ) ; this . getSpellAbility (  )  . addEffect ( new ScryEffect ( 1 )  ) ; } public GlimpseTheSunGod ( final GlimpseTheSunGod card )  { super ( card ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SpellAbility )  { ability . getTargets (  )  . clear (  ) ; int numberToTap = ability . getManaCostsToPay (  )  . getX (  ) ; numberToTap = Math . min ( game . getBattlefield (  )  . count ( filter, ability . getSourceId (  ) , ability . getControllerId (  ) , game ) , numberToTap ) ; ability . addTarget ( new TargetCreaturePermanent ( numberToTap, numberToTap, filter, false )  ) ; } } @Override public GlimpseTheSunGod copy (  )  { return new GlimpseTheSunGod ( this ) ; } } 
public class GodFavoredGeneral extends CardImpl { public GodFavoredGeneral ( UUID ownerId )  { super ( ownerId, 14, "God-Favored General", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new InspiredAbility ( new DoIfCostPaid ( new CreateTokenEffect ( new SoldierToken (  ) , 2 ) , new ManaCostsImpl ( "{2}{W}" )  )  )  ) ; } public GodFavoredGeneral ( final GodFavoredGeneral card )  { super ( card ) ; } @Override public GodFavoredGeneral copy (  )  { return new GodFavoredGeneral ( this ) ; } } class SoldierToken extends Token { public SoldierToken (  )  { super ( "Soldier", "1/1 white Soldier enchantment creature token" ) ; cardType . add ( CardType . ENCHANTMENT ) ; cardType . add ( CardType . CREATURE ) ; color . setWhite ( true ) ; subtype . add ( "Soldier" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; this . setOriginalExpansionSetCode ( "BNG" ) ; } } 
public class GorgonsHead extends CardImpl { public GorgonsHead ( UUID ownerId )  { super ( ownerId, 158, "Gorgon's Head", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( DeathtouchAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new ManaCostsImpl ( "{2}" )  )  ) ; } public GorgonsHead ( final GorgonsHead card )  { super ( card ) ; } @Override public GorgonsHead copy (  )  { return new GorgonsHead ( this ) ; } } 
public class GraverobberSpider extends CardImpl { public GraverobberSpider ( UUID ownerId )  { super ( ownerId, 122, "Graverobber Spider", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Spider" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; DynamicValue xValue = new CardsInControllerGraveyardCount ( new FilterCreatureCard ( "creature cards" )  ) ; Ability ability = new LimitedTimesPerTurnActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( xValue, xValue, Duration . EndOfTurn, true ) , new ManaCostsImpl ( "{3}{B}" )  ) ; this . addAbility ( ability ) ; } public GraverobberSpider ( final GraverobberSpider card )  { super ( card ) ; } @Override public GraverobberSpider copy (  )  { return new GraverobberSpider ( this ) ; } } 
public class GreatHart extends CardImpl { public GreatHart ( UUID ownerId )  { super ( ownerId, 15, "Great Hart", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Elk" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; } public GreatHart ( final GreatHart card )  { super ( card ) ; } @Override public GreatHart copy (  )  { return new GreatHart ( this ) ; } } 
public class GriffinDreamfinder extends CardImpl { private static final FilterCard filter = new FilterCard ( "enchantment card from your graveyard" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public GriffinDreamfinder ( UUID ownerId )  { super ( ownerId, 16, "Griffin Dreamfinder", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Griffin" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new ReturnFromGraveyardToHandTargetEffect (  ) , false ) ; ability . addTarget ( new TargetCardInYourGraveyard ( filter )  ) ; this . addAbility ( ability ) ; } public GriffinDreamfinder ( final GriffinDreamfinder card )  { super ( card ) ; } @Override public GriffinDreamfinder copy (  )  { return new GriffinDreamfinder ( this ) ; } } 
public class GrislyTransformation extends CardImpl { public GrislyTransformation ( UUID ownerId )  { super ( ownerId, 74, "Grisly Transformation", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( IntimidateAbility . getInstance (  ) , AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public GrislyTransformation ( final GrislyTransformation card )  { super ( card ) ; } @Override public GrislyTransformation copy (  )  { return new GrislyTransformation ( this ) ; } } 
public class HeraldOfTorment extends CardImpl { public HeraldOfTorment ( UUID ownerId )  { super ( ownerId, 75, "Herald of Torment", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new BestowAbility ( this, "{3}{B}{B}" )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new LoseLifeSourceControllerEffect ( 1 ) , TargetController . YOU, false )  ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 3, 3 )  ) ; Effect effect = new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( "and has flying" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public HeraldOfTorment ( final HeraldOfTorment card )  { super ( card ) ; } @Override public HeraldOfTorment copy (  )  { return new HeraldOfTorment ( this ) ; } } 
public class HeroesPodium extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Each legendary creature you control" ) ; static { filter . add ( new SupertypePredicate ( "Legendary" )  ) ; } public HeroesPodium ( UUID ownerId )  { super ( ownerId, 159, "Heroes' Podium", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{5}" ) ; this . expansionSetCode = "BNG"; this . supertype . add ( "Legendary" ) ; DynamicValue xValue = new HeroesPodiumLegendaryCount (  ) ; Effect effect = new BoostControlledEffect ( xValue, xValue, Duration . WhileOnBattlefield, filter, false ) ; effect . setText ( "Each legendary creature you control gets +1/+1 for each other legendary creature you control" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new HeroesPodiumEffect (  ) , new ManaCostsImpl ( "{X}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public HeroesPodium ( final HeroesPodium card )  { super ( card ) ; } @Override public HeroesPodium copy (  )  { return new HeroesPodium ( this ) ; } } class HeroesPodiumLegendaryCount implements DynamicValue { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "other legendary creature you control" ) ; static { filter . add ( new SupertypePredicate ( "Legendary" )  ) ; } @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { int value = game . getBattlefield (  )  . count ( filter, sourceAbility . getSourceId (  ) , sourceAbility . getControllerId (  ) , game ) ; if  ( value > 0 )  { value--; } return value; } @Override public String toString (  )  { return "X"; } @Override public String getMessage (  )  { return filter . getMessage (  ) ; } @Override public HeroesPodiumLegendaryCount copy (  )  { return new HeroesPodiumLegendaryCount (  ) ; } } class HeroesPodiumEffect extends OneShotEffect { private static final FilterCreatureCard filter = new FilterCreatureCard ( "a legendary creature card" ) ; static { filter . add ( new SupertypePredicate (  ( "Legendary" )  )  ) ; } public HeroesPodiumEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Look at the top X cards of your library .  You may reveal a legendary creature card from among them and put it into your hand .  Put the rest on the bottom of your library in a random order"; } public HeroesPodiumEffect ( final HeroesPodiumEffect effect )  { super ( effect ) ; } @Override public HeroesPodiumEffect copy (  )  { return new HeroesPodiumEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player == null )  { return false; } Cards cards = new CardsImpl (  ) ; int count = source . getManaCostsToPay (  )  . getX (  ) ; count = Math . min ( player . getLibrary (  )  . size (  ) , count ) ; boolean legendaryIncluded = false; for  ( int i = 0; i < count; i++ )  { Card card = player . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { cards . add ( card ) ; if  ( filter . match ( card, game )  )  { legendaryIncluded = true; } } } player . lookAtCards ( "Heroes' Podium", cards, game ) ; if  ( !cards . isEmpty (  )  && legendaryIncluded && player . chooseUse ( outcome, "Put a legendary creature card into your hand?", source, game )  )  { if  ( cards . size (  )  == 1 )  { Card card = cards . getRandom ( game ) ; cards . remove ( card ) ; card . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; return true; } else { TargetCard target = new TargetCard ( Zone . LIBRARY, filter ) ; if  ( player . choose ( outcome, cards, target, game )  )  { Card card = cards . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { cards . remove ( card ) ; card . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; } } } } while  ( cards . size (  )  > 0 )  { Card card = cards . getRandom ( game ) ; if  ( card != null )  { cards . remove ( card ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } } return true; } } 
public class HeroOfIroas extends CardImpl { private static final FilterCard filter = new FilterCard ( "Aura spells" ) ; static { filter . add ( new SubtypePredicate ( "Aura" )  ) ; } public HeroOfIroas ( UUID ownerId )  { super ( ownerId, 17, "Hero of Iroas", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SpellsCostReductionControllerEffect ( filter, 1 )  )  ) ; this . addAbility ( new HeroicAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  )  )  ) ; } public HeroOfIroas ( final HeroOfIroas card )  { super ( card ) ; } @Override public HeroOfIroas copy (  )  { return new HeroOfIroas ( this ) ; } } 
public class HeroOfLeinaTower extends CardImpl { public HeroOfLeinaTower ( UUID ownerId )  { super ( ownerId, 123, "Hero of Leina Tower", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new HeroicAbility ( new HeroOfLeinaTowerEffect (  )  )  ) ; } public HeroOfLeinaTower ( final HeroOfLeinaTower card )  { super ( card ) ; } @Override public HeroOfLeinaTower copy (  )  { return new HeroOfLeinaTower ( this ) ; } } class HeroOfLeinaTowerEffect extends OneShotEffect { public HeroOfLeinaTowerEffect (  )  { super ( Outcome . BoostCreature ) ; staticText = "you may pay {X} .  If you do, put X +1/+1 counters on {this}"; } public HeroOfLeinaTowerEffect ( final HeroOfLeinaTowerEffect effect )  { super ( effect ) ; } @Override public HeroOfLeinaTowerEffect copy (  )  { return new HeroOfLeinaTowerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player you = game . getPlayer ( source . getControllerId (  )  ) ; ManaCosts cost = new ManaCostsImpl ( "{X}" ) ; if  ( you != null && you . chooseUse ( Outcome . BoostCreature, "Do you want to to pay {X}?", source, game )  )  { int costX = you . announceXMana ( 0, Integer . MAX_VALUE, "Announce the value for {X}", game, source ) ; cost . add ( new GenericManaCost ( costX )  ) ; if  ( cost . pay ( source, game, source . getSourceId (  ) , source . getControllerId (  ) , false, null )  )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { return new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( costX ) , true )  . apply ( game, source ) ; } } } return false; } } 
public class HoldAtBay extends CardImpl { public HoldAtBay ( UUID ownerId )  { super ( ownerId, 18, "Hold at Bay", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{W}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new PreventDamageToTargetEffect ( Duration . EndOfTurn, 7 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public HoldAtBay ( final HoldAtBay card )  { super ( card ) ; } @Override public HoldAtBay copy (  )  { return new HoldAtBay ( this ) ; } } 
public class HuntersProwess extends CardImpl { public HuntersProwess ( UUID ownerId )  { super ( ownerId, 124, "Hunter's Prowess", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{4}{G}" ) ; this . expansionSetCode = "BNG"; Effect effect = new BoostTargetEffect ( 3,3, Duration . EndOfTurn ) ; effect . setText ( "Until end of turn, target creature gets +3/+3" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; effect = new GainAbilityTargetEffect ( TrampleAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains trample" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; Ability grantedAbility = new DealsCombatDamageToAPlayerTriggeredAbility ( new HuntersProwessDrawEffect (  ) , false, true ) ; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( grantedAbility, Duration . EndOfTurn, "and \"Whenever this creature deals combat damage to a player, draw that many cards . \"" )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public HuntersProwess ( final HuntersProwess card )  { super ( card ) ; } @Override public HuntersProwess copy (  )  { return new HuntersProwess ( this ) ; } } class HuntersProwessDrawEffect extends OneShotEffect { public HuntersProwessDrawEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "draw that many cards"; } public HuntersProwessDrawEffect ( final HuntersProwessDrawEffect effect )  { super ( effect ) ; } @Override public HuntersProwessDrawEffect copy (  )  { return new HuntersProwessDrawEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { int damage =  ( Integer )  this . getValue ( "damage" ) ; if  ( damage > 0 )  { controller . drawCards ( damage, game ) ; } return true; } return false; } } 
public class ImpetuousSunchaser extends CardImpl { public ImpetuousSunchaser ( UUID ownerId )  { super ( ownerId, 99, "Impetuous Sunchaser", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new AttacksEachTurnStaticAbility (  )  ) ; } public ImpetuousSunchaser ( final ImpetuousSunchaser card )  { super ( card ) ; } @Override public ImpetuousSunchaser copy (  )  { return new ImpetuousSunchaser ( this ) ; } } 
public class KarametraGodOfHarvests extends CardImpl { private static final FilterCard filter = new FilterCard ( "a Forest or Plains card" ) ; static { filter . add ( Predicates . or (  new SubtypePredicate ( "Forest" ) , new SubtypePredicate ( "Plains" )  )  ) ; } public KarametraGodOfHarvests ( UUID ownerId )  { super ( ownerId, 148, "Karametra, God of Harvests", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{3}{G}{W}" ) ; this . expansionSetCode = "BNG"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "God" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( IndestructibleAbility . getInstance (  )  ) ; Effect effect = new LoseCreatureTypeSourceEffect ( new DevotionCount ( ColoredManaSymbol . G, ColoredManaSymbol . W ) , 7 ) ; effect . setText ( "As long as your devotion to green and white is less than seven, Karametra isn't a creature" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility (  new SearchLibraryPutInPlayEffect ( new TargetCardInLibrary ( filter ) , true ) , new FilterCreatureSpell ( "a creature spell" ) , true )  ) ; } public KarametraGodOfHarvests ( final KarametraGodOfHarvests card )  { super ( card ) ; } @Override public KarametraGodOfHarvests copy (  )  { return new KarametraGodOfHarvests ( this ) ; } } 
public class KarametrasFavor extends CardImpl { public KarametrasFavor ( UUID ownerId )  { super ( ownerId, 125, "Karametra's Favor", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; Effect effect = new GainAbilityAttachedEffect ( new AnyColorManaAbility (  ) , AttachmentType . AURA, Duration . WhileOnBattlefield ) ; effect . setText ( "Enchanted creature has \"{T}: Add one mana of any color to your mana pool . \"" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public KarametrasFavor ( final KarametrasFavor card )  { super ( card ) ; } @Override public KarametrasFavor copy (  )  { return new KarametrasFavor ( this ) ; } } 
public class KiorasFollower extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "another target permanent" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public KiorasFollower ( UUID ownerId )  { super ( ownerId, 150, "Kiora's Follower", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{G}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Merfolk" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new UntapTargetEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public KiorasFollower ( final KiorasFollower card )  { super ( card ) ; } @Override public KiorasFollower copy (  )  { return new KiorasFollower ( this ) ; } } 
public class KrakenOfTheStraits extends CardImpl { public KrakenOfTheStraits ( UUID ownerId )  { super ( ownerId, 42, "Kraken of the Straits", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{U}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Kraken" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeBlockedByCreaturesWithLessPowerEffect (  )  )  ) ; } public KrakenOfTheStraits ( final KrakenOfTheStraits card )  { super ( card ) ; } @Override public KrakenOfTheStraits copy (  )  { return new KrakenOfTheStraits ( this ) ; } } class CantBeBlockedByCreaturesWithLessPowerEffect extends RestrictionEffect { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "Islands" ) ; static { filter . add ( new SubtypePredicate ( "Island" )  ) ; } private final DynamicValue dynamicValue = new PermanentsOnBattlefieldCount ( filter ) ; public CantBeBlockedByCreaturesWithLessPowerEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "Creatures with power less than the number of Islands you control can't block {this}"; } public CantBeBlockedByCreaturesWithLessPowerEffect ( final CantBeBlockedByCreaturesWithLessPowerEffect effect )  { super ( effect ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { return permanent . getId (  )  . equals ( source . getSourceId (  )  ) ; } @Override public boolean canBeBlocked ( Permanent attacker, Permanent blocker, Ability source, Game game )  { return blocker . getPower (  )  . getValue (  )  >= dynamicValue . calculate ( game, source, this ) ; } @Override public CantBeBlockedByCreaturesWithLessPowerEffect copy (  )  { return new CantBeBlockedByCreaturesWithLessPowerEffect ( this ) ; } } 
public class LightningVolley extends CardImpl { public LightningVolley ( UUID ownerId )  { super ( ownerId, 101, "Lightning Volley", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{R}" ) ; this . expansionSetCode = "BNG"; Ability grantedAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; grantedAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; Effect effect = new GainAbilityControlledEffect ( grantedAbility, Duration . EndOfTurn, new FilterCreaturePermanent ( "Creatures" )  ) ; effect . setText ( "Until end of turn, creatures you control gain \"{T}: This creature deals 1 damage to target creature or player . \"" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public LightningVolley ( final LightningVolley card )  { super ( card ) ; } @Override public LightningVolley copy (  )  { return new LightningVolley ( this ) ; } } 
public class LoyalPegasus extends CardImpl { public LoyalPegasus ( UUID ownerId )  { super ( ownerId, 19, "Loyal Pegasus", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Pegasus" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new CantAttackAloneAbility (  )  ) ; this . addAbility ( CantBlockAloneAbility . getInstance (  )  ) ; } public LoyalPegasus ( final LoyalPegasus card )  { super ( card ) ; } @Override public LoyalPegasus copy (  )  { return new LoyalPegasus ( this ) ; } } 
public class MarshmistTitan extends CardImpl { public MarshmistTitan ( UUID ownerId )  { super ( ownerId, 76, "Marshmist Titan", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{6}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Giant" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . STACK, new MarshmistTitanCostReductionEffect (  )  )  ) ; } public MarshmistTitan ( final MarshmistTitan card )  { super ( card ) ; } @Override public MarshmistTitan copy (  )  { return new MarshmistTitan ( this ) ; } } class MarshmistTitanCostReductionEffect extends CostModificationEffectImpl { public MarshmistTitanCostReductionEffect (  )  { super ( Duration . Custom, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "{this} costs {X} less to cast, where X is your devotion to black <i> ( Each {B} in the mana costs of permanents you control counts toward your devotion to black .  ) </i> "; } public MarshmistTitanCostReductionEffect ( final MarshmistTitanCostReductionEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { SpellAbility spellAbility =  ( SpellAbility ) abilityToModify; Mana mana = spellAbility . getManaCostsToPay (  )  . getMana (  ) ; if  ( mana . getGeneric (  )  > 0 )  { int count = new DevotionCount ( ColoredManaSymbol . B )  . calculate ( game, source, this ) ; int newCount = mana . getGeneric (  )  - count; if  ( newCount < 0 )  { newCount = 0; } mana . setGeneric ( newCount ) ; spellAbility . getManaCostsToPay (  )  . load ( mana . toString (  )  ) ; return true; } return false; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { if  ( abilityToModify . getSourceId (  )  . equals ( source . getSourceId (  )  )  &&  ( abilityToModify instanceof SpellAbility )  )  { return true; } return false; } @Override public MarshmistTitanCostReductionEffect copy (  )  { return new MarshmistTitanCostReductionEffect ( this ) ; } } 
public class MeletisAstronomer extends CardImpl { private static final FilterCard filter = new FilterCard ( "an enchantment card" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public MeletisAstronomer ( UUID ownerId )  { super ( ownerId, 43, "Meletis Astronomer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new HeroicAbility ( new LookLibraryAndPickControllerEffect ( 3, 1, filter, true, false, Zone . HAND, true ) , false )  ) ; } public MeletisAstronomer ( final MeletisAstronomer card )  { super ( card ) ; } @Override public MeletisAstronomer copy (  )  { return new MeletisAstronomer ( this ) ; } } 
public class Mindreaver extends CardImpl { public Mindreaver ( UUID ownerId )  { super ( ownerId, 44, "Mindreaver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{U}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new HeroicAbility ( new MindreaverExileEffect (  ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CounterTargetEffect (  ) , new ManaCostsImpl ( "{U}{U}" )  ) ; FilterSpell filter = new FilterSpell ( "spell with the same name as a card exiled with {this}" ) ; filter . add ( new MindreaverNamePredicate ( this . getId (  )  )  ) ; ability . addTarget ( new TargetSpell ( filter )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public Mindreaver ( final Mindreaver card )  { super ( card ) ; } @Override public Mindreaver copy (  )  { return new Mindreaver ( this ) ; } } class MindreaverExileEffect extends OneShotEffect { public MindreaverExileEffect (  )  { super ( Outcome . Exile ) ; this . staticText = "exile the top three cards of target opponent's library"; } public MindreaverExileEffect ( final MindreaverExileEffect effect )  { super ( effect ) ; } @Override public MindreaverExileEffect copy (  )  { return new MindreaverExileEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID exileId = CardUtil . getCardExileZoneId ( game, source ) ; MageObject sourceObject = source . getSourceObject ( game ) ; Player opponent = game . getPlayer ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( opponent != null && sourceObject != null )  { for  ( int i = 0; i < 3; i++ )  { Card card = opponent . getLibrary (  )  . getFromTop ( game ) ; if  ( card != null )  { card . moveToExile ( exileId, sourceObject . getIdName (  ) , source . getSourceId (  ) , game ) ; } } } return false; } } class MindreaverNamePredicate implements Predicate<MageObject> { private final UUID sourceId; public MindreaverNamePredicate ( UUID sourceId )  { this . sourceId = sourceId; } @Override public boolean apply ( MageObject input, Game game )  { Set<String> cardNames = new HashSet<String> (  ) ; UUID exileId = CardUtil . getCardExileZoneId ( game, sourceId ) ; ExileZone exileZone = game . getExile (  )  . getExileZone ( exileId ) ; if  ( exileZone != null )  { for  ( Card card : exileZone . getCards ( game )  )  { cardNames . add ( card . getName (  )  ) ; } } if  ( input instanceof SplitCard )  { return cardNames . contains (  (  ( SplitCard )  input )  . getLeftHalfCard (  )  . getName (  )  )  || cardNames . contains (  (  ( SplitCard )  input )  . getRightHalfCard (  )  . getName (  )  ) ; } else if  ( input instanceof Spell &&  (  ( Spell )  input )  . getSpellAbility (  )  . getSpellAbilityType (  )  . equals ( SpellAbilityType . SPLIT_FUSED )  )  { SplitCard card =  ( SplitCard )   (  ( Spell )  input )  . getCard (  ) ; return cardNames . contains ( card . getLeftHalfCard (  )  . getName (  )  )  || cardNames . contains ( card . getRightHalfCard (  )  . getName (  )  ) ; } else { return cardNames . contains ( input . getName (  )  ) ; } } @Override public String toString (  )  { return "spell with the same name as a card exiled with {source}"; } } 
public class MischiefAndMayhem extends CardImpl { public MischiefAndMayhem ( UUID ownerId )  { super ( ownerId, 126, "Mischief and Mayhem", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{G}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( 4,4, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0,2, new FilterCreaturePermanent ( "creatures each" ) , false )  ) ; } public MischiefAndMayhem ( final MischiefAndMayhem card )  { super ( card ) ; } @Override public MischiefAndMayhem copy (  )  { return new MischiefAndMayhem ( this ) ; } } 
public class MogisGodOfSlaughter extends CardImpl { public MogisGodOfSlaughter ( UUID ownerId )  { super ( ownerId, 151, "Mogis, God of Slaughter", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{2}{B}{R}" ) ; this . expansionSetCode = "BNG"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "God" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( IndestructibleAbility . getInstance (  )  ) ; Effect effect = new LoseCreatureTypeSourceEffect ( new DevotionCount ( ColoredManaSymbol . B, ColoredManaSymbol . R ) , 7 ) ; effect . setText ( "As long as your devotion to black and red is less than seven, Mogis isn't a creature" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; effect = new DoUnlessTargetPaysCost ( new DamageTargetEffect ( 2, false, "that player" ) , new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  ) , "Sacrifice a creature?  ( otherwise you get 2 damage ) " ) ; effect . setText ( "Mogis deals 2 damage to that player unless he or she sacrifices a creature" ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, effect, TargetController . OPPONENT, false, true ) ; this . addAbility ( ability ) ; } public MogisGodOfSlaughter ( final MogisGodOfSlaughter card )  { super ( card ) ; } @Override public MogisGodOfSlaughter copy (  )  { return new MogisGodOfSlaughter ( this ) ; } } class DoUnlessTargetPaysCost extends OneShotEffect { private final OneShotEffect executingEffect; private final Cost cost; private final String userMessage; public DoUnlessTargetPaysCost ( OneShotEffect effect, Cost cost )  { this ( effect, cost, null ) ; } public DoUnlessTargetPaysCost ( OneShotEffect effect, Cost cost, String userMessage )  { super ( Outcome . Benefit ) ; this . executingEffect = effect; this . cost = cost; this . userMessage = userMessage; } public DoUnlessTargetPaysCost ( final DoUnlessTargetPaysCost effect )  { super ( effect ) ; this . executingEffect =  ( OneShotEffect )  effect . executingEffect . copy (  ) ; this . cost = effect . cost . copy (  ) ; this . userMessage = effect . userMessage; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; MageObject mageObject = game . getObject ( source . getSourceId (  )  ) ; if  ( player != null && mageObject != null )  { String message = userMessage; if  ( message == null )  { message = getCostText (  )  + " to prevent " + executingEffect . getText ( source . getModes (  )  . getMode (  )  )  + "?"; } message = CardUtil . replaceSourceName ( message, mageObject . getLogName (  )  ) ; cost . clearPaid (  ) ; if  ( cost . canPay ( source, source . getSourceId (  ) , player . getId (  ) , game )  && player . chooseUse ( executingEffect . getOutcome (  ) , message, source, game )  )  { cost . pay ( source, game, source . getSourceId (  ) , player . getId (  ) , false, null ) ; } if  ( !cost . isPaid (  )  )  { executingEffect . setTargetPointer ( this . targetPointer ) ; return executingEffect . apply ( game, source ) ; } return true; } return false; } @Override public String getText ( Mode mode )  { if  ( !staticText . isEmpty (  )  )  { return staticText; } StringBuilder sb = new StringBuilder ( executingEffect . getText ( mode )  ) ; sb . append ( "unless he or she" ) ; sb . append ( getCostText (  )  ) ; return sb . toString (  ) ; } private String getCostText (  )  { StringBuilder sb = new StringBuilder (  ) ; String costText = cost . getText (  ) ; if  ( costText != null && !costText . toLowerCase (  )  . startsWith ( "discard" )  && !costText . toLowerCase (  )  . startsWith ( "sacrifice" )  && !costText . toLowerCase (  )  . startsWith ( "remove" )  )  { sb . append ( "pay " ) ; } return sb . append ( costText )  . toString (  ) ; } @Override public DoUnlessTargetPaysCost copy (  )  { return new DoUnlessTargetPaysCost ( this ) ; } } 
public class MortalsArdor extends CardImpl { public MortalsArdor ( UUID ownerId )  { super ( ownerId, 20, "Mortal's Ardor", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "BNG"; Effect effect = new BoostTargetEffect ( 1,1, Duration . EndOfTurn ) ; effect . setText ( "Target creature gets +1/+1" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; effect = new GainAbilityTargetEffect ( LifelinkAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains lifelink until end of turn" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public MortalsArdor ( final MortalsArdor card )  { super ( card ) ; } @Override public MortalsArdor copy (  )  { return new MortalsArdor ( this ) ; } } 
public class MortalsResolve extends CardImpl { public MortalsResolve ( UUID ownerId )  { super ( ownerId, 127, "Mortal's Resolve", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{G}" ) ; this . expansionSetCode = "BNG"; Effect effect = new BoostTargetEffect ( 1,1, Duration . EndOfTurn ) ; effect . setText ( "Target creature gets +1/+1" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; effect = new GainAbilityTargetEffect ( IndestructibleAbility . getInstance (  ) , Duration . EndOfTurn ) ; effect . setText ( "and gains indestructible until end of turn" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public MortalsResolve ( final MortalsResolve card )  { super ( card ) ; } @Override public MortalsResolve copy (  )  { return new MortalsResolve ( this ) ; } } 
public class NessianDemolok extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "noncreature permanent" ) ; static { filter . add ( Predicates . not ( new CardTypePredicate ( CardType . CREATURE )  )  ) ; } public NessianDemolok ( UUID ownerId )  { super ( ownerId, 128, "Nessian Demolok", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new TributeAbility ( 3 )  ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new DestroyTargetEffect (  ) , false ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, TributeNotPaidCondition . getInstance (  ) , "When {this} enters the battlefield, if its tribute wasn't paid, destroy target noncreature permanent . " )  ) ; } public NessianDemolok ( final NessianDemolok card )  { super ( card ) ; } @Override public NessianDemolok copy (  )  { return new NessianDemolok ( this ) ; } } 
public class NessianWildsRavager extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another target creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public NessianWildsRavager ( UUID ownerId )  { super ( ownerId, 129, "Nessian Wilds Ravager", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Hydra" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( new TributeAbility ( 6 )  ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new FightTargetSourceEffect (  ) , true ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, TributeNotPaidCondition . getInstance (  ) , "When {this} enters the battlefield, if its tribute wasn't paid, you may have {this} fight another target creature . " )  ) ; } public NessianWildsRavager ( final NessianWildsRavager card )  { super ( card ) ; } @Override public NessianWildsRavager copy (  )  { return new NessianWildsRavager ( this ) ; } } 
public class NobleQuarry extends CardImpl { public NobleQuarry ( UUID ownerId )  { super ( ownerId, 130, "Noble Quarry", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Unicorn" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BestowAbility ( this, "{5}{G}" )  ) ; Effect effect = new MustBeBlockedByAllSourceEffect ( Duration . WhileOnBattlefield ) ; effect . setText ( "All creatures able to block Noble Quarry" ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, effect ) ; effect = new MustBeBlockedByAllAttachedEffect ( Duration . WhileOnBattlefield, AttachmentType . AURA ) ; effect . setText ( "or enchanted creature do so" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1,1, Duration . WhileOnBattlefield )  )  ) ; } public NobleQuarry ( final NobleQuarry card )  { super ( card ) ; } @Override public NobleQuarry copy (  )  { return new NobleQuarry ( this ) ; } } 
public class Nullify extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "creature or Aura spell" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . CREATURE ) , new SubtypePredicate ( "Aura" )  )  ) ; } public Nullify ( UUID ownerId )  { super ( ownerId, 45, "Nullify", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{U}{U}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; } public Nullify ( final Nullify card )  { super ( card ) ; } @Override public Nullify copy (  )  { return new Nullify ( this ) ; } } 
public class NyxbornEidolon extends CardImpl { public NyxbornEidolon ( UUID ownerId )  { super ( ownerId, 78, "Nyxborn Eidolon", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BestowAbility ( this, "{4}{B}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 1, Duration . WhileOnBattlefield )  )  ) ; } public NyxbornEidolon ( final NyxbornEidolon card )  { super ( card ) ; } @Override public NyxbornEidolon copy (  )  { return new NyxbornEidolon ( this ) ; } } 
public class NyxbornRollicker extends CardImpl { public NyxbornRollicker ( UUID ownerId )  { super ( ownerId, 102, "Nyxborn Rollicker", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Satyr" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BestowAbility ( this, "{1}{R}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1,1, Duration . WhileOnBattlefield  )  )  ) ; } public NyxbornRollicker ( final NyxbornRollicker card )  { super ( card ) ; } @Override public NyxbornRollicker copy (  )  { return new NyxbornRollicker ( this ) ; } } 
public class NyxbornShieldmate extends CardImpl { public NyxbornShieldmate ( UUID ownerId )  { super ( ownerId, 21, "Nyxborn Shieldmate", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new BestowAbility ( this, "{2}{W}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1,2, Duration . WhileOnBattlefield )  )  ) ; } public NyxbornShieldmate ( final NyxbornShieldmate card )  { super ( card ) ; } @Override public NyxbornShieldmate copy (  )  { return new NyxbornShieldmate ( this ) ; } } 
public class NyxbornTriton extends CardImpl { public NyxbornTriton ( UUID ownerId )  { super ( ownerId, 46, "Nyxborn Triton", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Merfolk" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new BestowAbility ( this, "{4}{U}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2,3, Duration . WhileOnBattlefield )  )  ) ; } public NyxbornTriton ( final NyxbornTriton card )  { super ( card ) ; } @Override public NyxbornTriton copy (  )  { return new NyxbornTriton ( this ) ; } } 
public class OracleOfBones extends CardImpl { public OracleOfBones ( UUID ownerId )  { super ( ownerId, 103, "Oracle of Bones", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new TributeAbility ( 2 )  ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new OracleOfBonesCastEffect (  ) , false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, TributeNotPaidCondition . getInstance (  ) , "When {this} enters the battlefield, if its tribute wasn't paid, you may cast an instant or sorcery card from your hand without paying its mana cost . " )  ) ; } public OracleOfBones ( final OracleOfBones card )  { super ( card ) ; } @Override public OracleOfBones copy (  )  { return new OracleOfBones ( this ) ; } } class OracleOfBonesCastEffect extends OneShotEffect { private static final FilterCard filter = new FilterInstantOrSorceryCard ( "instant or sorcery card from your hand" ) ; public OracleOfBonesCastEffect (  )  { super ( Outcome . PlayForFree ) ; this . staticText = "you may cast an instant or sorcery card from your hand without paying its mana cost"; } public OracleOfBonesCastEffect ( final OracleOfBonesCastEffect effect )  { super ( effect ) ; } @Override public OracleOfBonesCastEffect copy (  )  { return new OracleOfBonesCastEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Target target = new TargetCardInHand ( filter ) ; if  ( target . canChoose ( source . getSourceId (  ) , controller . getId (  ) , game )  && controller . chooseUse ( outcome, "Cast an instant or sorcery card from your hand without paying its mana cost?", source, game )  )  { Card cardToCast = null; boolean cancel = false; while  ( controller . canRespond (  )  && !cancel )  { if  ( controller . chooseTarget ( outcome, target, source, game )  )  { cardToCast = game . getCard ( target . getFirstTarget (  )  ) ; if  ( cardToCast != null && cardToCast . getSpellAbility (  )  . canChooseTarget ( game )  )  { cancel = true; } } else { cancel = true; } } if  ( cardToCast != null )  { controller . cast ( cardToCast . getSpellAbility (  ) , game, true ) ; } } return true; } return false; } } 
public class OraclesInsight extends CardImpl { public OraclesInsight ( UUID ownerId )  { super ( ownerId, 47, "Oracle's Insight", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ScryEffect ( 1 ) , new TapSourceCost (  )  ) ; Effect effect = new DrawCardSourceControllerEffect ( 1 ) ; effect . setText ( "then draw a card" ) ; ability . addEffect ( effect ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability, AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public OraclesInsight ( final OraclesInsight card )  { super ( card ) ; } @Override public OraclesInsight copy (  )  { return new OraclesInsight ( this ) ; } } 
public class OreskosSunGuide extends CardImpl { public OreskosSunGuide ( UUID ownerId )  { super ( ownerId, 22, "Oreskos Sun Guide", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Cat" ) ; this . subtype . add ( "Monk" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new InspiredAbility ( new GainLifeEffect ( 2 )  )  ) ; } public OreskosSunGuide ( final OreskosSunGuide card )  { super ( card ) ; } @Override public OreskosSunGuide copy (  )  { return new OreskosSunGuide ( this ) ; } } 
public class Ornitharch extends CardImpl { public Ornitharch ( UUID ownerId )  { super ( ownerId, 23, "Ornitharch", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}{W}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Archon" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new TributeAbility ( 2 )  ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new CreateTokenEffect ( new BirdToken (  ) , 2 ) , false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, TributeNotPaidCondition . getInstance (  ) , "When {this} enters the battlefield, if its tribute wasn't paid, put two 1/1 white Bird creature tokens with flying onto the battlefield . " )  ) ; } public Ornitharch ( final Ornitharch card )  { super ( card ) ; } @Override public Ornitharch copy (  )  { return new Ornitharch ( this ) ; } } 
public class PainSeer extends CardImpl { public PainSeer ( UUID ownerId )  { super ( ownerId, 80, "Pain Seer", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new InspiredAbility ( new PainSeerEffect (  )  )  ) ; } public PainSeer ( final PainSeer card )  { super ( card ) ; } @Override public PainSeer copy (  )  { return new PainSeer ( this ) ; } } class PainSeerEffect extends OneShotEffect { public PainSeerEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "reveal the top card of your library and put that card into your hand .  You lose life equal to that card's converted mana cost"; } public PainSeerEffect ( final PainSeerEffect effect )  { super ( effect ) ; } @Override public PainSeerEffect copy (  )  { return new PainSeerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player == null )  { return false; } if  ( player . getLibrary (  )  . size (  )  > 0 )  { Card card = player . getLibrary (  )  . getFromTop ( game ) ; Cards cards = new CardsImpl (  ) ; cards . add ( card ) ; player . revealCards ( "Pain Seer", cards, game ) ; if  ( card != null && card . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false )  )  { player . loseLife ( card . getManaCost (  )  . convertedManaCost (  ) , game ) ; return true; } } return false; } } 
public class Peregrination extends CardImpl { public Peregrination ( UUID ownerId )  { super ( ownerId, 132, "Peregrination", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{G}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new PeregrinationEffect (  )  ) ; Effect effect = new ScryEffect ( 1 ) ; effect . setText ( "then scry 1 <i> ( Look at the top card of your library .  You may put that card on the bottom of your library .  ) </i>" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public Peregrination ( final Peregrination card )  { super ( card ) ; } @Override public Peregrination copy (  )  { return new Peregrination ( this ) ; } } class PeregrinationEffect extends OneShotEffect { protected static final FilterCard filter = new FilterCard ( "card to put on the battlefield tapped" ) ; public PeregrinationEffect (  )  { super ( Outcome . PutLandInPlay ) ; staticText = "Search your library for up to two basic land cards, reveal those cards, and put one onto the battlefield tapped and the other into your hand .  Shuffle your library"; } public PeregrinationEffect ( final PeregrinationEffect effect )  { super ( effect ) ; } @Override public PeregrinationEffect copy (  )  { return new PeregrinationEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller == null || sourceObject == null )  { return false; } TargetCardInLibrary target = new TargetCardInLibrary ( 0, 2, new FilterBasicLandCard (  )  ) ; if  ( controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { Cards revealed = new CardsImpl (  ) ; for  ( UUID cardId : target . getTargets (  )  )  { Card card = controller . getLibrary (  )  . getCard ( cardId, game ) ; revealed . add ( card ) ; } controller . revealCards ( sourceObject . getIdName (  ) , revealed, game ) ; if  ( target . getTargets (  )  . size (  )  == 2 )  { TargetCard target2 = new TargetCard ( Zone . LIBRARY, filter ) ; controller . choose ( Outcome . Benefit, revealed, target2, game ) ; Card card = revealed . get ( target2 . getFirstTarget (  ) , game ) ; controller . moveCards ( card, Zone . BATTLEFIELD, source, game, true, false, false, null ) ; revealed . remove ( card ) ; card = revealed . getCards ( game )  . iterator (  )  . next (  ) ; controller . moveCards ( card, Zone . HAND, source, game ) ; } else if  ( target . getTargets (  )  . size (  )  == 1 )  { Card card = revealed . getCards ( game )  . iterator (  )  . next (  ) ; controller . moveCards ( card, Zone . BATTLEFIELD, source, game, true, false, false, null ) ; } } controller . shuffleLibrary ( game ) ; return true; } controller . shuffleLibrary ( game ) ; return false; } } 
public class PerplexingChimera extends CardImpl { public PerplexingChimera ( UUID ownerId )  { super ( ownerId, 48, "Perplexing Chimera", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Chimera" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new PerplexingChimeraTriggeredAbility (  )  ) ; } public PerplexingChimera ( final PerplexingChimera card )  { super ( card ) ; } @Override public PerplexingChimera copy (  )  { return new PerplexingChimera ( this ) ; } } class PerplexingChimeraTriggeredAbility extends TriggeredAbilityImpl { public PerplexingChimeraTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new PerplexingChimeraControlExchangeEffect (  ) , true ) ; } public PerplexingChimeraTriggeredAbility ( final PerplexingChimeraTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SPELL_CAST; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( game . getOpponents ( controllerId )  . contains ( event . getPlayerId (  )  )  )  { for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( event . getTargetId (  )  )  ) ; } return true; } return false; } @Override public String getRule (  )  { return "Whenever an opponent casts a spell, " + super . getRule (  ) ; } @Override public PerplexingChimeraTriggeredAbility copy (  )  { return new PerplexingChimeraTriggeredAbility ( this ) ; } } class PerplexingChimeraControlExchangeEffect extends OneShotEffect { public PerplexingChimeraControlExchangeEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "exchange control of {this} and that spell .  If you do, you may choose new targets for the spell"; } public PerplexingChimeraControlExchangeEffect ( final PerplexingChimeraControlExchangeEffect effect )  { super ( effect ) ; } @Override public PerplexingChimeraControlExchangeEffect copy (  )  { return new PerplexingChimeraControlExchangeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Spell spell = game . getStack (  )  . getSpell ( targetPointer . getFirst ( game, source )  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( spell != null && controller != null )  { Player spellCaster = game . getPlayer ( spell . getControllerId (  )  ) ; spell . setControllerId ( controller . getId (  )  ) ; spell . chooseNewTargets ( game, controller . getId (  )  ) ; game . informPlayers ( controller . getLogName (  )  + " got control of " + spell . getName (  )  + " spell . " ) ; if  ( spellCaster != null )  { ContinuousEffect effect = new PerplexingChimeraControlEffect (  ) ; effect . setTargetPointer ( new FixedTarget ( spellCaster . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } } return false; } } class PerplexingChimeraControlEffect extends ContinuousEffectImpl { public PerplexingChimeraControlEffect (  )  { super ( Duration . Custom, Layer . ControlChangingEffects_2, SubLayer . NA, Outcome . GainControl ) ; staticText = "PerplexingChimeraControlEffect"; } public PerplexingChimeraControlEffect ( final PerplexingChimeraControlEffect effect )  { super ( effect ) ; } @Override public PerplexingChimeraControlEffect copy (  )  { return new PerplexingChimeraControlEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { return permanent . changeControllerId ( this . getTargetPointer (  )  . getFirst ( game, source ) , game ) ; } else { discard (  ) ;  
public class PharagaxGiant extends CardImpl { public PharagaxGiant ( UUID ownerId )  { super ( ownerId, 104, "Pharagax Giant", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Giant" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new TributeAbility ( 2 )  ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new DamagePlayersEffect ( 5, TargetController . OPPONENT ) , false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, TributeNotPaidCondition . getInstance (  ) , "When {this} enters the battlefield, if its tribute wasn't paid, {this} deals 5 damage to each opponent . " )  ) ; } public PharagaxGiant ( final PharagaxGiant card )  { super ( card ) ; } @Override public PharagaxGiant copy (  )  { return new PharagaxGiant ( this ) ; } } 
public class PhenaxGodOfDeception extends CardImpl { public PhenaxGodOfDeception ( UUID ownerId )  { super ( ownerId, 152, "Phenax, God of Deception", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{3}{U}{B}" ) ; this . expansionSetCode = "BNG"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "God" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( IndestructibleAbility . getInstance (  )  ) ; Effect effect = new LoseCreatureTypeSourceEffect ( new DevotionCount ( ColoredManaSymbol . U, ColoredManaSymbol . B ) , 7 ) ; effect . setText ( "As long as your devotion to blue and black is less than seven, Phenax isn't a creature" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; effect = new PutTopCardOfLibraryIntoGraveTargetEffect ( SourcePermanentToughnessValue . getInstance (  )  ) ; effect . setText ( "Target player puts the top X cards of his or her library into his or her graveyard, where X is this creature's toughness" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; effect = new GainAbilityControlledEffect ( ability, Duration . WhileOnBattlefield, new FilterCreaturePermanent ( "Creatures" ) ,false ) ; effect . setText ( "Creatures you control have \"{T}: Target player puts the top X cards of his or her library into his or her graveyard, where X is this creature's toughness . \"" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public PhenaxGodOfDeception ( final PhenaxGodOfDeception card )  { super ( card ) ; } @Override public PhenaxGodOfDeception copy (  )  { return new PhenaxGodOfDeception ( this ) ; } } 
public class PheresBandRaiders extends CardImpl { public PheresBandRaiders ( UUID ownerId )  { super ( ownerId, 133, "Pheres-Band Raiders", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Centaur" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new InspiredAbility ( new DoIfCostPaid ( new CreateTokenEffect ( new CentaurEnchantmentCreatureToken (  )  ) , new ManaCostsImpl ( "{2}{G}" )  )  )  ) ; } public PheresBandRaiders ( final PheresBandRaiders card )  { super ( card ) ; } @Override public PheresBandRaiders copy (  )  { return new PheresBandRaiders ( this ) ; } } 
public class PheresBandTromper extends CardImpl { public PheresBandTromper ( UUID ownerId )  { super ( ownerId, 134, "Pheres-Band Tromper", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Centaur" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new InspiredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  )  )  ) ; } public PheresBandTromper ( final PheresBandTromper card )  { super ( card ) ; } @Override public PheresBandTromper copy (  )  { return new PheresBandTromper ( this ) ; } } 
public class PillarOfWar extends CardImpl { public PillarOfWar ( UUID ownerId )  { super ( ownerId, 160, "Pillar of War", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; Effect effect = new ConditionalAsThoughEffect (  new CanAttackAsThoughItDidntHaveDefenderSourceEffect ( Duration . WhileOnBattlefield ) , new EnchantedCondition (  )  ) ; effect . setText ( "As long as {this} is enchanted, it can attack as though it didn't have defender" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public PillarOfWar ( final PillarOfWar card )  { super ( card ) ; } @Override public PillarOfWar copy (  )  { return new PillarOfWar ( this ) ; } } 
public class PinnacleOfRage extends CardImpl { public PinnacleOfRage ( UUID ownerId )  { super ( ownerId, 105, "Pinnacle of Rage", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{R}{R}" ) ; this . expansionSetCode = "BNG"; Effect effect = new DamageTargetEffect ( 3 ) ; effect . setText ( "{this} deals 3 damage to each of two target creatures and/or players" ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer ( 2,2 )  ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public PinnacleOfRage ( final PinnacleOfRage card )  { super ( card ) ; } @Override public PinnacleOfRage copy (  )  { return new PinnacleOfRage ( this ) ; } } 
public class PleaForGuidance extends CardImpl { private static final FilterCard filter = new FilterCard ( "enchantment cards" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public PleaForGuidance ( UUID ownerId )  { super ( ownerId, 24, "Plea for Guidance", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{5}{W}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( 0,2, filter ) , true, true )  ) ; } public PleaForGuidance ( final PleaForGuidance card )  { super ( card ) ; } @Override public PleaForGuidance copy (  )  { return new PleaForGuidance ( this ) ; } } 
public class Ragemonger extends CardImpl { private static final FilterCard filter = new FilterCard ( "Minotaur spells" ) ; static { filter . add ( new SubtypePredicate ( "Minotaur" )  ) ; } public Ragemonger ( UUID ownerId )  { super ( ownerId, 153, "Ragemonger", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SpellsCostReductionControllerEffect ( filter, new ManaCostsImpl<> ( "{B}{R}" )  )  )  ) ; } public Ragemonger ( final Ragemonger card )  { super ( card ) ; } @Override public Ragemonger copy (  )  { return new Ragemonger ( this ) ; } } 
public class RaisedByWolves extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Wolf you control" ) ; static { filter . add ( new SubtypePredicate ( "Wolf" )  ) ; } public RaisedByWolves ( UUID ownerId )  { super ( ownerId, 135, "Raised by Wolves", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{G}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new CreateTokenEffect ( new WolfToken (  ) , 2 )  )  ) ; DynamicValue amountOfWolves = new PermanentsOnBattlefieldCount ( filter ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( amountOfWolves, amountOfWolves, Duration . WhileOnBattlefield )  )  ) ; } public RaisedByWolves ( final RaisedByWolves card )  { super ( card ) ; } @Override public RaisedByWolves copy (  )  { return new RaisedByWolves ( this ) ; } } 
public class ReapWhatIsSown extends CardImpl { public ReapWhatIsSown ( UUID ownerId )  { super ( ownerId, 154, "Reap What Is Sown", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{G}{W}" ) ; this . expansionSetCode = "BNG"; Effect effect = new AddCountersTargetEffect ( CounterType . P1P1 . createInstance (  )  ) ; effect . setText ( "Put a +1/+1 counter on each of up to three target creatures" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 3, new FilterCreaturePermanent ( "creatures" ) , false )  ) ; } public ReapWhatIsSown ( final ReapWhatIsSown card )  { super ( card ) ; } @Override public ReapWhatIsSown copy (  )  { return new ReapWhatIsSown ( this ) ; } } 
public class RecklessReveler extends CardImpl { public RecklessReveler ( UUID ownerId )  { super ( ownerId, 106, "Reckless Reveler", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Satyr" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new ManaCostsImpl ( "{R}" )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetArtifactPermanent (  )  ) ; this . addAbility ( ability ) ; } public RecklessReveler ( final RecklessReveler card )  { super ( card ) ; } @Override public RecklessReveler copy (  )  { return new RecklessReveler ( this ) ; } } 
public class Sanguimancy extends CardImpl { public Sanguimancy ( UUID ownerId )  { super ( ownerId, 81, "Sanguimancy", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{B}" ) ; this . expansionSetCode = "BNG"; DynamicValue blackDevotion = new DevotionCount ( ColoredManaSymbol . B ) ; Effect effect = new DrawCardSourceControllerEffect ( blackDevotion ) ; effect . setText ( "You draw X cards" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; effect = new LoseLifeSourceControllerEffect ( blackDevotion ) ; effect . setText ( "and you lose X life, where X is your devotion to black" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public Sanguimancy ( final Sanguimancy card )  { super ( card ) ; } @Override public Sanguimancy copy (  )  { return new Sanguimancy ( this ) ; } } 
public class SatyrFiredancer extends CardImpl { public SatyrFiredancer ( UUID ownerId )  { super ( ownerId, 108, "Satyr Firedancer", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT, CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Satyr" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SatyrFiredancerTriggeredAbility (  )  ) ; } public SatyrFiredancer ( final SatyrFiredancer card )  { super ( card ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SatyrFiredancerTriggeredAbility )  { Player opponent = game . getPlayer ( ability . getEffects (  )  . get ( 0 )  . getTargetPointer (  )  . getFirst ( game, ability )  ) ; if  ( opponent != null )  { FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature controlled by " + opponent . getLogName (  )  ) ; filter . add ( new ControllerIdPredicate ( opponent . getId (  )  )  ) ; ability . getTargets (  )  . add ( new TargetCreaturePermanent ( filter )  ) ; } } } @Override public SatyrFiredancer copy (  )  { return new SatyrFiredancer ( this ) ; } } class SatyrFiredancerTriggeredAbility extends TriggeredAbilityImpl { private List<UUID> handledStackObjects = new ArrayList<> (  ) ; public SatyrFiredancerTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new SatyrFiredancerDamageEffect (  ) , false ) ; } public SatyrFiredancerTriggeredAbility ( final SatyrFiredancerTriggeredAbility ability )  { super ( ability ) ; } @Override public SatyrFiredancerTriggeredAbility copy (  )  { return new SatyrFiredancerTriggeredAbility ( this ) ; } @Override public void reset ( Game game )  { handledStackObjects . clear (  ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( getControllerId (  )  . equals ( game . getControllerId ( event . getSourceId (  )  )  )  )  { MageObject damageSource = game . getObject ( event . getSourceId (  )  ) ; if  ( damageSource != null )  { if  ( game . getOpponents ( getControllerId (  )  )  . contains ( event . getTargetId (  )  )  )  { MageObject object = game . getObject ( event . getSourceId (  )  ) ; if  ( object . getCardType (  )  . contains ( CardType . INSTANT )  || object . getCardType (  )  . contains ( CardType . SORCERY )  )  { if  ( ! ( damageSource instanceof StackObject )  || !handledStackObjects . contains ( damageSource . getId (  )  )  )  { if  ( damageSource instanceof StackObject )  { handledStackObjects . add ( damageSource . getId (  )  ) ; } for  ( Effect effect: this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( event . getTargetId (  )  )  ) ;  
public class SatyrNyxSmith extends CardImpl { public SatyrNyxSmith ( UUID ownerId )  { super ( ownerId, 109, "Satyr Nyx-Smith", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Satyr" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new InspiredAbility ( new DoIfCostPaid ( new CreateTokenEffect ( new SatyrNyxSmithElementalToken (  )  ) , new ManaCostsImpl ( "{2}{R}" )  )  )  ) ; } public SatyrNyxSmith ( final SatyrNyxSmith card )  { super ( card ) ; } @Override public SatyrNyxSmith copy (  )  { return new SatyrNyxSmith ( this ) ; } } class SatyrNyxSmithElementalToken extends Token { public SatyrNyxSmithElementalToken (  )  { super ( "Elemental", "3/1 red Elemental enchantment creature token with haste" ) ; cardType . add ( CardType . ENCHANTMENT ) ; cardType . add ( CardType . CREATURE ) ; color . setRed ( true ) ; subtype . add ( "Elemental" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . setOriginalExpansionSetCode ( "BNG" ) ; } } 
public class SatyrWayfinder extends CardImpl { public SatyrWayfinder ( UUID ownerId )  { super ( ownerId, 136, "Satyr Wayfinder", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Satyr" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new SatyrWayfinderEffect (  )  )  ) ; } public SatyrWayfinder ( final SatyrWayfinder card )  { super ( card ) ; } @Override public SatyrWayfinder copy (  )  { return new SatyrWayfinder ( this ) ; } } class SatyrWayfinderEffect extends OneShotEffect { private static final FilterLandCard filterPutInHand = new FilterLandCard ( "land card to put in hand" ) ; public SatyrWayfinderEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "reveal the top four cards of your library .  You may put a land card from among them into your hand .  Put the rest into your graveyard"; } public SatyrWayfinderEffect ( final SatyrWayfinderEffect effect )  { super ( effect ) ; } @Override public SatyrWayfinderEffect copy (  )  { return new SatyrWayfinderEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller != null && sourceObject != null )  { Cards cards = new CardsImpl (  ) ; cards . addAll ( controller . getLibrary (  )  . getTopCards ( game, 4 )  ) ; boolean properCardFound = cards . count ( filterPutInHand, source . getControllerId (  ) , source . getSourceId (  ) , game )  > 0; if  ( !cards . isEmpty (  )  )  { controller . revealCards ( sourceObject . getName (  ) , cards, game ) ; TargetCard target = new TargetCard ( Zone . LIBRARY, filterPutInHand ) ; if  ( properCardFound && controller . chooseUse ( outcome, "Put a land card into your hand?", source, game )  && controller . choose ( Outcome . DrawCard, cards, target, game )  )  { Card card = game . getCard ( target . getFirstTarget (  )  ) ; if  ( card != null )  { cards . remove ( card ) ; controller . moveCards ( card, null, Zone . HAND, source, game ) ; } } controller . moveCards ( cards, Zone . LIBRARY, Zone . GRAVEYARD, source, game ) ; } return true; } return false; } } 
public class ScourgeOfSkolaVale extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public ScourgeOfSkolaVale ( UUID ownerId )  { super ( ownerId, 137, "Scourge of Skola Vale", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Hydra" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; Effect effect = new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) , true ) ; effect . setText ( "with two +1/+1 counters on it" ) ; this . addAbility ( new EntersBattlefieldAbility ( effect )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ScourgeOfSkolaValeEffect (  ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public ScourgeOfSkolaVale ( final ScourgeOfSkolaVale card )  { super ( card ) ; } @Override public ScourgeOfSkolaVale copy (  )  { return new ScourgeOfSkolaVale ( this ) ; } } class ScourgeOfSkolaValeEffect extends OneShotEffect { public ScourgeOfSkolaValeEffect (  )  { super ( Outcome . GainLife ) ; this . staticText = "Put a number of +1/+1 counters on {this} equal to the sacrificed creature's toughness"; } public ScourgeOfSkolaValeEffect ( final ScourgeOfSkolaValeEffect effect )  { super ( effect ) ; } @Override public ScourgeOfSkolaValeEffect copy (  )  { return new ScourgeOfSkolaValeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Cost cost : source . getCosts (  )  )  { if  ( cost instanceof SacrificeTargetCost )  { int amount =  (  ( SacrificeTargetCost )  cost )  . getPermanents (  )  . get ( 0 )  . getToughness (  )  . getValue (  ) ; Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( amount > 0 && player != null )  { return new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( amount ) , true )  . apply ( game, source ) ; } } } return false; } } 
public class ScouringSands extends CardImpl { public ScouringSands ( UUID ownerId )  { super ( ownerId, 110, "Scouring Sands", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{R}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new ScouringSandsDamageEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ScryEffect ( 1 )  ) ; } public ScouringSands ( final ScouringSands card )  { super ( card ) ; } @Override public ScouringSands copy (  )  { return new ScouringSands ( this ) ; } } class ScouringSandsDamageEffect extends OneShotEffect { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature your opponents control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public ScouringSandsDamageEffect (  )  { super ( Outcome . GainLife ) ; staticText = "{this} deals 1 damage to each creature your opponents control"; } public ScouringSandsDamageEffect ( ScouringSandsDamageEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent creature : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , game )  )  { if  ( creature != null )  { creature . damage ( 1, source . getSourceId (  ) , game, false, false ) ; } } return true; } @Override public ScouringSandsDamageEffect copy (  )  { return new ScouringSandsDamageEffect ( this ) ; } } 
public class SearingBlood extends CardImpl { public SearingBlood ( UUID ownerId )  { super ( ownerId, 111, "Searing Blood", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{R}{R}" ) ; this . expansionSetCode = "BNG"; this . getSpellAbility (  )  . addEffect ( new SearingBloodEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public SearingBlood ( final SearingBlood card )  { super ( card ) ; } @Override public SearingBlood copy (  )  { return new SearingBlood ( this ) ; } } class SearingBloodEffect extends OneShotEffect { public SearingBloodEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "{this} deals 2 damage to target creature .  When that creature dies this turn, {this} deals 3 damage to that creature's controller"; } public SearingBloodEffect ( final SearingBloodEffect effect )  { super ( effect ) ; } @Override public SearingBloodEffect copy (  )  { return new SearingBloodEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { DelayedTriggeredAbility delayedAbility = new SearingBloodDelayedTriggeredAbility ( source . getFirstTarget (  )  ) ; game . addDelayedTriggeredAbility ( delayedAbility, source ) ; return new DamageTargetEffect ( 2 )  . apply ( game, source ) ; } } class SearingBloodDelayedTriggeredAbility extends DelayedTriggeredAbility { private UUID target; public SearingBloodDelayedTriggeredAbility ( UUID target )  { super ( new SearingBloodDelayedEffect ( target ) , Duration . EndOfTurn ) ; this . target = target; } public SearingBloodDelayedTriggeredAbility ( SearingBloodDelayedTriggeredAbility ability )  { super ( ability ) ; this . target = ability . target; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( target )  )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; if  ( zEvent . getFromZone (  )  == Zone . BATTLEFIELD && zEvent . getToZone (  )  == Zone . GRAVEYARD )  { return true; } } return false; } @Override public SearingBloodDelayedTriggeredAbility copy (  )  { return new SearingBloodDelayedTriggeredAbility ( this ) ; } @Override public String getRule (  )  { return "When that creature dies this turn, {this} deals 3 damage to that creature's controller . "; } } class SearingBloodDelayedEffect extends OneShotEffect { protected UUID target; public SearingBloodDelayedEffect ( UUID target )  { super ( Outcome . Damage ) ; this . target = target; } public SearingBloodDelayedEffect ( final SearingBloodDelayedEffect effect )  { super ( effect ) ; this . target = effect . target; } @Override public SearingBloodDelayedEffect copy (  )  { return new SearingBloodDelayedEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent =  ( Permanent )  game . getLastKnownInformation ( target, Zone . BATTLEFIELD ) ; if  ( permanent != null )  { Player player = game . getPlayer ( permanent . getControllerId (  )  ) ; if  ( player != null )  { MageObject sourceObject = source . getSourceObject ( game ) ; player . damage ( 3, source . getSourceId (  ) , game, false, true ) ; return true; } } return false; } } 
public class ServantOfTymaret extends CardImpl { public ServantOfTymaret ( UUID ownerId )  { super ( ownerId, 82, "Servant of Tymaret", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new InspiredAbility ( new ServantOfTymaretEffect (  )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{2}{B}" )  )  ) ; } public ServantOfTymaret ( final ServantOfTymaret card )  { super ( card ) ; } @Override public ServantOfTymaret copy (  )  { return new ServantOfTymaret ( this ) ; } } class ServantOfTymaretEffect extends OneShotEffect { public ServantOfTymaretEffect (  )  { super ( Outcome . Damage ) ; staticText = "each opponent loses 1 life .  You gain life equal to the life lost this way"; } public ServantOfTymaretEffect ( final ServantOfTymaretEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { int lostAmount = 0; for  ( UUID opponentId: game . getOpponents ( source . getControllerId (  )  )  )  { lostAmount += game . getPlayer ( opponentId )  . loseLife ( 1, game ) ; } game . getPlayer ( source . getControllerId (  )  )  . gainLife ( lostAmount, game ) ; return true; } @Override public ServantOfTymaretEffect copy (  )  { return new ServantOfTymaretEffect ( this ) ; } } 
public class SetessanOathsworn extends CardImpl { public SetessanOathsworn ( UUID ownerId )  { super ( ownerId, 138, "Setessan Oathsworn", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Satyr" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new HeroicAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) , true )  )  ) ; } public SetessanOathsworn ( final SetessanOathsworn card )  { super ( card ) ; } @Override public SetessanOathsworn copy (  )  { return new SetessanOathsworn ( this ) ; } } 
public class SetessanStarbreaker extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Aura" ) ; static { filter . add ( new SubtypePredicate ( "Aura" )  ) ; } public SetessanStarbreaker ( UUID ownerId )  { super ( ownerId, 139, "Setessan Starbreaker", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "BNG"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DestroyTargetEffect (  ) , true ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public SetessanStarbreaker ( final SetessanStarbreaker card )  { super ( card ) ; } @Override public SetessanStarbreaker copy (  )  { return new SetessanStarbreaker ( this ) ; } } 