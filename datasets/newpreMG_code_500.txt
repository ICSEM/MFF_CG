public class AgelessEntity extends CardImpl { public AgelessEntity ( UUID ownerId )  { super ( ownerId, 18, "Ageless Entity", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "DDH"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new GainLifeControllerTriggeredAbility ( new AgelessEntityEffect (  ) , false, true )  ) ; } public AgelessEntity ( final AgelessEntity card )  { super ( card ) ; } @Override public AgelessEntity copy (  )  { return new AgelessEntity ( this ) ; } } class AgelessEntityEffect extends OneShotEffect { public AgelessEntityEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "put that many +1/+1 counters on this creature"; } public AgelessEntityEffect ( final AgelessEntityEffect effect )  { super ( effect ) ; } @Override public AgelessEntityEffect copy (  )  { return new AgelessEntityEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int lifeGained =  ( Integer )  this . getValue ( "gainedLife" ) ; if  ( lifeGained > 0 )  { return new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( lifeGained )  )  . apply ( game, source ) ; } return false; } } 
public class AgonizingDemise extends CardImpl { private static final FilterCreaturePermanent filterNonBlackCreature = new FilterCreaturePermanent ( "nonblack creature" ) ; static { filterNonBlackCreature . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public AgonizingDemise ( UUID ownerId )  { super ( ownerId, 66, "Agonizing Demise", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{B}" ) ; this . expansionSetCode = "DDH"; this . addAbility ( new KickerAbility ( "{1}{R}" )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filterNonBlackCreature )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new AgonizingDemiseEffect (  ) , KickedCondition . getInstance (  ) , "If {this} was kicked, it deals damage equal to that creature's power to the creature's controller . " )  ) ; } public AgonizingDemise ( final AgonizingDemise card )  { super ( card ) ; } @Override public AgonizingDemise copy (  )  { return new AgonizingDemise ( this ) ; } } class AgonizingDemiseEffect extends OneShotEffect { public AgonizingDemiseEffect (  )  { super ( Outcome . Damage ) ; } public AgonizingDemiseEffect ( final AgonizingDemiseEffect effect )  { super ( effect ) ; } @Override public AgonizingDemiseEffect copy (  )  { return new AgonizingDemiseEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanentOrLKIBattlefield ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if ( permanent != null )  { Player controller = game . getPlayer ( permanent . getControllerId (  )  ) ; if ( controller != null )  { int amount = permanent . getPower (  )  . getValue (  ) ; controller . damage ( amount, source . getSourceId (  ) , game, false, true ) ; return true; } } return false; } } 
public class OgreSavant extends CardImpl { public OgreSavant ( UUID ownerId )  { super ( ownerId, 55, "Ogre Savant", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "DDH"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new ReturnToHandTargetEffect (  ) ,false ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, new ManaWasSpentCondition ( ColoredManaSymbol . U ) , "if {U} was spent to cast {this}, return target creature to its owner's hand . " ) , new ManaSpentToCastWatcher (  )  ) ; } public OgreSavant ( final OgreSavant card )  { super ( card ) ; } @Override public OgreSavant copy (  )  { return new OgreSavant ( this ) ; } } 
public class Anathemancer extends CardImpl { public Anathemancer ( UUID ownerId )  { super ( ownerId, 33, "Anathemancer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new DamageTargetEffect ( new AnathemancerCount (  )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new UnearthAbility ( new ManaCostsImpl ( "{5}{B}{R}" )  )  ) ; } public Anathemancer ( final Anathemancer card )  { super ( card ) ; } @Override public Anathemancer copy (  )  { return new Anathemancer ( this ) ; } } class AnathemancerCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { if  ( sourceAbility . getFirstTarget (  )  == null )  { return 0; } FilterLandPermanent filter = new FilterLandPermanent (  ) ; filter . add ( Predicates . not ( new SupertypePredicate ( "Basic" )  )  ) ; filter . add ( new ControllerIdPredicate ( sourceAbility . getFirstTarget (  )  )  ) ; return game . getBattlefield (  )  . count ( filter, sourceAbility . getSourceId (  ) , sourceAbility . getControllerId (  ) , game ) ; } @Override public DynamicValue copy (  )  { return new AnathemancerCount (  ) ; } @Override public String toString (  )  { return "1"; } @Override public String getMessage (  )  { return "nonbasic lands that player controls"; } } 
public class ArchitectsOfWill extends CardImpl { public ArchitectsOfWill ( UUID ownerId )  { super ( ownerId, 17, "Architects of Will", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new ArchitectsOfWillEffect (  ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{U/B}" )  )  ) ; } public ArchitectsOfWill ( final ArchitectsOfWill card )  { super ( card ) ; } @Override public ArchitectsOfWill copy (  )  { return new ArchitectsOfWill ( this ) ; } } class ArchitectsOfWillEffect extends OneShotEffect { public ArchitectsOfWillEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "look at the top three cards of target player's library, then put them back in any order"; } public ArchitectsOfWillEffect ( final ArchitectsOfWillEffect effect )  { super ( effect ) ; } @Override public ArchitectsOfWillEffect copy (  )  { return new ArchitectsOfWillEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer == null || controller == null )  { return false; } Cards cards = new CardsImpl (  ) ; int count = Math . min ( targetPlayer . getLibrary (  )  . size (  ) , 3 ) ; for  ( int i = 0; i < count; i++ )  { Card card = targetPlayer . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { cards . add ( card ) ; } } controller . lookAtCards ( "Architects of Will", cards, game ) ; controller . putCardsOnTopOfLibrary ( cards, game, source, true ) ; return true; } } 
public class ArdentPlea extends CardImpl { public ArdentPlea  ( UUID ownerId )  { super ( ownerId, 1, "Ardent Plea", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new ExaltedAbility (  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public ArdentPlea  ( final ArdentPlea card )  { super ( card ) ; } @Override public ArdentPlea copy (  )  { return new ArdentPlea ( this ) ; } } 
public class ArsenalThresher extends CardImpl { public ArsenalThresher ( UUID ownerId )  { super ( ownerId, 131, "Arsenal Thresher", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}{W/B}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Construct" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new ArsenalThresherEffect (  ) , "you may reveal any number of other artifact cards from your hand .  {this} enters the battlefield with a +1/+1 counter on it for each card revealed this way" )  ) ; } public ArsenalThresher ( final ArsenalThresher card )  { super ( card ) ; } @Override public ArsenalThresher copy (  )  { return new ArsenalThresher ( this ) ; } } class ArsenalThresherEffect extends OneShotEffect { public ArsenalThresherEffect (  )  { super ( Outcome . Benefit ) ; } public ArsenalThresherEffect ( final ArsenalThresherEffect effect )  { super ( effect ) ; } @Override public ArsenalThresherEffect copy (  )  { return new ArsenalThresherEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } Permanent arsenalThresher = game . getPermanentEntering ( source . getSourceId (  )  ) ; FilterArtifactCard filter = new FilterArtifactCard (  ) ; filter . add ( new AnotherCardPredicate (  )  ) ; if  ( controller . chooseUse ( Outcome . Benefit, "Do you want to reveal other artifacts in your hand?", source, game )  )  { Cards cards = new CardsImpl (  ) ; if  ( controller . getHand (  )  . count ( filter, source . getSourceId (  ) , source . getControllerId (  ) , game )  > 0 )  { TargetCardInHand target = new TargetCardInHand ( 0, Integer . MAX_VALUE, filter ) ; if  ( controller . choose ( Outcome . Benefit, target, source . getSourceId (  ) , game )  )  { for  ( UUID uuid : target . getTargets (  )  )  { cards . add ( controller . getHand (  )  . get ( uuid, game )  ) ; } if  ( arsenalThresher != null )  { controller . revealCards ( arsenalThresher . getIdName (  ) , cards, game ) ; arsenalThresher . addCounters ( CounterType . P1P1 . createInstance ( cards . size (  )  ) , game ) ; } } } return true; } return false; } } 
public class AvenMimeomancer extends CardImpl { public AvenMimeomancer ( UUID ownerId )  { super ( ownerId, 2, "Aven Mimeomancer", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new AddCountersTargetEffect ( CounterType . FEATHER . createInstance (  )  ) , TargetController . YOU, true ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; ability . addEffect ( new AvenEffect (  )  ) ; ability . addEffect ( new AvenEffect2 (  )  ) ; this . addAbility ( ability ) ; } public AvenMimeomancer ( final AvenMimeomancer card )  { super ( card ) ; } @Override public AvenMimeomancer copy (  )  { return new AvenMimeomancer ( this ) ; } } class AvenEffect extends ContinuousEffectImpl { public AvenEffect (  )  { super ( Duration . Custom, Layer . PTChangingEffects_7, SubLayer . SetPT_7b, Outcome . BoostCreature ) ; } public AvenEffect ( final AvenEffect effect )  { super ( effect ) ; } @Override public AvenEffect copy (  )  { return new AvenEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent target = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( target != null )  { target . getPower (  )  . setValue ( 3 ) ; target . getToughness (  )  . setValue ( 1 ) ; return true; } return false; } @Override public boolean isInactive ( Ability source, Game game )  { Permanent creature = game . getPermanent ( this . targetPointer . getFirst ( game, source )  ) ; if  ( creature != null && creature . getCounters (  )  . getCount ( CounterType . FEATHER )  < 1 )  { return true; } return false; } @Override public String getText ( Mode mode )  { StringBuilder sb = new StringBuilder (  ) ; sb . append ( "If you do, that creature has base power and toughness 3/1 and has flying for as long as it has a feather counter on it" ) ; return sb . toString (  ) ; } } class AvenEffect2 extends ContinuousEffectImpl { public AvenEffect2 (  )  { super ( Duration . Custom, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . BoostCreature ) ; } public AvenEffect2 ( final AvenEffect2 effect )  { super ( effect ) ; } @Override public AvenEffect2 copy (  )  { return new AvenEffect2 ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent target = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( target != null )  { if  ( !target . getAbilities (  )  . contains ( FlyingAbility . getInstance (  )  )  )  { target . addAbility ( FlyingAbility . getInstance (  ) , source . getSourceId (  ) , game ) ; return true; } } return false; } @Override public boolean isInactive ( Ability source, Game game )  { Permanent creature = game . getPermanent ( this . targetPointer . getFirst ( game, source )  ) ; if  ( creature != null && creature . getCounters (  )  . getCount ( CounterType . FEATHER )  < 1 )  { return true; } return false; } } 
public class BantSojourners extends CardImpl { public BantSojourners ( UUID ownerId )  { super ( ownerId, 125, "Bant Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability1 = new CycleTriggeredAbility ( new CreateTokenEffect ( new SoldierToken (  )  ) , true ) ; Ability ability2 = new DiesTriggeredAbility ( new CreateTokenEffect ( new SoldierToken (  )  ) , true ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{W}" )  )  ) ; } public BantSojourners ( final BantSojourners card )  { super ( card ) ; } @Override public BantSojourners copy (  )  { return new BantSojourners ( this ) ; } } 
public class BantSureblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public BantSureblade ( UUID ownerId )  { super ( ownerId, 143, "Bant Sureblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G/U}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( FirstStrikeAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has first strike" )  ) ; this . addAbility ( ability ) ; } public BantSureblade ( final BantSureblade card )  { super ( card ) ; } @Override public BantSureblade copy (  )  { return new BantSureblade ( this ) ; } } 
public class BehemothSledge extends CardImpl { public BehemothSledge ( UUID ownerId )  { super ( ownerId, 65, "Behemoth Sledge", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 2, 2 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( LifelinkAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( TrampleAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 3 )  )  ) ; } protected BehemothSledge ( BehemothSledge me )  { super ( me ) ; } @Override public BehemothSledge copy (  )  { return new BehemothSledge ( this ) ; } } 
public class BituminousBlast extends CardImpl { public BituminousBlast ( UUID ownerId )  { super ( ownerId, 34, "Bituminous Blast", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 4 )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public BituminousBlast ( final BituminousBlast card )  { super ( card ) ; } @Override public BituminousBlast copy (  )  { return new BituminousBlast ( this ) ; } } 
public class BlitzHellion extends CardImpl { public BlitzHellion ( UUID ownerId )  { super ( ownerId, 49, "Blitz Hellion", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Hellion" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Effect effect = new ShuffleIntoLibrarySourceEffect (  ) ; effect . setText ( "{this}'s owner shuffles it into his or her library . " ) ; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( Zone . BATTLEFIELD, effect, TargetController . ANY, null, false )  ) ; } public BlitzHellion ( final BlitzHellion card )  { super ( card ) ; } @Override public BlitzHellion copy (  )  { return new BlitzHellion ( this ) ; } } 
public class BloodbraidElf extends CardImpl { public BloodbraidElf ( UUID ownerId )  { super ( ownerId, 50, "Bloodbraid Elf", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public BloodbraidElf ( final BloodbraidElf card )  { super ( card ) ; } @Override public BloodbraidElf copy (  )  { return new BloodbraidElf ( this ) ; } } 
public class Brainbite extends CardImpl { public Brainbite ( UUID ownerId )  { super ( ownerId, 18, "Brainbite", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DiscardCardYouChooseTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public Brainbite ( final Brainbite card )  { super ( card ) ; } @Override public Brainbite copy (  )  { return new Brainbite ( this ) ; } } 
public class BreathOfMalfegor extends CardImpl { public BreathOfMalfegor ( UUID ownerId )  { super ( ownerId, 35, "Breath of Malfegor", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DamagePlayersEffect ( 5, TargetController . OPPONENT )  ) ; } public BreathOfMalfegor ( final BreathOfMalfegor card )  { super ( card ) ; } @Override public BreathOfMalfegor copy (  )  { return new BreathOfMalfegor ( this ) ; } } 
public class CapturedSunlight extends CardImpl { public CapturedSunlight  ( UUID ownerId )  { super ( ownerId, 66, "Captured Sunlight", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 4 )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public CapturedSunlight  ( final CapturedSunlight card )  { super ( card ) ; } @Override public CapturedSunlight copy (  )  { return new CapturedSunlight ( this ) ; } } 
public class CerodonYearling extends CardImpl { public CerodonYearling ( UUID ownerId )  { super ( ownerId, 96, "Cerodon Yearling", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; } public CerodonYearling ( final CerodonYearling card )  { super ( card ) ; } @Override public CerodonYearling copy (  )  { return new CerodonYearling ( this ) ; } } 
public class Crystallization extends CardImpl { public Crystallization ( UUID ownerId )  { super ( ownerId, 144, "Crystallization", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{G/U}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantAttackBlockAttachedEffect ( AttachmentType . AURA )  )  ) ; this . addAbility ( new CrystallizationTriggeredAbility (  )  ) ; } public Crystallization ( final Crystallization card )  { super ( card ) ; } @Override public Crystallization copy (  )  { return new Crystallization ( this ) ; } } class CrystallizationTriggeredAbility extends TriggeredAbilityImpl { public CrystallizationTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new ExileTargetEffect (  )  ) ; } public CrystallizationTriggeredAbility ( final CrystallizationTriggeredAbility ability )  { super ( ability ) ; } @Override public CrystallizationTriggeredAbility copy (  )  { return new CrystallizationTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TARGETED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent enchantment = game . getPermanent ( sourceId ) ; if  ( enchantment != null && enchantment . getAttachedTo (  )  != null )  { UUID enchanted = enchantment . getAttachedTo (  ) ; if  ( event . getTargetId (  )  . equals ( enchanted )  )  { getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( enchanted )  ) ; return true; } } return false; } @Override public String getRule (  )  { return "When enchanted creature becomes the target of a spell or ability, exile that creature . "; } } 
public class DauntlessEscort extends CardImpl { public DauntlessEscort ( UUID ownerId )  { super ( ownerId, 67, "Dauntless Escort", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rhino" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; FilterPermanent filter = new FilterControlledCreaturePermanent ( "Creatures you control" ) ; Effect effect = new GainAbilityAllEffect ( IndestructibleAbility . getInstance (  ) , Duration . EndOfTurn, filter, false ) ; effect . setText ( "Creatures you control are indestructible this turn" ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new SacrificeSourceCost (  )  )  ) ; } public DauntlessEscort ( final DauntlessEscort card )  { super ( card ) ; } @Override public DauntlessEscort copy (  )  { return new DauntlessEscort ( this ) ; } } 
public class DeadshotMinotaur extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public DeadshotMinotaur ( UUID ownerId )  { super ( ownerId, 52, "Deadshot Minotaur", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Minotaur" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DamageTargetEffect ( 3 ) , false ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{R/G}" )  )  ) ; } public DeadshotMinotaur ( final DeadshotMinotaur card )  { super ( card ) ; } @Override public DeadshotMinotaur copy (  )  { return new DeadshotMinotaur ( this ) ; } } 
public class DeathbringerThoctar extends CardImpl { public DeathbringerThoctar ( UUID ownerId )  { super ( ownerId, 36, "Deathbringer Thoctar", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , true, true )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new RemoveCountersSourceCost ( CounterType . P1P1 . createInstance (  )  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public DeathbringerThoctar ( final DeathbringerThoctar card )  { super ( card ) ; } @Override public DeathbringerThoctar copy (  )  { return new DeathbringerThoctar ( this ) ; } } 
public class DefilerOfSouls extends CardImpl { public DefilerOfSouls ( UUID ownerId )  { super ( ownerId, 37, "Defiler of Souls", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{B}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new DefilerOfSoulsEffect (  ) , TargetController . ANY, false, true )  ) ; } public DefilerOfSouls ( final DefilerOfSouls card )  { super ( card ) ; } @Override public DefilerOfSouls copy (  )  { return new DefilerOfSouls ( this ) ; } } class DefilerOfSoulsEffect extends OneShotEffect { DefilerOfSoulsEffect (  )  { super ( Outcome . Sacrifice ) ; staticText = "that player sacrifices a monocolored creature"; } DefilerOfSoulsEffect ( final DefilerOfSoulsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "monocolored creature" ) ; Player player = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( player == null )  { return false; } filter . add ( new MonocoloredPredicate (  )  ) ; int amount; int realCount = game . getBattlefield (  )  . countAll ( filter, player . getId (  ) , game ) ; amount = Math . min ( 1, realCount ) ; Target target = new TargetControlledPermanent ( amount, amount, filter, false ) ; target . setNotTarget ( true ) ; if  ( amount > 0 && target . canChoose ( source . getSourceId (  ) , player . getId (  ) , game )  )  { boolean abilityApplied = false; while  ( player . canRespond (  )  && !target . isChosen (  )  && target . canChoose ( player . getId (  ) , game )  )  { player . choose ( Outcome . Sacrifice, target, source . getSourceId (  ) , game ) ; } for  (  int idx = 0; idx < target . getTargets (  )  . size (  ) ; idx++ )  { Permanent permanent = game . getPermanent (  ( UUID ) target . getTargets (  )  . get ( idx )  ) ; if  (  permanent != null  )  { abilityApplied |= permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } return abilityApplied; } return false; } @Override public DefilerOfSoulsEffect copy (  )  { return new DefilerOfSoulsEffect ( this ) ; } } 
public class DemonicDread extends CardImpl { public DemonicDread ( UUID ownerId )  { super ( ownerId, 38, "Demonic Dread", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new CascadeAbility (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CantBlockTargetEffect ( Duration . EndOfTurn )  ) ; } public DemonicDread ( final DemonicDread card )  { super ( card ) ; } @Override public DemonicDread copy (  )  { return new DemonicDread ( this ) ; } } 
public class DemonspineWhip extends CardImpl { public DemonspineWhip ( UUID ownerId )  { super ( ownerId, 39, "Demonspine Whip", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( new XPaid (  ) , new StaticValue ( 0 ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{X}" )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 1 )  )  ) ; } public DemonspineWhip ( final DemonspineWhip card )  { super ( card ) ; } @Override public DemonspineWhip copy (  )  { return new DemonspineWhip ( this ) ; } } class XPaid implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { int paid = sourceAbility . getManaCostsToPay (  )  . getX (  ) ; return paid; } @Override public DynamicValue copy (  )  { return this; } @Override public String getMessage (  )  { return "X paid"; } @Override public String toString (  )  { return "X"; } } 
public class DenyReality extends CardImpl { public DenyReality  ( UUID ownerId )  { super ( ownerId, 19, "Deny Reality", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public DenyReality  ( final DenyReality card )  { super ( card ) ; } @Override public DenyReality copy (  )  { return new DenyReality ( this ) ; } } 
public class DoubleNegative extends CardImpl { public DoubleNegative ( UUID ownerId )  { super ( ownerId, 87, "Double Negative", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{U}{U}{R}" ) ; this . expansionSetCode = "ARB"; Effect effect = new CounterTargetEffect (  ) ; effect . setText ( "Counter up to two target spells" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( 0, 2, new FilterSpell (  )  )  ) ; } public DoubleNegative ( final DoubleNegative card )  { super ( card ) ; } @Override public DoubleNegative copy (  )  { return new DoubleNegative ( this ) ; } } 
public class DragonAppeasement extends CardImpl { public DragonAppeasement ( UUID ownerId )  { super ( ownerId, 115, "Dragon Appeasement", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SkipDrawStepEffect (  )  )  ) ; this . addAbility ( new DragonAppeasementTriggeredAbility (  )  ) ; } public DragonAppeasement ( final DragonAppeasement card )  { super ( card ) ; } @Override public DragonAppeasement copy (  )  { return new DragonAppeasement ( this ) ; } } class DragonAppeasementTriggeredAbility extends TriggeredAbilityImpl { public DragonAppeasementTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , true ) ; setLeavesTheBattlefieldTrigger ( true ) ; } public DragonAppeasementTriggeredAbility ( final DragonAppeasementTriggeredAbility ability )  { super ( ability ) ; } @Override public DragonAppeasementTriggeredAbility copy (  )  { return new DragonAppeasementTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SACRIFICED_PERMANENT; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { return event . getPlayerId (  )  . equals ( this . getControllerId (  )  )  && game . getLastKnownInformation ( event . getTargetId (  ) , Zone . BATTLEFIELD )  . getCardType (  )  . contains ( CardType . CREATURE ) ; } @Override public String getRule (  )  { return "Whenever you sacrifice a creature, " + super . getRule (  ) ; } } 
public class DragonBroodmother extends CardImpl { public DragonBroodmother ( UUID ownerId )  { super ( ownerId, 53, "Dragon Broodmother", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{R}{R}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new CreateTokenEffect ( new DragonToken (  )  ) , TargetController . ANY, false )  ) ; } public DragonBroodmother ( final DragonBroodmother card )  { super ( card ) ; } @Override public DragonBroodmother copy (  )  { return new DragonBroodmother ( this ) ; } } class DragonToken extends Token { DragonToken (  )  { super ( "Dragon", "1/1 red and green Dragon creature token with flying and devour 2" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; color . setRed ( true ) ; subtype . add ( "Dragon" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; addAbility ( new DevourAbility ( DevourEffect . DevourFactor . Devour2 )  ) ; } } 
public class DrasticRevelation extends CardImpl { public DrasticRevelation ( UUID ownerId )  { super ( ownerId, 111, "Drastic Revelation", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{U}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DrasticRevelationEffect (  )  ) ; } public DrasticRevelation ( final DrasticRevelation card )  { super ( card ) ; } @Override public DrasticRevelation copy (  )  { return new DrasticRevelation ( this ) ; } } class DrasticRevelationEffect extends OneShotEffect { DrasticRevelationEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Discard your hand .  Draw seven cards, then discard three cards at random"; } DrasticRevelationEffect ( final DrasticRevelationEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player you = game . getPlayer ( source . getControllerId (  )  ) ; you . discardToMax ( game ) ; you . drawCards ( 7, game ) ; Cards hand = you . getHand (  ) ; for  ( int i = 0; i < 3; i++ )  { Card card = hand . getRandom ( game ) ; if  ( card != null )  { you . discard ( card, source, game ) ; } } return false; } @Override public DrasticRevelationEffect copy (  )  { return new DrasticRevelationEffect ( this ) ; } } 
public class EnigmaSphinx extends CardImpl { public EnigmaSphinx ( UUID ownerId )  { super ( ownerId, 106, "Enigma Sphinx", Rarity . RARE, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Sphinx" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EnigmaSphinxTriggeredAbility ( new EnigmaSphinxEffect (  )  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public EnigmaSphinx ( final EnigmaSphinx card )  { super ( card ) ; } @Override public EnigmaSphinx copy (  )  { return new EnigmaSphinx ( this ) ; } } class EnigmaSphinxTriggeredAbility extends TriggeredAbilityImpl { public EnigmaSphinxTriggeredAbility ( Effect effect )  { this ( effect, false ) ; } public EnigmaSphinxTriggeredAbility ( Effect effect, boolean optional )  { super ( Zone . ALL, effect, optional ) ; } EnigmaSphinxTriggeredAbility ( EnigmaSphinxTriggeredAbility ability )  { super ( ability ) ; } @Override public EnigmaSphinxTriggeredAbility copy (  )  { return new EnigmaSphinxTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; Permanent permanent = zEvent . getTarget (  ) ; if  ( permanent != null && zEvent . getToZone (  )  == Zone . GRAVEYARD && zEvent . getFromZone (  )  == Zone . BATTLEFIELD && permanent . getId (  )  . equals ( this . getSourceId (  )  )  && permanent . getOwnerId (  )  . equals ( permanent . getControllerId (  )  )  )  { return true; } return false; } @Override public String getRule (  )  { return "When {this} is put into your graveyard from the battlefield, " + super . getRule (  ) ; } } class EnigmaSphinxEffect extends OneShotEffect { public EnigmaSphinxEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "put it into your library third from the top"; } public EnigmaSphinxEffect ( final EnigmaSphinxEffect effect )  { super ( effect ) ; } @Override public EnigmaSphinxEffect copy (  )  { return new EnigmaSphinxEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card card = game . getCard ( source . getSourceId (  )  ) ; if  ( card != null && game . getState (  )  . getZone ( source . getSourceId (  )  )  == Zone . GRAVEYARD )  { Player owner = game . getPlayer ( card . getOwnerId (  )  ) ; if  ( owner != null && card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true )  )  { game . informPlayers ( card . getLogName (  )  + " is put into " + owner . getLogName (  )  +"'s library third from the top" ) ; Library lib = owner . getLibrary (  ) ; if  ( lib != null )  { Card card1 = lib . removeFromTop ( game ) ; if  ( card1 != null && card1 . getId (  )  . equals ( source . getSourceId (  )  )  )  { Card card2 = lib . removeFromTop ( game ) ; Card card3 = lib . removeFromTop ( game ) ; lib . putOnTop ( card1, game ) ; if  ( card3 != null )  { lib . putOnTop ( card3, game ) ; } if  ( card2 != null )  { lib . putOnTop ( card2, game ) ; } return true; } } } } return false; } } 
public class EnlistedWurm extends CardImpl { public EnlistedWurm ( UUID ownerId )  { super ( ownerId, 68, "Enlisted Wurm", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public EnlistedWurm ( final EnlistedWurm card )  { super ( card ) ; } @Override public EnlistedWurm copy (  )  { return new EnlistedWurm ( this ) ; } } 
public class EsperSojourners extends CardImpl { public EsperSojourners ( UUID ownerId )  { super ( ownerId, 107, "Esper Sojourners", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Vedalken" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability1 = new CycleTriggeredAbility ( new MayTapOrUntapTargetEffect (  )  ) ; Ability ability2 = new DiesTriggeredAbility ( new MayTapOrUntapTargetEffect (  )  ) ; ability1 . addTarget ( new TargetPermanent (  )  ) ; ability2 . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{U}" )  )  ) ; } public EsperSojourners ( final EsperSojourners card )  { super ( card ) ; } @Override public EsperSojourners copy (  )  { return new EsperSojourners ( this ) ; } } 
public class EsperStormblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public EsperStormblade ( UUID ownerId )  { super ( ownerId, 132, "Esper Stormblade", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{W/B}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Vedalken" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( FlyingAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has flying" )  ) ; this . addAbility ( ability ) ; } public EsperStormblade ( final EsperStormblade card )  { super ( card ) ; } @Override public EsperStormblade copy (  )  { return new EsperStormblade ( this ) ; } } 
public class EthercasteKnight extends CardImpl { public EthercasteKnight  ( UUID ownerId )  { super ( ownerId, 3, "Ethercaste Knight", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new ExaltedAbility (  )  ) ; } public EthercasteKnight  ( final EthercasteKnight card )  { super ( card ) ; } @Override public EthercasteKnight copy (  )  { return new EthercasteKnight ( this ) ; } } 
public class EtheriumAbomination extends CardImpl { public EtheriumAbomination  ( UUID ownerId )  { super ( ownerId, 20, "Etherium Abomination", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new UnearthAbility ( new ManaCostsImpl ( "{1}{U}{B}" )  )  ) ; } public EtheriumAbomination  ( final EtheriumAbomination card )  { super ( card ) ; } @Override public EtheriumAbomination copy (  )  { return new EtheriumAbomination ( this ) ; } } 
public class FieldmistBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public FieldmistBorderpost  ( UUID ownerId )  { super ( ownerId, 5, "Fieldmist Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new WhiteManaAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; } public FieldmistBorderpost  ( final FieldmistBorderpost card )  { super ( card ) ; } @Override public FieldmistBorderpost copy (  )  { return new FieldmistBorderpost ( this ) ; } } 
public class FightToTheDeath extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "all blocking creatures and all blocked creatures" ) ; static { filter . add ( Predicates . or (  new BlockingPredicate (  ) , new BlockedPredicate (  )  )  ) ; } public FightToTheDeath ( UUID ownerId )  { super ( ownerId, 97, "Fight to the Death", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{R}{W}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new DestroyAllEffect ( filter )  ) ; } public FightToTheDeath ( final FightToTheDeath card )  { super ( card ) ; } @Override public FightToTheDeath copy (  )  { return new FightToTheDeath ( this ) ; } } 
public class FiligreeAngel extends CardImpl { public FiligreeAngel  ( UUID ownerId )  { super ( ownerId, 6, "Filigree Angel", Rarity . RARE, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{5}{W}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new FiligreeAngelEffect (  )  )  ) ; } public FiligreeAngel  ( final FiligreeAngel card )  { super ( card ) ; } @Override public FiligreeAngel copy (  )  { return new FiligreeAngel ( this ) ; } } class FiligreeAngelEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterControlledPermanent (  ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; } public FiligreeAngelEffect (  )  { super ( Outcome . GainLife ) ; staticText = "you gain 3 life for each artifact you control"; } public FiligreeAngelEffect ( final FiligreeAngelEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { int life = game . getBattlefield (  )  . count ( filter, source . getSourceId (  ) , source . getControllerId (  ) , game )  * 3; player . gainLife ( life, game ) ; } return true; } @Override public FiligreeAngelEffect copy (  )  { return new FiligreeAngelEffect ( this ) ; } } 
public class FinestHour extends CardImpl { public FinestHour ( UUID ownerId )  { super ( ownerId, 126, "Finest Hour", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new ExaltedAbility (  )  ) ; this . addAbility ( new FinestHourAbility (  )  ) ; } public FinestHour ( final FinestHour card )  { super ( card ) ; } @Override public FinestHour copy (  )  { return new FinestHour ( this ) ; } } class FinestHourAbility extends TriggeredAbilityImpl { public FinestHourAbility (  )  { super ( Zone . BATTLEFIELD, new FinestHourEffect (  )  ) ; } public FinestHourAbility ( final FinestHourAbility ability )  { super ( ability ) ; } @Override public FinestHourAbility copy (  )  { return new FinestHourAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DECLARED_ATTACKERS; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( game . getActivePlayerId (  )  . equals ( this . controllerId )  )  { if  ( game . getCombat (  )  . attacksAlone (  )  )  { for  ( Effect effect: this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( game . getCombat (  )  . getAttackers (  )  . get ( 0 )  )  ) ; } return true; } } return false; } @Override public boolean checkInterveningIfClause ( Game game )  { return game . getTurn (  )  . getPhase ( TurnPhase . COMBAT )  . getCount (  )  == 0; } @Override public String getRule (  )  { return "Whenever a creature you control attacks alone, if it's the first combat phase of the turn, untap that creature .  After this phase, there is an additional combat phase . "; } } class FinestHourEffect extends OneShotEffect { public FinestHourEffect (  )  { super ( Outcome . Benefit ) ; } public FinestHourEffect ( final FinestHourEffect effect )  { super ( effect ) ; } @Override public FinestHourEffect copy (  )  { return new FinestHourEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( permanent != null )  { permanent . untap ( game ) ; game . getState (  )  . getTurnMods (  )  . add ( new TurnMod ( source . getControllerId (  ) , TurnPhase . COMBAT, null, false )  ) ; return true; } return false; } } 
public class FirewildBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public FirewildBorderpost  ( UUID ownerId )  { super ( ownerId, 54, "Firewild Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new RedManaAbility (  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; } public FirewildBorderpost  ( final FirewildBorderpost card )  { super ( card ) ; } @Override public FirewildBorderpost copy (  )  { return new FirewildBorderpost ( this ) ; } } 
public class FlurryOfWings extends CardImpl { private static final FilterAttackingCreature filter = new FilterAttackingCreature ( "the number of attacking creatures" ) ; public FlurryOfWings ( UUID ownerId )  { super ( ownerId, 127, "Flurry of Wings", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new BirdSoldierToken (  ) , new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public FlurryOfWings ( final FlurryOfWings card )  { super ( card ) ; } @Override public FlurryOfWings copy (  )  { return new FlurryOfWings ( this ) ; } } class BirdSoldierToken extends Token { public BirdSoldierToken (  )  { super ( "Bird Soldier", "1/1 white Bird Soldier creature with flying" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Bird" ) ; color . setWhite ( true ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class GiantAmbushBeetle extends CardImpl { public GiantAmbushBeetle ( UUID ownerId )  { super ( ownerId, 137, "Giant Ambush Beetle", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B/G}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Insect" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new MustBeBlockedByTargetSourceEffect ( Duration . EndOfTurn ) , true ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public GiantAmbushBeetle ( final GiantAmbushBeetle card )  { super ( card ) ; } @Override public GiantAmbushBeetle copy (  )  { return new GiantAmbushBeetle ( this ) ; } } 
public class GlassdustHulk extends CardImpl { private static final FilterPermanent filter = new FilterArtifactPermanent ( "another artifact" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public GlassdustHulk ( UUID ownerId )  { super ( ownerId, 7, "Glassdust Hulk", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new EntersBattlefieldControlledTriggeredAbility ( new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , filter, "Whenever another artifact enters the battlefield under your control, Glassdust Hulk gets +1/+1 until end of turn and can't be blocked this turn . " ) ; ability . addEffect ( new CantBeBlockedSourceEffect ( Duration . EndOfTurn )  ) ; this . addAbility ( ability ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{W/U}" )  )  ) ; } public GlassdustHulk ( final GlassdustHulk card )  { super ( card ) ; } @Override public GlassdustHulk copy (  )  { return new GlassdustHulk ( this ) ; } } 
public class GloryOfWarfare extends CardImpl { public GloryOfWarfare  ( UUID ownerId )  { super ( ownerId, 98, "Glory of Warfare", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}{W}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostControlledEffect ( 2, 0, Duration . WhileOnBattlefield ) , MyTurnCondition . getInstance (  ) , "As long as it's your turn, creatures you control get +2/+0" )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostControlledEffect ( 0, 2, Duration . WhileOnBattlefield ) , NotMyTurnCondition . getInstance (  ) , "As long as it's not your turn, creatures you control get +0/+2" )  )  ) ; } public GloryOfWarfare  ( final GloryOfWarfare card )  { super ( card ) ; } @Override public GloryOfWarfare copy (  )  { return new GloryOfWarfare ( this ) ; } } 
public class GloryscaleViashino extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "a multicolored spell" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public GloryscaleViashino  ( UUID ownerId )  { super ( ownerId, 120, "Gloryscale Viashino", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Viashino" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new BoostSourceEffect ( 3, 3, Duration . EndOfTurn ) , filter, false )  ) ; } public GloryscaleViashino  ( final GloryscaleViashino card )  { super ( card ) ; } @Override public GloryscaleViashino copy (  )  { return new GloryscaleViashino ( this ) ; } } 
public class GodtrackerOfJund extends CardImpl { final private static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; static { filter . add ( new PowerPredicate ( Filter . ComparisonType . GreaterThan, 4 )  ) ; } String rule = "Whenever a creature with power 5 or greater enters the battlefield under your control, you may put a +1/+1 counter on {this} . "; public GodtrackerOfJund ( UUID ownerId )  { super ( ownerId, 55, "Godtracker of Jund", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new EntersBattlefieldAllTriggeredAbility ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , filter, true, rule, true )  ) ; } public GodtrackerOfJund ( final GodtrackerOfJund card )  { super ( card ) ; } @Override public GodtrackerOfJund copy (  )  { return new GodtrackerOfJund ( this ) ; } } 
public class GorgerWurm extends CardImpl { public GorgerWurm ( UUID ownerId )  { super ( ownerId, 56, "Gorger Wurm", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DevourAbility ( DevourEffect . DevourFactor . Devour1 )  ) ; } public GorgerWurm ( final GorgerWurm card )  { super ( card ) ; } @Override public GorgerWurm copy (  )  { return new GorgerWurm ( this ) ; } } 
public class GrixisGrimblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public GrixisGrimblade ( UUID ownerId )  { super ( ownerId, 134, "Grixis Grimblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U/R}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( DeathtouchAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has deathtouch" )  ) ; this . addAbility ( ability ) ; } public GrixisGrimblade ( final GrixisGrimblade card )  { super ( card ) ; } @Override public GrixisGrimblade copy (  )  { return new GrixisGrimblade ( this ) ; } } 
public class GrixisSojourners extends CardImpl { public GrixisSojourners ( UUID ownerId )  { super ( ownerId, 112, "Grixis Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Ogre" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability1 = new CycleTriggeredAbility ( new ExileTargetEffect (  ) , true ) ; Ability ability2 = new DiesTriggeredAbility ( new ExileTargetEffect (  ) , true ) ; ability1 . addTarget ( new TargetCardInASingleGraveyard ( 1, 1, new FilterCard (  )  )  ) ; ability2 . addTarget ( new TargetCardInASingleGraveyard ( 1, 1, new FilterCard (  )  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{B}" )  )  ) ; } public GrixisSojourners ( final GrixisSojourners card )  { super ( card ) ; } @Override public GrixisSojourners copy (  )  { return new GrixisSojourners ( this ) ; } } 
public class GrizzledLeotau extends CardImpl { public GrizzledLeotau ( UUID ownerId )  { super ( ownerId, 69, "Grizzled Leotau", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Cat" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 5 ) ; } public GrizzledLeotau ( final GrizzledLeotau card )  { super ( card ) ; } @Override public GrizzledLeotau copy (  )  { return new GrizzledLeotau ( this ) ; } } 
public class IdentityCrisis extends CardImpl { public IdentityCrisis  ( UUID ownerId )  { super ( ownerId, 81, "Identity Crisis", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{W}{W}{B}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new IdentityCrisisEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public IdentityCrisis  ( final IdentityCrisis card )  { super ( card ) ; } @Override public IdentityCrisis copy (  )  { return new IdentityCrisis ( this ) ; } } class IdentityCrisisEffect extends OneShotEffect { IdentityCrisisEffect (  )  { super ( Outcome . Exile ) ; staticText = "Exile all cards from target player's hand and graveyard"; } IdentityCrisisEffect ( final IdentityCrisisEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null )  { for  ( UUID cid : player . getHand (  )  . copy (  )  )  { Card c = game . getCard ( cid ) ; if  ( c != null )  { c . moveToExile ( null, null, source . getSourceId (  ) , game ) ; } } for  ( UUID cid : player . getGraveyard (  )  . copy (  )  )  { Card c = game . getCard ( cid ) ; if  ( c != null )  { c . moveToExile ( null, null, source . getSourceId (  ) , game ) ; } } return true; } return false; } @Override public IdentityCrisisEffect copy (  )  { return new IdentityCrisisEffect ( this ) ; } } 
public class IgneousPouncer extends CardImpl { public IgneousPouncer ( UUID ownerId )  { super ( ownerId, 40, "Igneous Pouncer", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new SwampcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new MountaincyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public IgneousPouncer ( final IgneousPouncer card )  { super ( card ) ; } @Override public IgneousPouncer copy (  )  { return new IgneousPouncer ( this ) ; } } 
public class IllusoryDemon extends CardImpl { public IllusoryDemon ( UUID ownerId )  { super ( ownerId, 21, "Illusory Demon", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Demon" ) ; this . subtype . add ( "Illusion" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new SacrificeSourceEffect (  ) , false )  ) ; } public IllusoryDemon ( final IllusoryDemon card )  { super ( card ) ; } @Override public IllusoryDemon copy (  )  { return new IllusoryDemon ( this ) ; } } 
public class JhessianZombies extends CardImpl { public JhessianZombies ( UUID ownerId )  { super ( ownerId, 22, "Jhessian Zombies", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FearAbility . getInstance (  )  ) ; this . addAbility ( new IslandcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new SwampcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public JhessianZombies ( final JhessianZombies card )  { super ( card ) ; } @Override public JhessianZombies copy (  )  { return new JhessianZombies ( this ) ; } } 
public class JundHackblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public JundHackblade ( UUID ownerId )  { super ( ownerId, 138, "Jund Hackblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B/G}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, {this} gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( HasteAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "and has haste" )  ) ; this . addAbility ( ability ) ; } public JundHackblade ( final JundHackblade card )  { super ( card ) ; } @Override public JundHackblade copy (  )  { return new JundHackblade ( this ) ; } } 
public class JundSojourners extends CardImpl { public JundSojourners ( UUID ownerId )  { super ( ownerId, 116, "Jund Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Viashino" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability1 = new CycleTriggeredAbility ( new DamageTargetEffect ( 1 )  ) ; Ability ability2 = new DiesTriggeredAbility ( new DamageTargetEffect ( 1 )  ) ; ability1 . addTarget ( new TargetCreatureOrPlayer (  )  ) ; ability2 . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{R}" )  )  ) ; } public JundSojourners ( final JundSojourners card )  { super ( card ) ; } @Override public JundSojourners copy (  )  { return new JundSojourners ( this ) ; } } 
public class KarrthusTyrantOfJund extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Dragon creatures you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new SubtypePredicate ( "Dragon" )  ) ; } public KarrthusTyrantOfJund ( UUID ownerId )  { super ( ownerId, 117, "Karrthus, Tyrant of Jund", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new KarrthusEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAllEffect ( HasteAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter, true )  )  ) ; } public KarrthusTyrantOfJund ( final KarrthusTyrantOfJund card )  { super ( card ) ; } @Override public KarrthusTyrantOfJund copy (  )  { return new KarrthusTyrantOfJund ( this ) ; } } class KarrthusEffect extends OneShotEffect { public KarrthusEffect (  )  { super ( Outcome . GainControl ) ; this . staticText = "gain control of all Dragons, then untap all Dragons"; } public KarrthusEffect ( final KarrthusEffect effect )  { super ( effect ) ; } @Override public KarrthusEffect copy (  )  { return new KarrthusEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { FilterPermanent filter = new FilterPermanent (  ) ; filter . add ( new SubtypePredicate ( "Dragon" )  ) ; List<Permanent> dragons = game . getBattlefield (  )  . getAllActivePermanents ( filter, game ) ; for  ( Permanent dragon : dragons )  { ContinuousEffect effect = new KarrthusControlEffect ( source . getControllerId (  )  ) ; effect . setTargetPointer ( new FixedTarget ( dragon . getId (  )  )  ) ; game . addEffect ( effect, source ) ; } for  ( Permanent dragon : dragons )  { dragon . untap ( game ) ; } return true; } } class KarrthusControlEffect extends ContinuousEffectImpl { private UUID controllerId; public KarrthusControlEffect ( UUID controllerId )  { super ( Duration . EndOfGame, Layer . ControlChangingEffects_2, SubLayer . NA, Outcome . GainControl ) ; this . controllerId = controllerId; } public KarrthusControlEffect ( final KarrthusControlEffect effect )  { super ( effect ) ; this . controllerId = effect . controllerId; } @Override public KarrthusControlEffect copy (  )  { return new KarrthusControlEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent dragon = game . getPermanent ( targetPointer . getFirst ( game, source )  ) ; if  ( dragon != null && controllerId != null )  { return dragon . changeControllerId ( controllerId, game ) ; } return false; } } 
public class KathariBomber extends CardImpl { public KathariBomber ( UUID ownerId )  { super ( ownerId, 41, "Kathari Bomber", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility ( new CreateTokenEffect ( new GoblinToken (  ) , 2 ) , false ) ; ability . addEffect ( new SacrificeSourceEffect (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new UnearthAbility ( new ManaCostsImpl ( "{3}{B}{R}" )  )  ) ; } public KathariBomber ( final KathariBomber card )  { super ( card ) ; } @Override public KathariBomber copy (  )  { return new KathariBomber ( this ) ; } } 
public class KathariRemnant extends CardImpl { public KathariRemnant  ( UUID ownerId )  { super ( ownerId, 23, "Kathari Remnant", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Skeleton" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public KathariRemnant  ( final KathariRemnant card )  { super ( card ) ; } @Override public KathariRemnant copy (  )  { return new KathariRemnant ( this ) ; } } 
public class KnightOfNewAlara extends CardImpl { public KnightOfNewAlara ( UUID ownerId )  { super ( ownerId, 70, "Knight of New Alara", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new KnightOfNewAlaraEffect (  )  )  ) ; } public KnightOfNewAlara ( final KnightOfNewAlara card )  { super ( card ) ; } @Override public KnightOfNewAlara copy (  )  { return new KnightOfNewAlara ( this ) ; } } class KnightOfNewAlaraEffect extends ContinuousEffectImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public KnightOfNewAlaraEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . PTChangingEffects_7, SubLayer . ModifyPT_7c, Outcome . BoostCreature ) ; staticText = "Each other multicolored creature you control gets +1/+1 for each of its colors"; } public KnightOfNewAlaraEffect ( final KnightOfNewAlaraEffect effect )  { super ( effect ) ; } @Override public KnightOfNewAlaraEffect copy (  )  { return new KnightOfNewAlaraEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent creature : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { if  ( creature != null && !creature . getId (  )  . equals ( source . getSourceId (  )  )  )  { int colors = creature . getColor ( game )  . getColorCount (  ) ; creature . addPower ( colors ) ; creature . addToughness ( colors ) ; } } return true; } } 
public class KnotvinePaladin extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creature you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public KnotvinePaladin ( UUID ownerId )  { super ( ownerId, 71, "Knotvine Paladin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( new PermanentsOnBattlefieldCount ( filter ) , new PermanentsOnBattlefieldCount ( filter ) , Duration . EndOfTurn ) , false )  ) ; } public KnotvinePaladin ( final KnotvinePaladin card )  { super ( card ) ; } @Override public KnotvinePaladin copy (  )  { return new KnotvinePaladin ( this ) ; } } 
public class Lavalanche extends CardImpl { public Lavalanche ( UUID ownerId )  { super ( ownerId, 118, "Lavalanche", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new LavalancheEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public Lavalanche ( final Lavalanche card )  { super ( card ) ; } @Override public Lavalanche copy (  )  { return new Lavalanche ( this ) ; } } class LavalancheEffect extends OneShotEffect { private DynamicValue amount; public LavalancheEffect ( DynamicValue amount )  { super ( Outcome . Damage ) ; this . amount = amount; staticText = "Lavalanche deals X damage to target player and each creature he or she controls"; } public LavalancheEffect ( final LavalancheEffect effect )  { super ( effect ) ; this . amount = effect . amount; } @Override public LavalancheEffect copy (  )  { return new LavalancheEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer == null )  { return false; } targetPlayer . damage ( amount . calculate ( game, source, this ) , source . getSourceId (  ) , game, false, true ) ; FilterPermanent filter = new FilterPermanent ( "and each creature he or she controls" ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; filter . add ( new ControllerIdPredicate ( targetPlayer . getId (  )  )  ) ; List<Permanent> permanents = game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game ) ; for  ( Permanent permanent: permanents )  { permanent . damage ( amount . calculate ( game, source, this ) , source . getSourceId (  ) , game, false, true ) ; } return true; } } 
public class LeoninArmorguard extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creatures you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public LeoninArmorguard ( UUID ownerId )  { super ( ownerId, 72, "Leonin Armorguard", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Cat" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new BoostAllEffect ( 1, 1, Duration . EndOfTurn, filter, false )  )  ) ; } public LeoninArmorguard ( final LeoninArmorguard card )  { super ( card ) ; } @Override public LeoninArmorguard copy (  )  { return new LeoninArmorguard ( this ) ; } } 
public class LichLordOfUnx extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Zombies you control" ) ; static { filter . add ( new SubtypePredicate ( "Zombie" )  ) ; } public LichLordOfUnx  ( UUID ownerId )  { super ( ownerId, 24, "Lich Lord of Unx", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new ZombieWizardToken (  )  ) , new ManaCostsImpl ( "{U}{B}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new LoseLifeTargetEffect ( new PermanentsOnBattlefieldCount ( filter )  ) , new ManaCostsImpl ( "{U}{U}{B}{B}" )  ) ; ability . addEffect ( new PutLibraryIntoGraveTargetEffect ( new PermanentsOnBattlefieldCount ( filter, 1 )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public LichLordOfUnx  ( final LichLordOfUnx card )  { super ( card ) ; } @Override public LichLordOfUnx copy (  )  { return new LichLordOfUnx ( this ) ; } } class ZombieWizardToken extends Token { ZombieWizardToken (  )  { super ( "Zombie Wizard", "a 1/1 blue and black Zombie Wizard creature token" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; color . setBlack ( true ) ; subtype . add ( "Zombie" ) ; subtype . add ( "Wizard" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; } } 
public class LightningReaver extends CardImpl { public LightningReaver ( UUID ownerId )  { super ( ownerId, 42, "Lightning Reaver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( FearAbility . getInstance (  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . CHARGE . createInstance (  )  ) , false )  ) ; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( new DamageOpponentsEffect (  ) , TargetController . YOU, false )  ) ; } public LightningReaver ( final LightningReaver card )  { super ( card ) ; } @Override public LightningReaver copy (  )  { return new LightningReaver ( this ) ; } } class DamageOpponentsEffect extends OneShotEffect { public DamageOpponentsEffect (  )  { super ( Outcome . Damage ) ; staticText = "Lightning Reaver deals damage equal to the number of charge counters on it to each opponent"; } public DamageOpponentsEffect ( final DamageOpponentsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { DynamicValue amount = new CountersCount ( CounterType . CHARGE ) ; for  ( UUID playerId : game . getOpponents ( source . getControllerId (  )  )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { player . damage ( amount . calculate ( game, source, this ) , source . getSourceId (  ) , game, false, true ) ; } } return true; } @Override public DamageOpponentsEffect copy (  )  { return new DamageOpponentsEffect ( this ) ; } } 
public class LordOfExtinction extends CardImpl { public LordOfExtinction ( UUID ownerId )  { super ( ownerId, 91, "Lord of Extinction", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new SetPowerToughnessSourceEffect ( new LordOfExtinctionDynamicCount (  ) , Duration . EndOfGame )  )  ) ; } public LordOfExtinction ( final LordOfExtinction card )  { super ( card ) ; } @Override public LordOfExtinction copy (  )  { return new LordOfExtinction ( this ) ; } } class LordOfExtinctionDynamicCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { int count = 0; for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( sourceAbility . getControllerId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { count += player . getGraveyard (  )  . size (  ) ; } } return count; } @Override public DynamicValue copy (  )  { return new LordOfExtinctionDynamicCount (  ) ; } @Override public String getMessage (  )  { return "cards in all graveyards"; } @Override public String toString (  )  { return "1"; } } 
public class LorescaleCoatl extends CardImpl { public LorescaleCoatl  ( UUID ownerId )  { super ( ownerId, 101, "Lorescale Coatl", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DrawCardControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , true )  ) ; } public LorescaleCoatl  ( final LorescaleCoatl card )  { super ( card ) ; } @Override public LorescaleCoatl copy (  )  { return new LorescaleCoatl ( this ) ; } } 
public class MadrushCyclops extends CardImpl { public MadrushCyclops  ( UUID ownerId )  { super ( ownerId, 119, "Madrush Cyclops", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Cyclops" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( HasteAbility . getInstance (  ) , Duration . WhileOnBattlefield, new FilterCreaturePermanent (  )  )  )  ) ; } public MadrushCyclops  ( final MadrushCyclops card )  { super ( card ) ; } @Override public MadrushCyclops copy (  )  { return new MadrushCyclops ( this ) ; } } 
public class MaelstromNexus extends CardImpl { public MaelstromNexus ( UUID ownerId )  { super ( ownerId, 130, "Maelstrom Nexus", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT}, "{W}{U}{B}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MaelstromNexusGainCascadeFirstSpellEffect (  )  ) , new FirstSpellCastThisTurnWatcher (  )  ) ; } public MaelstromNexus ( final MaelstromNexus card )  { super ( card ) ; } @Override public MaelstromNexus copy (  )  { return new MaelstromNexus ( this ) ; } } class MaelstromNexusGainCascadeFirstSpellEffect extends ContinuousEffectImpl { private Ability cascadeAbility = new CascadeAbility (  ) ; public MaelstromNexusGainCascadeFirstSpellEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; staticText = "The first spell you cast each turn has cascade"; } public MaelstromNexusGainCascadeFirstSpellEffect ( final MaelstromNexusGainCascadeFirstSpellEffect effect )  { super ( effect ) ; } @Override public MaelstromNexusGainCascadeFirstSpellEffect copy (  )  { return new MaelstromNexusGainCascadeFirstSpellEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { for  ( StackObject stackObject : game . getStack (  )  )  { if  (  ( stackObject instanceof Spell )  && !stackObject . isCopy (  )  && stackObject . getControllerId (  )  . equals ( source . getControllerId (  )  )  )  { Spell spell =  ( Spell )  stackObject; FirstSpellCastThisTurnWatcher watcher =  ( FirstSpellCastThisTurnWatcher )  game . getState (  )  . getWatchers (  )  . get ( "FirstSpellCastThisTurn" ) ; if  ( watcher != null && spell . getId (  )  . equals ( watcher . getIdOfFirstCastSpell ( source . getControllerId (  )  )  )  )  { game . getState (  )  . addOtherAbility ( spell . getCard (  ) , cascadeAbility ) ; } } } return true; } return false; } } class FirstSpellCastThisTurnWatcher extends Watcher { Map<UUID, UUID> playerFirstSpellCast = new HashMap<> (  ) ; Map<UUID, UUID> playerFirstCastSpell = new HashMap<> (  ) ; public FirstSpellCastThisTurnWatcher (  )  { super ( "FirstSpellCastThisTurn", WatcherScope . GAME ) ; } public FirstSpellCastThisTurnWatcher ( final FirstSpellCastThisTurnWatcher watcher )  { super ( watcher ) ; } @Override public void watch ( GameEvent event, Game game )  { switch  ( event . getType (  )  )  { case SPELL_CAST: case CAST_SPELL: Spell spell =  ( Spell )  game . getObject ( event . getTargetId (  )  ) ; if  ( spell != null && !playerFirstSpellCast . containsKey ( spell . getControllerId (  )  )  )  { if  ( event . getType (  )  . equals ( EventType . SPELL_CAST )  )  { playerFirstSpellCast . put ( spell . getControllerId (  ) , spell . getId (  )  ) ; } else if  ( event . getType (  )  . equals ( EventType . CAST_SPELL )  )  { playerFirstCastSpell . put ( spell . getControllerId (  ) , spell . getId (  )  ) ; } } } } @Override public FirstSpellCastThisTurnWatcher copy (  )  { return new FirstSpellCastThisTurnWatcher ( this ) ; } @Override public void reset (  )  { super . reset (  ) ; playerFirstSpellCast . clear (  ) ; playerFirstCastSpell . clear (  ) ; } public UUID getIdOfFirstCastSpell ( UUID playerId )  { if  ( playerFirstSpellCast . get ( playerId )  == null )  { return playerFirstCastSpell . get ( playerId ) ; } else { return playerFirstSpellCast . get ( playerId ) ; } } } 
public class MaelstromPulse extends CardImpl { public MaelstromPulse ( UUID ownerId )  { super ( ownerId, 92, "Maelstrom Pulse", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{1}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetNonlandPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyAllNamedPermanentsEffect (  )  ) ; } public MaelstromPulse ( final MaelstromPulse card )  { super ( card ) ; } @Override public MaelstromPulse copy (  )  { return new MaelstromPulse ( this ) ; } } 
public class MagefireWings extends CardImpl { public MagefireWings  ( UUID ownerId )  { super ( ownerId, 88, "Magefire Wings", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{U}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 0, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; } public MagefireWings  ( final MagefireWings card )  { super ( card ) ; } @Override public MagefireWings copy (  )  { return new MagefireWings ( this ) ; } } 
public class MarrowChomper extends CardImpl { public MarrowChomper ( UUID ownerId )  { super ( ownerId, 93, "Marrow Chomper", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Lizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DevourAbility ( DevourEffect . DevourFactor . Devour2 )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( new DevouredCreaturesCount ( 2 )  )  )  ) ; } public MarrowChomper ( final MarrowChomper card )  { super ( card ) ; } @Override public MarrowChomper copy (  )  { return new MarrowChomper ( this ) ; } } 
public class MaskOfRiddles extends CardImpl { public MaskOfRiddles ( UUID ownerId )  { super ( ownerId, 25, "Mask of Riddles", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FearAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new DealsDamageToAPlayerAttachedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , "equipped", true )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 )  )  ) ; } public MaskOfRiddles ( final MaskOfRiddles card )  { super ( card ) ; } @Override public MaskOfRiddles copy (  )  { return new MaskOfRiddles ( this ) ; } } 
public class MayaelsAria extends CardImpl { public MayaelsAria ( UUID ownerId )  { super ( ownerId, 121, "Mayael's Aria", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new MayaelsAriaEffect (  ) , TargetController . YOU, false )  ) ; } public MayaelsAria ( final MayaelsAria card )  { super ( card ) ; } @Override public MayaelsAria copy (  )  { return new MayaelsAria ( this ) ; } } class MayaelsAriaEffect extends OneShotEffect { public MayaelsAriaEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "put a +1/+1 counter on each creature you control if you control a creature with power 5 or greater .  Then you gain 10 life if you control a creature with power 10 or greater .  Then you win the game if you control a creature with power 20 or greater"; } public MayaelsAriaEffect ( final MayaelsAriaEffect effect )  { super ( effect ) ; } @Override public MayaelsAriaEffect copy (  )  { return new MayaelsAriaEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; filter . add ( new PowerPredicate ( Filter . ComparisonType . GreaterThan, 4 )  ) ; if  ( game . getState (  )  . getBattlefield (  )  . countAll ( filter, controller . getId (  ) , game )  > 0 )  { for  ( Permanent creature : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { creature . addCounters ( CounterType . P1P1 . createInstance (  ) , game ) ; } } game . applyEffects (  ) ;  
public class MeddlingMage extends CardImpl { public MeddlingMage ( UUID ownerId )  { super ( ownerId, 8, "Meddling Mage", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new NameACardEffect ( NameACardEffect . TypeOfName . NON_LAND_NAME )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MeddlingMageReplacementEffect (  )  )  ) ; } public MeddlingMage ( final MeddlingMage card )  { super ( card ) ; } @Override public MeddlingMage copy (  )  { return new MeddlingMage ( this ) ; } } class MeddlingMageReplacementEffect extends ContinuousRuleModifyingEffectImpl { public MeddlingMageReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Detriment ) ; staticText = "The named card can't be cast"; } public MeddlingMageReplacementEffect ( final MeddlingMageReplacementEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public MeddlingMageReplacementEffect copy (  )  { return new MeddlingMageReplacementEffect ( this ) ; } @Override public String getInfoMessage ( Ability source, GameEvent event, Game game )  { MageObject mageObject = game . getObject ( source . getSourceId (  )  ) ; if  ( mageObject != null )  { return "You can't cast a card with that name  ( " + mageObject . getLogName (  )  + " in play )  . "; } return null; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . CAST_SPELL; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { MageObject object = game . getObject ( event . getSourceId (  )  ) ; return object != null && !object . isCopy (  )  && object . getName (  )  . equals ( game . getState (  )  . getValue ( source . getSourceId (  )  . toString (  )  + NameACardEffect . INFO_KEY )  ) ; } } 
public class MessengerFalcons extends CardImpl { public MessengerFalcons ( UUID ownerId )  { super ( ownerId, 145, "Messenger Falcons", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G/U}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; } public MessengerFalcons ( final MessengerFalcons card )  { super ( card ) ; } @Override public MessengerFalcons copy (  )  { return new MessengerFalcons ( this ) ; } } 
public class MindFuneral extends CardImpl { public MindFuneral ( UUID ownerId )  { super ( ownerId, 26, "Mind Funeral", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new MindFuneralEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public MindFuneral ( final MindFuneral card )  { super ( card ) ; } @Override public MindFuneral copy (  )  { return new MindFuneral ( this ) ; } } class MindFuneralEffect extends OneShotEffect { public MindFuneralEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "Target opponent reveals cards from the top of his or her library until four land cards are revealed .  That player puts all cards revealed this way into his or her graveyard"; } public MindFuneralEffect ( final MindFuneralEffect effect )  { super ( effect ) ; } @Override public MindFuneralEffect copy (  )  { return new MindFuneralEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player opponent = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( opponent != null )  { Cards cards = new CardsImpl (  ) ; int landsFound = 0; while  ( landsFound < 4 && opponent . getLibrary (  )  . size (  )  > 0 )  { Card card = opponent . getLibrary (  )  . removeFromTop ( game ) ; if  ( card == null )  { break; } if  ( card . getCardType (  )  . contains ( CardType . LAND )  )  { landsFound++; } cards . add ( card ) ; } opponent . revealCards ( "Mind Funeral", cards, game ) ; opponent . moveCards ( cards, Zone . LIBRARY, Zone . GRAVEYARD, source, game ) ; return true; } return false; } } 
public class MistveinBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public MistveinBorderpost  ( UUID ownerId )  { super ( ownerId, 27, "Mistvein Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public MistveinBorderpost  ( final MistveinBorderpost card )  { super ( card ) ; } @Override public MistveinBorderpost copy (  )  { return new MistveinBorderpost ( this ) ; } } 
public class MonstrousCarabid extends CardImpl { public MonstrousCarabid ( UUID ownerId )  { super ( ownerId, 43, "Monstrous Carabid", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Insect" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new AttacksEachTurnStaticAbility (  )  ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{B/R}" )  )  ) ; } public MonstrousCarabid ( final MonstrousCarabid card )  { super ( card ) ; } @Override public MonstrousCarabid copy (  )  { return new MonstrousCarabid ( this ) ; } } 
public class MorbidBloom extends CardImpl { public MorbidBloom ( UUID ownerId )  { super ( ownerId, 94, "Morbid Bloom", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{B}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new MorbidBloomEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInGraveyard ( new FilterCreatureCard ( "creature from a graveyard" )  )  ) ; } public MorbidBloom ( final MorbidBloom card )  { super ( card ) ; } @Override public MorbidBloom copy (  )  { return new MorbidBloom ( this ) ; } } class MorbidBloomEffect extends OneShotEffect { public MorbidBloomEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "Exile target creature card from a graveyard, then put X 1/1 green Saproling creature tokens onto the battlefield, where X is the exiled card's toughness"; } public MorbidBloomEffect ( final MorbidBloomEffect effect )  { super ( effect ) ; } @Override public MorbidBloomEffect copy (  )  { return new MorbidBloomEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card targetCreatureCard = game . getCard ( source . getFirstTarget (  )  ) ; if  ( targetCreatureCard != null )  { targetCreatureCard . moveToExile ( null, null, source . getSourceId (  ) , game ) ; int toughness = targetCreatureCard . getToughness (  )  . getValue (  ) ; SaprolingToken token = new SaprolingToken (  ) ; return token . putOntoBattlefield ( toughness, game, source . getSourceId (  ) , source . getControllerId (  )  ) ; } return false; } } 
public class MycoidShepherd extends CardImpl { public MycoidShepherd ( UUID ownerId )  { super ( ownerId, 73, "Mycoid Shepherd", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Fungus" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new MycoidShepherdTriggeredAbility (  )  ) ; } public MycoidShepherd ( final MycoidShepherd card )  { super ( card ) ; } @Override public MycoidShepherd copy (  )  { return new MycoidShepherd ( this ) ; } } class MycoidShepherdTriggeredAbility extends TriggeredAbilityImpl { public MycoidShepherdTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new GainLifeEffect ( 5 ) , true ) ; } public MycoidShepherdTriggeredAbility ( final MycoidShepherdTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { MageObject lastKnown = game . getLastKnownInformation ( event . getTargetId (  ) , Zone . BATTLEFIELD ) ; if  ( lastKnown == null )  { return false; } ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; Permanent permanent = zEvent . getTarget (  ) ; if  ( permanent == null )  { return false; } if  ( super . getSourceId (  )  . equals ( event . getTargetId (  )  )  || permanent . getPower (  )  . getValue (  )  > 4 && permanent . getControllerId (  )  . equals ( controllerId )  )  { Zone after = game . getState (  )  . getZone ( event . getTargetId (  )  ) ; return after != null && Zone . GRAVEYARD . match ( after ) ; } return false; } @Override public String getRule (  )  { return "Whenever Mycoid Shepherd or another creature you control with power 5 or greater dies, you may gain 5 life . "; } @Override public MycoidShepherdTriggeredAbility copy (  )  { return new MycoidShepherdTriggeredAbility ( this ) ; } } 
public class NayaHushblade extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "another multicolor permanent" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public NayaHushblade ( UUID ownerId )  { super ( ownerId, 141, "Naya Hushblade", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R/W}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostSourceEffect ( 1,1, Duration . WhileOnBattlefield ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "As long as you control another multicolored permanent, Naya Hushblade gets +1/+1" )  ) ; ability . addEffect ( new ConditionalContinuousEffect (  new GainAbilitySourceEffect ( ShroudAbility . getInstance (  )  ) , new PermanentsOnTheBattlefieldCondition ( filter ) , " and has shroud" )  ) ; this . addAbility ( ability ) ; } public NayaHushblade ( final NayaHushblade card )  { super ( card ) ; } @Override public NayaHushblade copy (  )  { return new NayaHushblade ( this ) ; } } 
public class NayaSojourners extends CardImpl { public NayaSojourners ( UUID ownerId )  { super ( ownerId, 122, "Naya Sojourners", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability1 = new CycleTriggeredAbility ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance (  )  )  ) ; Ability ability2 = new DiesTriggeredAbility ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance (  )  )  ) ; ability1 . addTarget ( new TargetCreaturePermanent (  )  ) ; ability2 . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability1 ) ; this . addAbility ( ability2 ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{2}{G}" )  )  ) ; } public NayaSojourners ( final NayaSojourners card )  { super ( card ) ; } @Override public NayaSojourners copy (  )  { return new NayaSojourners ( this ) ; } } 
public class NecromancersCovenant extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Zombies you control" ) ; static { filter . add ( new SubtypePredicate ( "Zombie" )  ) ; } public NecromancersCovenant ( UUID ownerId )  { super ( ownerId, 82, "Necromancer's Covenant", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}{B}{B}" ) ; this . expansionSetCode = "ARB"; Ability ability = new EntersBattlefieldTriggeredAbility ( new NecromancersConvenantEffect (  ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAllEffect ( LifelinkAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter )  )  ) ; } public NecromancersCovenant ( final NecromancersCovenant card )  { super ( card ) ; } @Override public NecromancersCovenant copy (  )  { return new NecromancersCovenant ( this ) ; } } class NecromancersConvenantEffect extends OneShotEffect { public NecromancersConvenantEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "exile all creature cards from target player's graveyard, then put a 2/2 black Zombie creature token onto the battlefield for each card exiled this way"; } public NecromancersConvenantEffect ( NecromancersConvenantEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player == null )  { return false; } int count = 0; for  ( Card card : player . getGraveyard (  )  . getCards ( new FilterCreatureCard (  ) , game )  )  { if  ( card . moveToExile ( source . getSourceId (  ) , "Necromancer Covenant", source . getSourceId (  ) , game )  )  { count += 1; } } ZombieToken zombieToken = new ZombieToken (  ) ; if  ( zombieToken . putOntoBattlefield ( count, game, source . getSourceId (  ) , source . getControllerId (  )  )  )  { return true; } return false; } @Override public NecromancersConvenantEffect copy (  )  { return new NecromancersConvenantEffect ( this ) ; } } 
public class NemesisOfReason extends CardImpl { public NemesisOfReason  ( UUID ownerId )  { super ( ownerId, 28, "Nemesis of Reason", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Leviathan" ) ; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 7 ) ; Effect effect = new PutLibraryIntoGraveTargetEffect ( 10 ) ; effect . setText ( "defending player puts the top ten cards of his or her library into his or her graveyard" ) ; this . addAbility ( new NemesisOfReasonTriggeredAbility ( effect )  ) ; } public NemesisOfReason  ( final NemesisOfReason card )  { super ( card ) ; } @Override public NemesisOfReason copy (  )  { return new NemesisOfReason ( this ) ; } } class NemesisOfReasonTriggeredAbility extends TriggeredAbilityImpl { NemesisOfReasonTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect ) ; } NemesisOfReasonTriggeredAbility ( final NemesisOfReasonTriggeredAbility ability )  { super ( ability ) ; } @Override public NemesisOfReasonTriggeredAbility copy (  )  { return new NemesisOfReasonTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  . equals ( this . getSourceId (  )  )   )  { UUID defenderId = game . getCombat (  )  . getDefendingPlayerId ( this . getSourceId (  ) , game ) ; for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( defenderId )  ) ; } return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} attacks, defending player puts the top ten cards of his or her library into his or her graveyard . "; } } 
public class NulltreadGargantuan extends CardImpl { public NulltreadGargantuan  ( UUID ownerId )  { super ( ownerId, 102, "Nulltread Gargantuan", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 6 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new PutOnLibraryTargetEffect ( true ) , false ) ; Target target = new TargetControlledCreaturePermanent (  ) ; target . setNotTarget ( true ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public NulltreadGargantuan  ( final NulltreadGargantuan card )  { super ( card ) ; } @Override public NulltreadGargantuan copy (  )  { return new NulltreadGargantuan ( this ) ; } } 
public class OfferingToAsha extends CardImpl { public OfferingToAsha ( UUID ownerId )  { super ( ownerId, 9, "Offering to Asha", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetSpell (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CounterUnlessPaysEffect ( new GenericManaCost ( 4 )  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 4 )  ) ; } public OfferingToAsha ( final OfferingToAsha card )  { super ( card ) ; } @Override public OfferingToAsha copy (  )  { return new OfferingToAsha ( this ) ; } } 
public class PaleRecluse extends CardImpl { public PaleRecluse ( UUID ownerId )  { super ( ownerId, 74, "Pale Recluse", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Spider" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; this . addAbility ( new ForestcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new PlainscyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public PaleRecluse ( final PaleRecluse card )  { super ( card ) ; } @Override public PaleRecluse copy (  )  { return new PaleRecluse ( this ) ; } } 
public class PredatoryAdvantage extends CardImpl { public PredatoryAdvantage ( UUID ownerId )  { super ( ownerId, 58, "Predatory Advantage", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new BeginningOfEndStepTriggeredAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new LizardToken (  )  ) , TargetController . OPPONENT, new DidNotCastCreatureCondition (  ) , false ) , new CastCreatureWatcher (  )  ) ; } public PredatoryAdvantage ( final PredatoryAdvantage card )  { super ( card ) ; } @Override public PredatoryAdvantage copy (  )  { return new PredatoryAdvantage ( this ) ; } } class DidNotCastCreatureCondition implements Condition { @Override public boolean apply ( Game game, Ability source )  { Permanent p = game . getPermanent ( source . getSourceId (  )  ) ; if  ( p != null )  { Watcher watcher = game . getState (  )  . getWatchers (  )  . get ( "CastCreature", source . getSourceId (  )  ) ; if  ( watcher != null && !watcher . conditionMet (  )  )  { return true; } } return false; } @Override public String toString (  )  { StringBuilder sb = new StringBuilder ( "if that player didn't cast a creature spell this turn" ) ; return sb . toString (  ) ; } } class CastCreatureWatcher extends Watcher { public CastCreatureWatcher (  )  { super ( "CastCreature", WatcherScope . CARD ) ; } public CastCreatureWatcher ( final CastCreatureWatcher watcher )  { super ( watcher ) ; } @Override public void watch ( GameEvent event, Game game )  { if  ( event . getType (  )  == GameEvent . EventType . SPELL_CAST && game . getActivePlayerId (  )  . equals ( event . getPlayerId (  )  )  && game . getOpponents ( controllerId )  . contains ( event . getPlayerId (  )  )  )  { Spell spell =  ( Spell )  game . getObject ( event . getTargetId (  )  ) ; if  ( spell . getCardType (  )  . contains ( CardType . CREATURE )  )  { condition = true; } } } @Override public CastCreatureWatcher copy (  )  { return new CastCreatureWatcher ( this ) ; } } class LizardToken extends Token { public LizardToken (  )  { super ( "Lizard", "2/2 green Lizard creature token onto the battlefield" ) ; cardType . add ( CardType . CREATURE ) ; color . setGreen ( true ) ; subtype . add ( "Lizard" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 2 ) ; } } 
public class RebornHope extends CardImpl { private static final FilterCard filter = new FilterCard ( "multicolored card from your graveyard" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public RebornHope ( UUID ownerId )  { super ( ownerId, 76, "Reborn Hope", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{G}{W}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToHandTargetEffect (  )  ) ; } public RebornHope ( final RebornHope card )  { super ( card ) ; } @Override public RebornHope copy (  )  { return new RebornHope ( this ) ; } } 
public class RetaliatorGriffin extends CardImpl { public RetaliatorGriffin ( UUID ownerId )  { super ( ownerId, 123, "Retaliator Griffin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Griffin" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new RetaliatorGriffinTriggeredAbility (  )  ) ; } public RetaliatorGriffin ( final RetaliatorGriffin card )  { super ( card ) ; } @Override public RetaliatorGriffin copy (  )  { return new RetaliatorGriffin ( this ) ; } } class RetaliatorGriffinTriggeredAbility extends TriggeredAbilityImpl { public RetaliatorGriffinTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new RetaliatorGriffinEffect (  ) , true ) ; } public RetaliatorGriffinTriggeredAbility ( final RetaliatorGriffinTriggeredAbility ability )  { super ( ability ) ; } @Override public RetaliatorGriffinTriggeredAbility copy (  )  { return new RetaliatorGriffinTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  . equals ( GameEvent . EventType . DAMAGED_PLAYER ) ; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( getControllerId (  )  )  )  { UUID sourceControllerId = game . getControllerId ( event . getSourceId (  )  ) ; if  ( sourceControllerId != null && game . getOpponents ( getControllerId (  )  )  . contains ( sourceControllerId )  )  { getEffects (  )  . get ( 0 )  . setValue ( "damageAmount", event . getAmount (  )  ) ; return true; } } return false; } @Override public String getRule (  )  { return "Whenever a source an opponent controls deals damage to you, you may put that many +1/+1 counters on {this} . "; } } class RetaliatorGriffinEffect extends OneShotEffect { public RetaliatorGriffinEffect (  )  { super ( Outcome . BoostCreature ) ; } public RetaliatorGriffinEffect ( final RetaliatorGriffinEffect effect )  { super ( effect ) ; } @Override public RetaliatorGriffinEffect copy (  )  { return new RetaliatorGriffinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; Integer amount =  ( Integer )  this . getValue ( "damageAmount" ) ; if  ( permanent != null && amount != null && amount > 0 )  { new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( amount ) , true )  . apply ( game, source ) ; } return true; } return false; } } 
public class RhoxBrute extends CardImpl { public RhoxBrute  ( UUID ownerId )  { super ( ownerId, 59, "Rhox Brute", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rhino" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; } public RhoxBrute  ( final RhoxBrute card )  { super ( card ) ; } @Override public RhoxBrute copy (  )  { return new RhoxBrute ( this ) ; } } 
public class SagesOfTheAnima extends CardImpl { public SagesOfTheAnima ( UUID ownerId )  { super ( ownerId, 103, "Sages of the Anima", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SagesOfTheAnimaReplacementEffect (  )  )  ) ; } public SagesOfTheAnima ( final SagesOfTheAnima card )  { super ( card ) ; } @Override public SagesOfTheAnima copy (  )  { return new SagesOfTheAnima ( this ) ; } } class SagesOfTheAnimaReplacementEffect extends ReplacementEffectImpl { public SagesOfTheAnimaReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "If you would draw a card, instead reveal the top three cards of your library .  Put all creature cards revealed this way into your hand and the rest on the bottom of your library in any order"; } public SagesOfTheAnimaReplacementEffect ( final SagesOfTheAnimaReplacementEffect effect )  { super ( effect ) ; } @Override public SagesOfTheAnimaReplacementEffect copy (  )  { return new SagesOfTheAnimaReplacementEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { FilterCard filter = new FilterCard (  ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; Player player = game . getPlayer ( event . getPlayerId (  )  ) ; Cards cards = new CardsImpl (  ) ; if  ( player != null )  { for  ( int i = 0; i < 3; i++ )  { Card card = player . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { cards . add ( card ) ; } } player . revealCards ( "Top three cards of library revealed", cards, game ) ; for  ( Card revealedCard : cards . getCards ( game )  )  { if  ( revealedCard . getCardType (  )  . contains ( CardType . CREATURE )  )  { revealedCard . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; cards . remove ( revealedCard ) ; } } TargetCard target = new TargetCard ( Zone . LIBRARY, new FilterCard (  )  ) ; while  ( player . canRespond (  )  && cards . size (  )  > 1 )  { player . choose ( Outcome . Neutral, cards, target, game ) ; Card card = cards . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { cards . remove ( card ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } target . clearChosen (  ) ; } if  ( cards . size (  )  == 1 )  { Card card = cards . get ( cards . iterator (  )  . next (  ) , game ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } } return true; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DRAW_CARD; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getPlayerId (  )  . equals ( source . getControllerId (  )  ) ; } } 
public class SanctumPlowbeast extends CardImpl { public SanctumPlowbeast ( UUID ownerId )  { super ( ownerId, 10, "Sanctum Plowbeast", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( new PlainscyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new IslandcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public SanctumPlowbeast ( final SanctumPlowbeast card )  { super ( card ) ; } @Override public SanctumPlowbeast copy (  )  { return new SanctumPlowbeast ( this ) ; } } 
public class SangriteBacklash extends CardImpl { public SangriteBacklash ( UUID ownerId )  { super ( ownerId, 139, "Sangrite Backlash", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{B/G}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 3, -3 )  )  ) ; } public SangriteBacklash ( final SangriteBacklash card )  { super ( card ) ; } @Override public SangriteBacklash copy (  )  { return new SangriteBacklash ( this ) ; } } 
public class SanityGnawers extends CardImpl { public SanityGnawers ( UUID ownerId )  { super ( ownerId, 44, "Sanity Gnawers", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rat" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DiscardTargetEffect ( 1, true ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public SanityGnawers ( final SanityGnawers card )  { super ( card ) ; } @Override public SanityGnawers copy (  )  { return new SanityGnawers ( this ) ; } } 
public class SenTriplets extends CardImpl { public SenTriplets ( UUID ownerId )  { super ( ownerId, 109, "Sen Triplets", Rarity . MYTHIC, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new SenTripletsRuleModifyingEffect (  ) , TargetController . YOU, false, false ) ; ability . addEffect ( new SenTripletsOpponentRevealsHandEffect (  )  ) ; ability . addEffect ( new SenTripletsPlayFromOpponentsHandEffect (  )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public SenTriplets ( final SenTriplets card )  { super ( card ) ; } @Override public SenTriplets copy (  )  { return new SenTriplets ( this ) ; } } class SenTripletsRuleModifyingEffect extends ContinuousRuleModifyingEffectImpl { public SenTripletsRuleModifyingEffect (  )  { super ( Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "At the beginning of your upkeep, choose target opponent .  This turn, that player can't cast spells or activate abilities"; } public SenTripletsRuleModifyingEffect ( final SenTripletsRuleModifyingEffect effect )  { super ( effect ) ; } @Override public SenTripletsRuleModifyingEffect copy (  )  { return new SenTripletsRuleModifyingEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public String getInfoMessage ( Ability source, GameEvent event, Game game )  { Player targetPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; MageObject mageObject = game . getObject ( source . getSourceId (  )  ) ; if  ( targetPlayer != null && mageObject != null )  { return "This turn you can't cast spells or activate abilities" + "  ( " + mageObject . getLogName (  )  + " ) "; } return null; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . CAST_SPELL || event . getType (  )  == GameEvent . EventType . ACTIVATE_ABILITY; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getPlayerId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  ) ; } } class SenTripletsOpponentRevealsHandEffect extends ContinuousEffectImpl { public SenTripletsOpponentRevealsHandEffect (  )  { super ( Duration . EndOfTurn, Layer . PlayerEffects, SubLayer . NA, Outcome . Detriment ) ; staticText = "and plays with his or her hand revealed"; } public SenTripletsOpponentRevealsHandEffect ( final SenTripletsOpponentRevealsHandEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( player != null )  { player . revealCards ( player . getName (  )  + "'s hand cards", player . getHand (  ) , game, false ) ; } return true; } @Override public SenTripletsOpponentRevealsHandEffect copy (  )  { return new SenTripletsOpponentRevealsHandEffect ( this ) ; } } class SenTripletsPlayFromOpponentsHandEffect extends AsThoughEffectImpl { public SenTripletsPlayFromOpponentsHandEffect (  )  { super ( AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE, Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "You may play cards from that player's hand this turn"; } public SenTripletsPlayFromOpponentsHandEffect ( final SenTripletsPlayFromOpponentsHandEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public SenTripletsPlayFromOpponentsHandEffect copy (  )  { return new SenTripletsPlayFromOpponentsHandEffect ( this ) ; } @Override public boolean applies ( UUID objectId, Ability source, UUID affectedControllerId, Game game )  { Card card = game . getCard ( objectId ) ; return card != null && card . getOwnerId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  )  && game . getState (  )  . getZone ( objectId )  . equals ( Zone . HAND )  && affectedControllerId . equals ( source . getControllerId (  )  ) ; } } 
public class SewnEyeDrake extends CardImpl { public SewnEyeDrake  ( UUID ownerId )  { super ( ownerId, 135, "Sewn-Eye Drake", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U/R}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; } public SewnEyeDrake  ( final SewnEyeDrake card )  { super ( card ) ; } @Override public SewnEyeDrake copy (  )  { return new SewnEyeDrake ( this ) ; } } 
public class ShieldOfTheRighteous extends CardImpl { public ShieldOfTheRighteous ( UUID ownerId )  { super ( ownerId, 11, "Shield of the Righteous", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 0, 2 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( VigilanceAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new BlocksCreatureAttachedTriggeredAbility ( new DontUntapInControllersNextUntapStepTargetEffect ( "that creature" ) , "equipped", false, false, true )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 ) , new TargetControlledCreaturePermanent (  )  )  ) ; } public ShieldOfTheRighteous ( final ShieldOfTheRighteous card )  { super ( card ) ; } @Override public ShieldOfTheRighteous copy (  )  { return new ShieldOfTheRighteous ( this ) ; } } 
public class SigilCaptain extends CardImpl { public SigilCaptain ( UUID ownerId )  { super ( ownerId, 77, "Sigil Captain", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{W}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Rhino" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SigilCaptainTriggeredAbility (  )  ) ; } public SigilCaptain ( final SigilCaptain card )  { super ( card ) ; } @Override public SigilCaptain copy (  )  { return new SigilCaptain ( this ) ; } } class SigilCaptainTriggeredAbility extends TriggeredAbilityImpl { public SigilCaptainTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new AddCountersTargetEffect ( CounterType . P1P1 . createInstance ( 2 )  )  ) ; } public SigilCaptainTriggeredAbility ( final SigilCaptainTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent == null )  { return false; } if  ( permanent . getControllerId (  )  . equals ( controllerId )  && permanent . getPower (  )  . getValue (  )  == 1 && permanent . getToughness (  )  . getValue (  )  == 1 )  { for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( event . getTargetId (  )  )  ) ; } return true; } return false; } @Override public SigilCaptainTriggeredAbility copy (  )  { return new SigilCaptainTriggeredAbility ( this ) ; } @Override public String getRule (  )  { StringBuilder sb = new StringBuilder (  ) ; sb . append ( "Whenever a creature enters the battlefield under your control, if that creature is 1/1, put two +1/+1 counters on it" ) ; return sb . toString (  ) ; } } 
public class SigiledBehemoth extends CardImpl { public SigiledBehemoth  ( UUID ownerId )  { super ( ownerId, 79, "Sigiled Behemoth", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new ExaltedAbility (  )  ) ; } public SigiledBehemoth  ( final SigiledBehemoth card )  { super ( card ) ; } @Override public SigiledBehemoth copy (  )  { return new SigiledBehemoth ( this ) ; } } 
public class SigilOfTheNayanGods extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; public SigilOfTheNayanGods ( UUID ownerId )  { super ( ownerId, 78, "Sigil of the Nayan Gods", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; this . addAbility ( new EnchantAbility ( auraTarget . getTargetName (  )  )  ) ; PermanentsOnBattlefieldCount amount = new PermanentsOnBattlefieldCount ( filter, 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( amount, amount, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new CyclingAbility ( new ManaCostsImpl ( "{G/W}" )  )  ) ; } public SigilOfTheNayanGods ( final SigilOfTheNayanGods card )  { super ( card ) ; } @Override public SigilOfTheNayanGods copy (  )  { return new SigilOfTheNayanGods ( this ) ; } } 
public class SingeMindOgre extends CardImpl { public SingeMindOgre ( UUID ownerId )  { super ( ownerId, 45, "Singe-Mind Ogre", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Ogre" ) ; this . subtype . add ( "Mutant" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new SingeMindOgreEffect (  ) , false ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public SingeMindOgre ( final SingeMindOgre card )  { super ( card ) ; } @Override public SingeMindOgre copy (  )  { return new SingeMindOgre ( this ) ; } } class SingeMindOgreEffect extends OneShotEffect { public SingeMindOgreEffect (  )  { super ( Outcome . LoseLife ) ; this . staticText = "target player reveals a card at random from his or her hand, then loses life equal to that card's converted mana cost"; } public SingeMindOgreEffect ( final SingeMindOgreEffect effect )  { super ( effect ) ; } @Override public SingeMindOgreEffect copy (  )  { return new SingeMindOgreEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer != null && targetPlayer . getHand (  )  . size (  )  > 0 )  { Cards revealed = new CardsImpl (  ) ; Card card = targetPlayer . getHand (  )  . getRandom ( game ) ; revealed . add ( card ) ; targetPlayer . revealCards ( "Singe-Mind Ogre", revealed, game ) ; targetPlayer . loseLife ( card . getManaCost (  )  . convertedManaCost (  ) , game ) ; return true; } return false; } } 
public class SkyclawThrash extends CardImpl { public SkyclawThrash ( UUID ownerId )  { super ( ownerId, 89, "Skyclaw Thrash", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}{U}{R}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Viashino" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; } public SkyclawThrash ( final SkyclawThrash card )  { super ( card ) ; } @Override public SkyclawThrash copy (  )  { return new SkyclawThrash ( this ) ; } } 
public class SlaveOfBolas extends CardImpl { public SlaveOfBolas ( UUID ownerId )  { super ( ownerId, 136, "Slave of Bolas", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{U/R}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new GainControlTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new UntapTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new SlaveOfBolasEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public SlaveOfBolas ( final SlaveOfBolas card )  { super ( card ) ; } @Override public SlaveOfBolas copy (  )  { return new SlaveOfBolas ( this ) ; } } class SlaveOfBolasEffect extends OneShotEffect { public SlaveOfBolasEffect (  )  { super ( Outcome . Sacrifice ) ; staticText = "Sacrifice it at the beginning of the next end step"; } public SlaveOfBolasEffect ( final SlaveOfBolasEffect effect )  { super ( effect ) ; } @Override public SlaveOfBolasEffect copy (  )  { return new SlaveOfBolasEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect ( "sacrifice this", source . getControllerId (  )  ) ; sacrificeEffect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( sacrificeEffect ) ; game . addDelayedTriggeredAbility ( delayedAbility, source ) ; return true; } return false; } } 
public class SoulManipulation extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "creature spell" ) ; private static final FilterCreatureCard filter2 = new FilterCreatureCard ( "creature card from your graveyard" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public SoulManipulation ( UUID ownerId )  { super ( ownerId, 29, "Soul Manipulation", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . getModes (  )  . setMinModes ( 1 ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 2 ) ; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new ReturnFromGraveyardToHandTargetEffect (  )  ) ; mode . getTargets (  )  . add ( new TargetCardInYourGraveyard ( filter2 )  ) ; this . getSpellAbility (  )  . addMode ( mode ) ; } public SoulManipulation ( final SoulManipulation card )  { super ( card ) ; } @Override public SoulManipulation copy (  )  { return new SoulManipulation ( this ) ; } } 
public class Soulquake extends CardImpl { public Soulquake ( UUID ownerId )  { super ( ownerId, 30, "Soulquake", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}{U}{B}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new SoulquakeEffect (  )  ) ; } public Soulquake ( final Soulquake card )  { super ( card ) ; } @Override public Soulquake copy (  )  { return new Soulquake ( this ) ; } } class SoulquakeEffect extends OneShotEffect { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature" ) ; private static final FilterCreatureCard filter2 = new FilterCreatureCard ( "creature" ) ; public SoulquakeEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "Return all creatures on the battlefield and all creature cards in graveyards to their owners' hands"; } public SoulquakeEffect ( final SoulquakeEffect effect )  { super ( effect ) ; } @Override public SoulquakeEffect copy (  )  { return new SoulquakeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, true ) ; } for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( source . getControllerId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { for  ( Card card : player . getGraveyard (  )  . getCards ( filter2, game )  )  { card . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, true ) ; } } } return true; } } 
public class SpellbreakerBehemoth extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "Creature spells you control with power 5 or greater" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; filter . add ( new PowerPredicate ( Filter . ComparisonType . GreaterThan, 4 )  ) ; } public SpellbreakerBehemoth ( UUID ownerId )  { super ( ownerId, 60, "Spellbreaker Behemoth", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{R}{G}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . STACK, new CantBeCounteredSourceEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeCounteredControlledEffect ( filter, Duration . WhileOnBattlefield )  )  ) ; } public SpellbreakerBehemoth ( final SpellbreakerBehemoth card )  { super ( card ) ; } @Override public SpellbreakerBehemoth copy (  )  { return new SpellbreakerBehemoth ( this ) ; } } 
public class SphinxOfTheSteelWind extends CardImpl { private static final FilterCard filter = new FilterCard ( "red and from green" ) ; static { filter . add ( Predicates . or (  new ColorPredicate ( ObjectColor . RED ) , new ColorPredicate ( ObjectColor . GREEN )  )  ) ; } public SphinxOfTheSteelWind  ( UUID ownerId )  { super ( ownerId, 110, "Sphinx of the Steel Wind", Rarity . MYTHIC, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{5}{W}{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Sphinx" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( LifelinkAbility . getInstance (  )  ) ; this . addAbility ( new ProtectionAbility ( filter )  ) ; } public SphinxOfTheSteelWind  ( final SphinxOfTheSteelWind card )  { super ( card ) ; } @Override public SphinxOfTheSteelWind copy (  )  { return new SphinxOfTheSteelWind ( this ) ; } } 
public class StormcallersBoon extends CardImpl { public StormcallersBoon ( UUID ownerId )  { super ( ownerId, 13, "Stormcaller's Boon", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilityControlledEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn, new FilterControlledCreaturePermanent ( "Creatures" )  ) , new SacrificeSourceCost (  )  )  ) ; this . addAbility ( new CascadeAbility (  )  ) ; } public StormcallersBoon ( final StormcallersBoon card )  { super ( card ) ; } @Override public StormcallersBoon copy (  )  { return new StormcallersBoon ( this ) ; } } 
public class StunSniper extends CardImpl { public StunSniper  ( UUID ownerId )  { super ( ownerId, 100, "Stun Sniper", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}{W}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Archer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addEffect ( new TapTargetEffect (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public StunSniper  ( final StunSniper card )  { super ( card ) ; } @Override public StunSniper copy (  )  { return new StunSniper ( this ) ; } } 
public class TaintedSigil extends CardImpl { String rule = "You gain life equal to the total life lost by all players this turn"; public TaintedSigil ( UUID ownerId )  { super ( ownerId, 83, "Tainted Sigil", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}{W}{B}" ) ; this . expansionSetCode = "ARB"; AllPlayersLostLifeCount totalLifeLostThisTurn = new AllPlayersLostLifeCount (  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( totalLifeLostThisTurn, rule ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public TaintedSigil ( final TaintedSigil card )  { super ( card ) ; } @Override public TaintedSigil copy (  )  { return new TaintedSigil ( this ) ; } } class AllPlayersLostLifeCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { return this . calculate ( game, sourceAbility . getControllerId (  )  ) ; } public int calculate ( Game game, UUID controllerId )  { PlayerLostLifeWatcher watcher =  ( PlayerLostLifeWatcher )  game . getState (  )  . getWatchers (  )  . get ( "PlayerLostLifeWatcher" ) ; if  ( watcher != null )  { int amountLifeLost = 0; for  ( UUID playerId : game . getPlayerList (  )  )  { amountLifeLost += watcher . getLiveLost ( playerId ) ; } return amountLifeLost; } return 0; } @Override public DynamicValue copy (  )  { return new AllPlayersLostLifeCount (  ) ; } @Override public String toString (  )  { return "X"; } @Override public String getMessage (  )  { return "the total life lost by all players this turn"; } } 
public class TalonTrooper extends CardImpl { public TalonTrooper  ( UUID ownerId )  { super ( ownerId, 14, "Talon Trooper", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Bird" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } public TalonTrooper  ( final TalonTrooper card )  { super ( card ) ; } @Override public TalonTrooper copy (  )  { return new TalonTrooper ( this ) ; } } 
public class Terminate extends CardImpl { public Terminate ( UUID ownerId )  { super ( ownerId, 46, "Terminate", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect ( true )  ) ; } public Terminate ( final Terminate card )  { super ( card ) ; } @Override public Terminate copy (  )  { return new Terminate ( this ) ; } } 
public class ThopterFoundry extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "a nontoken artifact" ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; filter . add ( Predicates . not ( new TokenPredicate (  )  )  ) ; } public ThopterFoundry ( UUID ownerId )  { super ( ownerId, 133, "Thopter Foundry", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{W/B}{U}" ) ; this . expansionSetCode = "ARB"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new ThopterToken (  )  ) , new GenericManaCost ( 1 )  ) ; ability . addEffect ( new GainLifeEffect ( 1 )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public ThopterFoundry ( final ThopterFoundry card )  { super ( card ) ; } @Override public ThopterFoundry copy (  )  { return new ThopterFoundry ( this ) ; } } class ThopterToken extends Token { ThopterToken (  )  { super ( "Thopter", "a 1/1 blue Thopter artifact creature token with flying" ) ; cardType . add ( CardType . CREATURE ) ; cardType . add ( CardType . ARTIFACT ) ; color . setBlue ( true ) ; subtype . add ( "Thopter" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class ThoughtHemorrhage extends CardImpl { public ThoughtHemorrhage ( UUID ownerId )  { super ( ownerId, 47, "Thought Hemorrhage", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new NameACardEffect ( NameACardEffect . TypeOfName . NON_LAND_NAME )  ) ; this . getSpellAbility (  )  . addEffect ( new ThoughtHemorrhageEffect (  )  ) ; } public ThoughtHemorrhage ( final ThoughtHemorrhage card )  { super ( card ) ; } @Override public ThoughtHemorrhage copy (  )  { return new ThoughtHemorrhage ( this ) ; } } class ThoughtHemorrhageEffect extends OneShotEffect { final String rule = "Target player reveals his or her hand .  {this} deals 3 damage to that player for each card with that name revealed this way .  Search that player's graveyard, hand, and library for all cards with that name and exile them .  Then that player shuffles his or her library"; public ThoughtHemorrhageEffect (  )  { super ( Outcome . Detriment ) ; staticText = rule; } public ThoughtHemorrhageEffect ( final ThoughtHemorrhageEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; String cardName =  ( String )  game . getState (  )  . getValue ( source . getSourceId (  )  . toString (  )  + NameACardEffect . INFO_KEY ) ; if  ( sourceObject != null && controller != null && cardName != null && !cardName . isEmpty (  )  )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( targetPlayer != null )  { targetPlayer . revealCards ( "hand of " + targetPlayer . getName (  ) , targetPlayer . getHand (  ) , game ) ; int cardsFound = 0; for  ( Card card : targetPlayer . getHand (  )  . getCards ( game )  )  { if  ( card . getName (  )  . equals ( cardName )  )  { cardsFound++; } } if  ( cardsFound > 0 )  { targetPlayer . damage ( 3 * cardsFound, source . getSourceId (  ) , game, false, true ) ; } FilterCard filterNamedCards = new FilterCard (  ) ; filterNamedCards . add ( new NamePredicate ( cardName )  ) ; for  ( Card checkCard : targetPlayer . getGraveyard (  )  . getCards ( game )  )  { if  ( checkCard . getName (  )  . equals ( cardName )  )  { controller . moveCardToExileWithInfo ( checkCard, null, "", source . getSourceId (  ) , game, Zone . GRAVEYARD, true ) ; } } TargetCardInHand targetCardsHand = new TargetCardInHand ( 0, Integer . MAX_VALUE, filterNamedCards ) ; controller . chooseTarget ( outcome, targetPlayer . getGraveyard (  ) , targetCardsHand, source, game ) ; for ( UUID cardId: targetCardsHand . getTargets (  )  )  { Card card = game . getCard ( cardId ) ; if  ( card != null )  { controller . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . HAND, true ) ; } } TargetCardInLibrary targetCardsLibrary = new TargetCardInLibrary ( 0, Integer . MAX_VALUE, filterNamedCards ) ; controller . searchLibrary ( targetCardsLibrary, game, targetPlayer . getId (  )  ) ; for ( UUID cardId: targetCardsLibrary . getTargets (  )  )  { Card card = game . getCard ( cardId ) ; if  ( card != null )  { controller . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . LIBRARY, true ) ; } } targetPlayer . shuffleLibrary ( game ) ; return true; } } return false; } @Override public ThoughtHemorrhageEffect copy (  )  { return new ThoughtHemorrhageEffect ( this ) ; } } 
public class Thraximundar extends CardImpl { public Thraximundar ( UUID ownerId )  { super ( ownerId, 113, "Thraximundar", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{U}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Assassin" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new ThraximundarTriggeredAbility (  )  ) ; this . addAbility ( new PlayerSacrificesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , true )  ) ; } public Thraximundar ( final Thraximundar card )  { super ( card ) ; } @Override public Thraximundar copy (  )  { return new Thraximundar ( this ) ; } } class ThraximundarTriggeredAbility extends TriggeredAbilityImpl { private static final FilterControlledPermanent filter; static { filter = new FilterControlledPermanent ( " a creature" ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public ThraximundarTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new SacrificeEffect ( filter, 1, "defending player" )  ) ; } public ThraximundarTriggeredAbility ( final ThraximundarTriggeredAbility ability )  { super ( ability ) ; } @Override public ThraximundarTriggeredAbility copy (  )  { return new ThraximundarTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  != null && event . getSourceId (  )  . equals ( this . getSourceId (  )  )  )  { UUID defender = game . getCombat (  )  . getDefendingPlayerId ( this . getSourceId (  ) , game ) ; this . getEffects (  )  . get ( 0 )  . setTargetPointer ( new FixedTarget ( defender )  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} attacks, defending player sacrifices a creature . "; } } class PlayerSacrificesCreatureTriggeredAbility extends TriggeredAbilityImpl { public PlayerSacrificesCreatureTriggeredAbility ( Effect effect, boolean optional )  { super ( Zone . BATTLEFIELD, effect, optional ) ; } public PlayerSacrificesCreatureTriggeredAbility ( final PlayerSacrificesCreatureTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . SACRIFICED_PERMANENT; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { MageObject mageObject = game . getLastKnownInformation ( event . getTargetId (  ) , Zone . BATTLEFIELD ) ; return mageObject != null && mageObject . getCardType (  )  . contains ( CardType . CREATURE ) ; } @Override public String getRule (  )  { return "Whenever a player sacrifices a creature, " + super . getRule (  ) ; } @Override public PlayerSacrificesCreatureTriggeredAbility copy (  )  { return new PlayerSacrificesCreatureTriggeredAbility ( this ) ; } } 
public class TimeSieve extends CardImpl { public TimeSieve ( UUID ownerId )  { super ( ownerId, 31, "Time Sieve", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{U}{B}" ) ; this . expansionSetCode = "ARB"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddExtraTurnControllerEffect (  ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( 5, 5, new FilterControlledArtifactPermanent ( "five artifacts" ) , true )  )  ) ; this . addAbility ( ability ) ; } public TimeSieve ( final TimeSieve card )  { super ( card ) ; } @Override public TimeSieve copy (  )  { return new TimeSieve ( this ) ; } } 
public class TraceOfAbundance extends CardImpl { private String rule = "Enchanted land has shroud"; public TraceOfAbundance ( UUID ownerId )  { super ( ownerId, 142, "Trace of Abundance", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{R/W}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Benefit )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ShroudAbility . getInstance (  ) , AttachmentType . AURA, Duration . WhileOnBattlefield, rule )  )  ) ; this . addAbility ( new TraceOfAbundanceTriggeredAbility (  )  ) ; } public TraceOfAbundance ( final TraceOfAbundance card )  { super ( card ) ; } @Override public TraceOfAbundance copy (  )  { return new TraceOfAbundance ( this ) ; } } class TraceOfAbundanceTriggeredAbility extends TriggeredManaAbility { public TraceOfAbundanceTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new AddManaAnyColorAttachedControllerEffect (  )  ) ; } public TraceOfAbundanceTriggeredAbility ( final TraceOfAbundanceTriggeredAbility ability )  { super ( ability ) ; } @Override public TraceOfAbundanceTriggeredAbility copy (  )  { return new TraceOfAbundanceTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TAPPED_FOR_MANA; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent enchantment = game . getPermanent ( this . getSourceId (  )  ) ; return enchantment != null && event . getSourceId (  )  . equals ( enchantment . getAttachedTo (  )  ) ; } @Override public String getRule (  )  { return "Whenever enchanted land is tapped for mana, its controller adds one mana of any color to his or her mana pool . "; } } 
public class UnbenderTine extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "another target permanent" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public UnbenderTine ( UUID ownerId )  { super ( ownerId, 15, "Unbender Tine", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}{W}{U}" ) ; this . expansionSetCode = "ARB"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new UnbenderTineEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public UnbenderTine ( final UnbenderTine card )  { super ( card ) ; } @Override public UnbenderTine copy (  )  { return new UnbenderTine ( this ) ; } } class UnbenderTineEffect extends OneShotEffect { public UnbenderTineEffect (  )  { super ( Outcome . Untap ) ; this . staticText = "Untap another target permanent"; } public UnbenderTineEffect ( final UnbenderTineEffect effect )  { super ( effect ) ; } @Override public UnbenderTineEffect copy (  )  { return new UnbenderTineEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent targetPermanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( targetPermanent == null )  { return false; } return targetPermanent . untap ( game ) ; } } 
public class UnscytheKillerOfKings extends CardImpl { public UnscytheKillerOfKings ( UUID ownerId )  { super ( ownerId, 114, "Unscythe, Killer of Kings", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{U}{B}{B}{R}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 3, 3 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FirstStrikeAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new UnscytheKillerOfKingsTriggeredAbility ( new UnscytheEffect (  )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 2 ) , new TargetControlledCreaturePermanent (  )  )  ) ; } public UnscytheKillerOfKings ( final UnscytheKillerOfKings card )  { super ( card ) ; } @Override public UnscytheKillerOfKings copy (  )  { return new UnscytheKillerOfKings ( this ) ; } } class UnscytheKillerOfKingsTriggeredAbility extends TriggeredAbilityImpl { public UnscytheKillerOfKingsTriggeredAbility ( Effect effect )  { super ( Zone . ALL, effect, true ) ; } public UnscytheKillerOfKingsTriggeredAbility ( final UnscytheKillerOfKingsTriggeredAbility ability )  { super ( ability ) ; } @Override public UnscytheKillerOfKingsTriggeredAbility copy (  )  { return new UnscytheKillerOfKingsTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ZONE_CHANGE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  (  (  ( ZoneChangeEvent )  event )  . isDiesEvent (  )  )  { ZoneChangeEvent zEvent =  ( ZoneChangeEvent )  event; if  ( zEvent . getTarget (  )  . getCardType (  )  . contains ( CardType . CREATURE )  )  {  
public class UrilTheMiststalker extends CardImpl { public UrilTheMiststalker ( UUID ownerId )  { super ( ownerId, 124, "Uril, the Miststalker", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{R}{G}{W}" ) ; this . expansionSetCode = "ARB"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( HexproofAbility . getInstance (  )  ) ; AuraAttachedCount count = new AuraAttachedCount ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( count, count, Duration . WhileOnBattlefield )  )  ) ; } public UrilTheMiststalker ( final UrilTheMiststalker card )  { super ( card ) ; } @Override public UrilTheMiststalker copy (  )  { return new UrilTheMiststalker ( this ) ; } } 
public class ValleyRannet extends CardImpl { public ValleyRannet ( UUID ownerId )  { super ( ownerId, 61, "Valley Rannet", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new MountaincyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; this . addAbility ( new ForestcyclingAbility ( new ManaCostsImpl ( "{2}" )  )  ) ; } public ValleyRannet ( final ValleyRannet card )  { super ( card ) ; } @Override public ValleyRannet copy (  )  { return new ValleyRannet ( this ) ; } } 
public class VectisDominator extends CardImpl { public VectisDominator ( UUID ownerId )  { super ( ownerId, 84, "Vectis Dominator", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{1}{W}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new VectisDominatorEffect ( new PayLifeCost ( 2 )  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public VectisDominator ( final VectisDominator card )  { super ( card ) ; } @Override public VectisDominator copy (  )  { return new VectisDominator ( this ) ; } } class VectisDominatorEffect extends OneShotEffect { protected Cost cost; public VectisDominatorEffect ( Cost cost )  { super ( Outcome . Detriment ) ; this . staticText = "Tap target creature unless its controller pays 2 life"; this . cost = cost; } public VectisDominatorEffect ( final VectisDominatorEffect effect )  { super ( effect ) ; this . cost = effect . cost . copy (  ) ; } @Override public VectisDominatorEffect copy (  )  { return new VectisDominatorEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent targetCreature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( targetCreature != null )  { Player player = game . getPlayer ( targetCreature . getControllerId (  )  ) ; if  ( player != null )  { cost . clearPaid (  ) ; final StringBuilder sb = new StringBuilder ( "Pay 2 life?  ( Otherwise " )  . append ( targetCreature . getName (  )  )  . append ( " will be tapped ) " ) ; if  ( player . chooseUse ( Outcome . Benefit, sb . toString (  ) , source, game )  )  { cost . pay ( source, game, targetCreature . getControllerId (  ) , targetCreature . getControllerId (  ) , true, null ) ; } if  ( !cost . isPaid (  )  )  { return targetCreature . tap ( game ) ; } } } return false; } } 
public class VedalkenGhoul extends CardImpl { public VedalkenGhoul ( UUID ownerId )  { super ( ownerId, 32, "Vedalken Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}{B}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Vedalken" ) ; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new VedalkenGhoulTriggeredAbility (  )  ) ; } public VedalkenGhoul ( final VedalkenGhoul card )  { super ( card ) ; } @Override public VedalkenGhoul copy (  )  { return new VedalkenGhoul ( this ) ; } } class VedalkenGhoulTriggeredAbility extends TriggeredAbilityImpl { public VedalkenGhoulTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new LoseLifeTargetEffect ( 4 ) , false ) ; } public VedalkenGhoulTriggeredAbility ( final VedalkenGhoulTriggeredAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . CREATURE_BLOCKED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getTargetId (  )  . equals ( this . getSourceId (  )  )  )  { UUID defendingPlayer = game . getCombat (  )  . getDefenderId ( this . getSourceId (  )  ) ; if  ( defendingPlayer != null )  { for  ( Effect effect : this . getEffects (  )  )  { effect . setTargetPointer ( new FixedTarget ( defendingPlayer )  ) ; } return true; } } return false; } @Override public String getRule (  )  { return "Whenever {this} becomes blocked, defending player loses 4 life . "; } @Override public VedalkenGhoulTriggeredAbility copy (  )  { return new VedalkenGhoulTriggeredAbility ( this ) ; } } 
public class VengefulRebirth extends CardImpl { public VengefulRebirth ( UUID ownerId )  { super ( ownerId, 62, "Vengeful Rebirth", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new VengefulRebirthEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( ExileSpellEffect . getInstance (  )  ) ; } public VengefulRebirth ( final VengefulRebirth card )  { super ( card ) ; } @Override public VengefulRebirth copy (  )  { return new VengefulRebirth ( this ) ; } } class VengefulRebirthEffect extends OneShotEffect { public VengefulRebirthEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Return target card from your graveyard to your hand .  If you return a nonland card to your hand this way, {this} deals damage equal to that card's converted mana cost to target creature or player"; } public VengefulRebirthEffect ( final VengefulRebirthEffect effect )  { super ( effect ) ; } @Override public VengefulRebirthEffect copy (  )  { return new VengefulRebirthEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Card card =  ( Card ) game . getObject ( source . getFirstTarget (  )  ) ; if  ( controller != null && card != null && controller . removeFromGraveyard ( card, game )  )  { controller . moveCards ( card, Zone . GRAVEYARD, Zone . HAND, source, game ) ; if  ( !card . getCardType (  )  . contains ( CardType . LAND )  )  { int damage = card . getManaCost (  )  . convertedManaCost (  ) ; Permanent permanent = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . damage ( damage, source . getSourceId (  ) , game, false, true ) ; } Player targetPlayer = game . getPlayer ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( targetPlayer != null )  { targetPlayer . damage ( damage, source . getSourceId (  ) , game, false, true ) ; } } return true; } return false; } } 
public class ViolentOutburst extends CardImpl { public ViolentOutburst ( UUID ownerId )  { super ( ownerId, 63, "Violent Outburst", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . addAbility ( new CascadeAbility (  )  ) ; this . getSpellAbility (  )  . addEffect ( new BoostControlledEffect ( 1, 0, Duration . EndOfTurn )  ) ; } public ViolentOutburst ( final ViolentOutburst card )  { super ( card ) ; } @Override public ViolentOutburst copy (  )  { return new ViolentOutburst ( this ) ; } } 
public class VithianRenegades extends CardImpl { public VithianRenegades  ( UUID ownerId )  { super ( ownerId, 64, "Vithian Renegades", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}{G}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DestroyTargetEffect (  )  ) ; ability . addTarget ( new TargetPermanent ( new FilterArtifactPermanent (  )  )  ) ; this . addAbility ( ability ) ; } public VithianRenegades  ( final VithianRenegades card )  { super ( card ) ; } @Override public VithianRenegades copy (  )  { return new VithianRenegades ( this ) ; } } 
public class WallOfDenial extends CardImpl { public WallOfDenial  ( UUID ownerId )  { super ( ownerId, 16, "Wall of Denial", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 8 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( ShroudAbility . getInstance (  )  ) ; } public WallOfDenial  ( final WallOfDenial card )  { super ( card ) ; } @Override public WallOfDenial copy (  )  { return new WallOfDenial ( this ) ; } } 
public class Wargate extends CardImpl { public Wargate ( UUID ownerId )  { super ( ownerId, 129, "Wargate", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{G}{W}{U}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new WargateEffect (  )  ) ; } public Wargate ( final Wargate card )  { super ( card ) ; } @Override public Wargate copy (  )  { return new Wargate ( this ) ; } } class WargateEffect extends OneShotEffect { WargateEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "Search your library for a permanent card with converted mana cost X or less, put it onto the battlefield, then shuffle your library"; } WargateEffect ( final WargateEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } FilterPermanentCard filter = new FilterPermanentCard ( "permanent card with converted mana cost X or less" ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, source . getManaCostsToPay (  )  . getX (  )  + 1 )  ) ; TargetCardInLibrary target = new TargetCardInLibrary ( filter ) ; if  ( controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { Card card = controller . getLibrary (  )  . getCard ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { controller . moveCards ( card, Zone . BATTLEFIELD, source, game ) ; } } } controller . shuffleLibrary ( game ) ; return false; } @Override public WargateEffect copy (  )  { return new WargateEffect ( this ) ; } } 
public class WildfieldBorderpost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a basic land" ) ; static { filter . add ( new SupertypePredicate ( "Basic" )  ) ; } public WildfieldBorderpost  ( UUID ownerId )  { super ( ownerId, 80, "Wildfield Borderpost", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}{G}{W}" ) ; this . expansionSetCode = "ARB"; Ability ability = new AlternativeCostSourceAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new ReturnToHandChosenControlledPermanentCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTappedAbility (  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; this . addAbility ( new WhiteManaAbility (  )  ) ; } public WildfieldBorderpost  ( final WildfieldBorderpost card )  { super ( card ) ; } @Override public WildfieldBorderpost copy (  )  { return new WildfieldBorderpost ( this ) ; } } 
public class WingedCoatl extends CardImpl { public WingedCoatl  ( UUID ownerId )  { super ( ownerId, 105, "Winged Coatl", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{U}" ) ; this . expansionSetCode = "ARB"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( DeathtouchAbility . getInstance (  )  ) ; } public WingedCoatl  ( final WingedCoatl card )  { super ( card ) ; } @Override public WingedCoatl copy (  )  { return new WingedCoatl ( this ) ; } } 
public class ZealousPersecution extends CardImpl { public ZealousPersecution ( UUID ownerId )  { super ( ownerId, 85, "Zealous Persecution", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{W}{B}" ) ; this . expansionSetCode = "ARB"; this . getSpellAbility (  )  . addEffect ( new BoostControlledEffect ( 1, 1, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new BoostOpponentsEffect ( -1, -1, Duration . EndOfTurn )  ) ; } public ZealousPersecution ( final ZealousPersecution card )  { super ( card ) ; } @Override public ZealousPersecution copy (  )  { return new ZealousPersecution ( this ) ; } } 
public class AesthirGlider1 extends CardImpl { public AesthirGlider1 ( UUID ownerId )  { super ( ownerId, 156, "Aesthir Glider", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new CantBlockAbility (  )  ) ; } public AesthirGlider1 ( final AesthirGlider1 card )  { super ( card ) ; } @Override public AesthirGlider1 copy (  )  { return new AesthirGlider1 ( this ) ; } } 
public class AgentOfStromgald1 extends CardImpl { public AgentOfStromgald1 ( UUID ownerId )  { super ( ownerId, 94, "Agent of Stromgald", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlackMana ( 1 ) , new ManaCostsImpl ( "{R}" )  )  ) ; } public AgentOfStromgald1 ( final AgentOfStromgald1 card )  { super ( card ) ; } @Override public AgentOfStromgald1 copy (  )  { return new AgentOfStromgald1 ( this ) ; } } 
public class BalduvianHorde extends CardImpl { public BalduvianHorde ( UUID ownerId )  { super ( ownerId, 96, "Balduvian Horde", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Barbarian" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new SacrificeSourceUnlessPaysEffect ( new DiscardCardCost ( true )  )  )  ) ; } public BalduvianHorde ( final BalduvianHorde card )  { super ( card ) ; } @Override public BalduvianHorde copy (  )  { return new BalduvianHorde ( this ) ; } } 
public class BalduvianTradingPost extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an untapped Mountain" ) ; static { filter . add ( new SubtypePredicate ( "Mountain" )  ) ; filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public BalduvianTradingPost ( UUID ownerId )  { super ( ownerId, 182, "Balduvian Trading Post", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, new Mana ( 1, 0, 0, 0, 0, 0, 0, 1 ) , new TapSourceCost (  )  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetAttackingCreature (  )  ) ; this . addAbility ( ability ) ; } public BalduvianTradingPost ( final BalduvianTradingPost card )  { super ( card ) ; } @Override public BalduvianTradingPost copy (  )  { return new BalduvianTradingPost ( this ) ; } } 
public class BalduvianWarMakers1 extends CardImpl { public BalduvianWarMakers1 ( UUID ownerId )  { super ( ownerId, 97, "Balduvian War-Makers", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Barbarian" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new RampageAbility ( 1 )  ) ; } public BalduvianWarMakers1 ( final BalduvianWarMakers1 card )  { super ( card ) ; } @Override public BalduvianWarMakers1 copy (  )  { return new BalduvianWarMakers1 ( this ) ; } } 
public class Browse extends CardImpl { public Browse ( UUID ownerId )  { super ( ownerId, 38, "Browse", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{U}{U}" ) ; this . expansionSetCode = "ALL"; SimpleActivatedAbility ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BrowseEffect (  ) , new ManaCostsImpl ( "{2}{U}{U}" )  ) ; this . addAbility ( ability ) ; } public Browse ( final Browse card )  { super ( card ) ; } @Override public Browse copy (  )  { return new Browse ( this ) ; } } class BrowseEffect extends OneShotEffect { public BrowseEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Look at the top five cards of your library, put one of them into your hand, and exile the rest"; } public BrowseEffect ( final BrowseEffect effect )  { super ( effect ) ; } @Override public BrowseEffect copy (  )  { return new BrowseEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { Cards cards = new CardsImpl (  ) ; int cardsCount = Math . min ( 5, player . getLibrary (  )  . size (  )  ) ; for  ( int i = 0; i < cardsCount; i++ )  { Card card = player . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { cards . add ( card ) ; } } if  ( cards . size (  )  > 0 )  { player . lookAtCards ( "Browse", cards, game ) ; TargetCard target = new TargetCard ( Zone . LIBRARY, new FilterCard ( "card to put in your hand" )  ) ; if  ( player . choose ( Outcome . Benefit, cards, target, game )  )  { Card card = cards . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { card . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; cards . remove ( card ) ; } } for  ( Card card : cards . getCards ( game )  )  { card . moveToExile ( null, null, source . getSourceId (  ) , game ) ; } } return true; } return false; } } 
public class Burnout extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant spell" ) ; static { filter . add ( new CardTypePredicate ( CardType . INSTANT )  ) ; } public Burnout ( UUID ownerId )  { super ( ownerId, 101, "Burnout", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "ALL"; Effect effect = new BurnoutCounterTargetEffect (  ) ; effect . setText ( "Counter target instant spell if it's blue" ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addEffect ( new CreateDelayedTriggeredAbilityEffect (  new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , Duration . OneUse ) , false )  ) ; } public Burnout ( final Burnout card )  { super ( card ) ; } @Override public Burnout copy (  )  { return new Burnout ( this ) ; } } class BurnoutCounterTargetEffect extends OneShotEffect { public BurnoutCounterTargetEffect (  )  { super ( Outcome . Detriment ) ; } public BurnoutCounterTargetEffect ( final BurnoutCounterTargetEffect effect )  { super ( effect ) ; } @Override public BurnoutCounterTargetEffect copy (  )  { return new BurnoutCounterTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Spell targetSpell = game . getStack (  )  . getSpell ( source . getFirstTarget (  )  ) ; if ( targetSpell != null && targetSpell . getColor ( game )  . isBlue (  )  ) { game . getStack (  )  . counter ( source . getFirstTarget (  ) , source . getSourceId (  ) , game ) ; } return true; } } 
public class CarrierPigeons1 extends CardImpl { public CarrierPigeons1 ( UUID ownerId )  { super ( ownerId, 125, "Carrier Pigeons", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new CreateDelayedTriggeredAbilityEffect (  new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , Duration . OneUse ) , false )  )  ) ; } public CarrierPigeons1 ( final CarrierPigeons1 card )  { super ( card ) ; } @Override public CarrierPigeons1 copy (  )  { return new CarrierPigeons1 ( this ) ; } } 
public class Contagion extends CardImpl { public Contagion ( UUID ownerId )  { super ( ownerId, 4, "Contagion", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{B}{B}" ) ; this . expansionSetCode = "ALL"; FilterOwnedCard filter = new FilterOwnedCard ( "black card from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . BLACK )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class DiminishingReturns extends CardImpl { public DiminishingReturns ( UUID ownerId )  { super ( ownerId, 39, "Diminishing Returns", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{U}{U}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . addEffect ( new DiminishingReturnsEffect (  )  ) ; } public DiminishingReturns ( final DiminishingReturns card )  { super ( card ) ; } @Override public DiminishingReturns copy (  )  { return new DiminishingReturns ( this ) ; } } class DiminishingReturnsEffect extends OneShotEffect { public DiminishingReturnsEffect (  )  { super ( Outcome . Neutral ) ; staticText = "Each player shuffles his or her hand and graveyard into his or her library .  You exile the top ten cards of your library .  Then each player draws up to seven cards . "; } public DiminishingReturnsEffect ( final DiminishingReturnsEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { for  ( Card card: player . getHand (  )  . getCards ( game )  )  { card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true ) ; } for  ( Card card: player . getGraveyard (  )  . getCards ( game )  )  { card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, true ) ; } player . shuffleLibrary ( game ) ; } } for  ( Card card: controller . getLibrary (  )  . getTopCards ( game, 10 )  )  { controller . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . LIBRARY, true ) ; } for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { int cardsToDrawCount = player . getAmount ( 0, 7, "How many cards to draw  ( up to 7 ) ?", game ) ; player . drawCards ( cardsToDrawCount, game ) ; } } } return true; } @Override public DiminishingReturnsEffect copy (  )  { return new DiminishingReturnsEffect ( this ) ; } } 
public class EnslavedScout1 extends CardImpl { public EnslavedScout1 ( UUID ownerId )  { super ( ownerId, 104, "Enslaved Scout", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( new MountainwalkAbility ( false ) , Duration . EndOfTurn ) , new GenericManaCost ( 2 )  )  ) ; } public EnslavedScout1 ( final EnslavedScout1 card )  { super ( card ) ; } @Override public EnslavedScout1 copy (  )  { return new EnslavedScout1 ( this ) ; } } 
public class Exile extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonwhite attacking creature" ) ; static { filter . add ( new AttackingPredicate (  )  ) ; filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . WHITE )  )  ) ; } public Exile ( UUID ownerId )  { super ( ownerId, 129, "Exile", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{2}{W}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ExileEffect (  )  ) ; } public Exile ( final Exile card )  { super ( card ) ; } @Override public Exile copy (  )  { return new Exile ( this ) ; } } class ExileEffect extends OneShotEffect { public ExileEffect (  )  { super ( Outcome . GainLife ) ; staticText = "You gain life equal to its toughness"; } public ExileEffect ( final ExileEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent =  ( Permanent )  game . getLastKnownInformation ( source . getFirstTarget (  ) , Zone . BATTLEFIELD ) ; if  ( permanent != null )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . gainLife ( permanent . getToughness (  )  . getValue (  ) , game ) ; } } return false; } @Override public ExileEffect copy (  )  { return new ExileEffect ( this ) ; } } 
public class FeveredStrength1 extends CardImpl { public FeveredStrength1 ( UUID ownerId )  { super ( ownerId, 10, "Fevered Strength", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{B}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( 2, 0, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CreateDelayedTriggeredAbilityEffect (  new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , Duration . OneUse ) , false )  ) ; } public FeveredStrength1 ( final FeveredStrength1 card )  { super ( card ) ; } @Override public FeveredStrength1 copy (  )  { return new FeveredStrength1 ( this ) ; } } 
public class ForceOfWill extends CardImpl { public ForceOfWill ( UUID ownerId )  { super ( ownerId, 42, "Force of Will", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{U}{U}" ) ; this . expansionSetCode = "ALL"; FilterOwnedCard filter = new FilterOwnedCard ( "a blue card from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class GorillaBerserkers1 extends CardImpl { public GorillaBerserkers1 ( UUID ownerId )  { super ( ownerId, 75, "Gorilla Berserkers", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Ape" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new RampageAbility ( 2 )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeBlockedByOneEffect ( 3 )  )  ) ; } public GorillaBerserkers1 ( final GorillaBerserkers1 card )  { super ( card ) ; } @Override public GorillaBerserkers1 copy (  )  { return new GorillaBerserkers1 ( this ) ; } } 
public class GorillaShaman1 extends CardImpl { private final UUID originalId; public GorillaShaman1 ( UUID ownerId )  { super ( ownerId, 106, "Gorilla Shaman", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Ape" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new ManaCostsImpl ( "{X}{X}{1}" )  ) ; ability . addTarget ( new TargetPermanent ( new FilterArtifactPermanent ( "noncreature artifact with converted mana cost X" )  )  ) ; originalId = ability . getOriginalId (  ) ; this . addAbility ( ability ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability . getOriginalId (  )  . equals ( originalId )  )  { int xValue = ability . getManaCostsToPay (  )  . getX (  ) ; ability . getTargets (  )  . clear (  ) ; FilterArtifactPermanent filter = new FilterArtifactPermanent ( new StringBuilder ( "noncreature artifact with converted mana cost " )  . append ( xValue )  . toString (  )  ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . Equal, xValue )  ) ; filter . add ( Predicates . not ( new CardTypePredicate ( CardType . CREATURE )  )  ) ; Target target = new TargetPermanent ( filter ) ; ability . addTarget ( target ) ; } } public GorillaShaman1 ( final GorillaShaman1 card )  { super ( card ) ; this . originalId = card . originalId; } @Override public GorillaShaman1 copy (  )  { return new GorillaShaman1 ( this ) ; } } 
public class HeartOfYavimaya extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "a Forest" ) ; static { filter . add ( new SubtypePredicate ( "Forest" )  ) ; } public HeartOfYavimaya ( UUID ownerId )  { super ( ownerId, 183, "Heart of Yavimaya", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new GreenManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 1,1,Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public HeartOfYavimaya ( final HeartOfYavimaya card )  { super ( card ) ; } @Override public HeartOfYavimaya copy (  )  { return new HeartOfYavimaya ( this ) ; } } 
public class HelmOfObedience extends CardImpl { public HelmOfObedience ( UUID ownerId )  { super ( ownerId, 163, "Helm of Obedience", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "ALL"; VariableManaCost xCosts = new VariableManaCost (  ) ; xCosts . setMinX ( 1 ) ; SimpleActivatedAbility abilitiy = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new HelmOfObedienceEffect (  ) , xCosts ) ; abilitiy . addCost ( new TapSourceCost (  )  ) ; abilitiy . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( abilitiy ) ; } public HelmOfObedience ( final HelmOfObedience card )  { super ( card ) ; } @Override public HelmOfObedience copy (  )  { return new HelmOfObedience ( this ) ; } } class HelmOfObedienceEffect extends OneShotEffect { private static final ManacostVariableValue amount = new ManacostVariableValue (  ) ; public HelmOfObedienceEffect (  )  { super ( Outcome . Detriment ) ; staticText = "Target opponent puts cards from the top of his or her library into his or her graveyard until a creature card or X cards are put into that graveyard this way, whichever comes first .  If a creature card is put into that graveyard this way, sacrifice Helm of Obedience and put that card onto the battlefield under your control .  X can't be 0"; } public HelmOfObedienceEffect ( final HelmOfObedienceEffect effect )  { super ( effect ) ; } @Override public HelmOfObedienceEffect copy (  )  { return new HelmOfObedienceEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player targetOpponent = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( targetOpponent != null )  { int max = amount . calculate ( game, source, this ) ; if ( max != 0 ) { int numberOfCard = 0; while ( targetOpponent . getLibrary (  )  . size (  )  > 0 )  { Card card = targetOpponent . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null ) { if  ( targetOpponent . moveCards ( card, Zone . LIBRARY, Zone . GRAVEYARD, source, game )  )  { if ( card . getCardType (  )  . contains ( CardType . CREATURE )  ) { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { sourcePermanent . sacrifice ( source . getSourceId (  ) , game ) ; } if  ( game . getState (  )  . getZone ( card . getId (  )  )  . equals ( Zone . GRAVEYARD )  )  { card . putOntoBattlefield ( game, Zone . GRAVEYARD, source . getSourceId (  ) , source . getControllerId (  )  ) ; } break; } else{ numberOfCard++; if ( numberOfCard >= max ) { break; } } } } else{ return false; } } } return true; } return false; } } 
public class Inheritance extends CardImpl { public Inheritance ( UUID ownerId )  { super ( ownerId, 130, "Inheritance", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{W}" ) ; this . expansionSetCode = "ALL"; Ability ability = new DiesCreatureTriggeredAbility ( new DoIfCostPaid ( new DrawCardSourceControllerEffect ( 1 ) , new ManaCostsImpl ( "{3}" )  ) , false ) ; this . addAbility ( ability ) ; } public Inheritance ( final Inheritance card )  { super ( card ) ; } @Override public Inheritance copy (  )  { return new Inheritance ( this ) ; } } 
public class InsidiousBookworms1 extends CardImpl { public InsidiousBookworms1 ( UUID ownerId )  { super ( ownerId, 12, "Insidious Bookworms", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Worm" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new DiesTriggeredAbility ( new DoIfCostPaid ( new DiscardTargetEffect ( 1, true ) , new ManaCostsImpl ( "{1}{B}" )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public InsidiousBookworms1 ( final InsidiousBookworms1 card )  { super ( card ) ; } @Override public InsidiousBookworms1 copy (  )  { return new InsidiousBookworms1 ( this ) ; } } 
public class JuniperOrderAdvocate extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "green creatures you control" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public JuniperOrderAdvocate ( UUID ownerId )  { super ( ownerId, 132, "Juniper Order Advocate", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostAllEffect ( 1, 1, Duration . WhileOnBattlefield, filter, false ) , new InvertCondition ( new SourceTappedCondition (  )  ) , "As long as {this} is untapped, green creatures you control get +1/+1 . " )  )  ) ; } public JuniperOrderAdvocate ( final JuniperOrderAdvocate card )  { super ( card ) ; } @Override public JuniperOrderAdvocate copy (  )  { return new JuniperOrderAdvocate ( this ) ; } } 
public class Kaysa extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Green creatures" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; } public Kaysa ( UUID ownerId )  { super ( ownerId, 80, "Kaysa", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}{G}" ) ; this . expansionSetCode = "ALL"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1,1, Duration . WhileOnBattlefield, filter )  )  ) ; } public Kaysa ( final Kaysa card )  { super ( card ) ; } @Override public Kaysa copy (  )  { return new Kaysa ( this ) ; } } 
public class KeeperOfTresserhorn extends CardImpl { public KeeperOfTresserhorn ( UUID ownerId )  { super ( ownerId, 14, "Keeper of Tresserhorn", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Avatar" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; Effect effect = new AssignNoCombatDamageSourceEffect ( Duration . EndOfTurn ) ; effect . setText ( "it assigns no combat damage this turn" ) ; Ability ability = new AttacksAndIsNotBlockedTriggeredAbility ( effect, false, true ) ; effect = new LoseLifeTargetEffect ( 2 ) ; effect . setText ( "and defending player loses 2 life" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public KeeperOfTresserhorn ( final KeeperOfTresserhorn card )  { super ( card ) ; } @Override public KeeperOfTresserhorn copy (  )  { return new KeeperOfTresserhorn ( this ) ; } } 
public class LibraryOfLatNam extends CardImpl { public LibraryOfLatNam ( UUID ownerId )  { super ( ownerId, 47, "Library of Lat-Nam", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{4}{U}" ) ; this . expansionSetCode = "ALL"; this . getSpellAbility (  )  . getModes (  )  . setModeChooser ( TargetController . OPPONENT ) ; this . getSpellAbility (  )  . addEffect ( new CreateDelayedTriggeredAbilityEffect ( new AtTheBeginOfNextUpkeepDelayedTriggeredAbility ( new DrawCardSourceControllerEffect ( 3 )  ) , false )  ) ; Mode mode = new Mode (  ) ; Effect effect = new SearchLibraryPutInHandEffect ( new TargetCardInLibrary (  ) , false, true ) ; mode . getEffects (  )  . add ( effect ) ; this . getSpellAbility (  )  . addMode ( mode ) ; } public LibraryOfLatNam ( final LibraryOfLatNam card )  { super ( card ) ; } @Override public LibraryOfLatNam copy (  )  { return new LibraryOfLatNam ( this ) ; } } 
public class LimDulsHighGuard1 extends CardImpl { public LimDulsHighGuard1 ( UUID ownerId )  { super ( ownerId, 17, "Lim-Dul's High Guard", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Skeleton" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{1}{B}" )  )  ) ; } public LimDulsHighGuard1 ( final LimDulsHighGuard1 card )  { super ( card ) ; } @Override public LimDulsHighGuard1 copy (  )  { return new LimDulsHighGuard1 ( this ) ; } } 
public class LimDulsPaladin extends CardImpl { public LimDulsPaladin ( UUID ownerId )  { super ( ownerId, 191, "Lim-Dul's Paladin", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new LimDulsPaladinEffect (  ) , TargetController . YOU, false )  ) ; this . addAbility ( new BecomesBlockedTriggeredAbility ( new BoostSourceEffect ( 6, 3, Duration . EndOfTurn ) , false )  ) ; Effect effect = new AssignNoCombatDamageSourceEffect ( Duration . EndOfTurn ) ; effect . setText ( "it assigns no combat damage this turn" ) ; Ability ability = new AttacksAndIsNotBlockedTriggeredAbility ( effect, false, true ) ; effect = new LoseLifeTargetEffect ( 4 ) ; effect . setText ( "and defending player loses 4 life" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public LimDulsPaladin ( final LimDulsPaladin card )  { super ( card ) ; } @Override public LimDulsPaladin copy (  )  { return new LimDulsPaladin ( this ) ; } } class LimDulsPaladinEffect extends SacrificeSourceUnlessPaysEffect { public LimDulsPaladinEffect (  )  { super ( new DiscardTargetCost ( new TargetCardInHand (  )  )  ) ; staticText = "you may discard a card .  If you don't, sacrifice {this} and draw a card . "; } public LimDulsPaladinEffect ( final LimDulsPaladinEffect effect )  { super ( effect ) ; } @Override public LimDulsPaladinEffect copy (  )  { return new LimDulsPaladinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if ( permanent != null )  { super . apply ( game, source ) ; if ( game . getPermanent ( source . getSourceId (  )  )  == null )  { return new DrawCardSourceControllerEffect ( 1 )  . apply ( game, source ) ; } return true; } return false; } } 
public class LordOfTresserhorn extends CardImpl { public LordOfTresserhorn ( UUID ownerId )  { super ( ownerId, 193, "Lord of Tresserhorn", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}{B}{R}" ) ; this . expansionSetCode = "ALL"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 10 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new LoseLifeSourceControllerEffect ( 2 ) , false ) ; ability . addEffect ( new SacrificeControllerEffect ( new FilterControlledCreaturePermanent ( "creatures" ) , 2, "you" )  ) ; Effect effect = new DrawCardTargetEffect ( 2 ) ; effect . setText ( ", and target opponent draws two cards" ) ; ability . addEffect ( effect ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; } public LordOfTresserhorn ( final LordOfTresserhorn card )  { super ( card ) ; } @Override public LordOfTresserhorn copy (  )  { return new LordOfTresserhorn ( this ) ; } } 
public class MysticCompass extends CardImpl { public MysticCompass ( UUID ownerId )  { super ( ownerId, 166, "Mystic Compass", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "ALL"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesBasicLandTargetEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{1}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; Target target = new TargetLandPermanent (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public MysticCompass ( final MysticCompass card )  { super ( card ) ; } @Override public MysticCompass copy (  )  { return new MysticCompass ( this ) ; } } 
public class PhyrexianWarBeast1 extends CardImpl { public PhyrexianWarBeast1 ( UUID ownerId )  { super ( ownerId, 169, "Phyrexian War Beast", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{3}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability = new LeavesBattlefieldTriggeredAbility ( new SacrificeControllerEffect ( new FilterControlledLandPermanent (  ) , 1, "" ) , false ) ; Effect effect = new DamageControllerEffect ( 1 ) ; effect . setText ( "and {this} deals 1 damage to you" ) ; ability . addEffect ( effect ) ; ability . addTarget ( new TargetControlledPermanent ( new FilterControlledLandPermanent (  )  )  ) ; this . addAbility ( ability ) ; } public PhyrexianWarBeast1 ( final PhyrexianWarBeast1 card )  { super ( card ) ; } @Override public PhyrexianWarBeast1 copy (  )  { return new PhyrexianWarBeast1 ( this ) ; } } 
public class Pyrokinesis extends CardImpl { public Pyrokinesis ( UUID ownerId )  { super ( ownerId, 115, "Pyrokinesis", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{R}{R}" ) ; this . expansionSetCode = "ALL"; FilterOwnedCard filter = new FilterOwnedCard ( "a red card from your hand" ) ; filter . add ( new ColorPredicate ( ObjectColor . RED )  ) ; filter . add ( Predicates . not ( new CardIdPredicate ( this . getId (  )  )  )  ) ;  
public class RoyalHerbalist1 extends CardImpl { public RoyalHerbalist1 ( UUID ownerId )  { super ( ownerId, 147, "Royal Herbalist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 1 ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addCost ( new ExileFromTopOfLibraryCost ( 1 )  ) ; this . addAbility ( ability ) ; } public RoyalHerbalist1 ( final RoyalHerbalist1 card )  { super ( card ) ; } @Override public RoyalHerbalist1 copy (  )  { return new RoyalHerbalist1 ( this ) ; } } 
public class SchoolOfTheUnseen extends CardImpl { public SchoolOfTheUnseen ( UUID ownerId )  { super ( ownerId, 186, "School of the Unseen", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new AnyColorManaAbility ( new GenericManaCost ( 2 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public SchoolOfTheUnseen ( final SchoolOfTheUnseen card )  { super ( card ) ; } @Override public SchoolOfTheUnseen copy (  )  { return new SchoolOfTheUnseen ( this ) ; } } 
public class SeasonedTactician extends CardImpl { public SeasonedTactician ( UUID ownerId )  { super ( ownerId, 150, "Seasoned Tactician", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Advisor" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventNextDamageFromChosenSourceToYouEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}" )  ) ; ability . addCost ( new ExileFromTopOfLibraryCost ( 4 )  ) ; this . addAbility ( ability ) ; } public SeasonedTactician ( final SeasonedTactician card )  { super ( card ) ; } @Override public SeasonedTactician copy (  )  { return new SeasonedTactician ( this ) ; } } 
public class ShelteredValley extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent (  ) ; private static final FilterPermanent filterShelteredValley = new FilterPermanent ( "permanent named Sheltered Valley" ) ; static { filterShelteredValley . add ( new NamePredicate ( "Sheltered Valley" )  ) ; } public ShelteredValley ( UUID ownerId )  { super ( ownerId, 187, "Sheltered Valley", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; Effect effect = new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeAllCost ( filterShelteredValley )  ) ; effect . setText ( "If {this} would enter the battlefield, instead sacrifice each other permanent named {this} you control, then put {this} onto the battlefield . " ) ; Ability ability = new SimpleStaticAbility ( Zone . ALL, effect ) ; this . addAbility ( ability ) ; Condition controls = new PermanentsOnTheBattlefieldCondition ( filter, PermanentsOnTheBattlefieldCondition . CountType . FEWER_THAN, 4 ) ; effect = new ConditionalOneShotEffect ( new GainLifeEffect ( 1 ) , controls ) ; effect . setText ( "if you control three or fewer lands, you gain 1 life" ) ; ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, effect, TargetController . YOU, false ) ; this . addAbility ( ability ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; } public ShelteredValley ( final ShelteredValley card )  { super ( card ) ; } @Override public ShelteredValley copy (  )  { return new ShelteredValley ( this ) ; } } 
public class ShieldSphere extends CardImpl { public ShieldSphere ( UUID ownerId )  { super ( ownerId, 172, "Shield Sphere", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{0}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( new BlocksTriggeredAbility ( new AddCountersSourceEffect ( new BoostCounter ( 0, -1 )  ) , false )  ) ; } public ShieldSphere ( final ShieldSphere card )  { super ( card ) ; } @Override public ShieldSphere copy (  )  { return new ShieldSphere ( this ) ; } } 
public class SoldeviAdnate1 extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "black or artifact creature" ) ; static { filter . add ( Predicates . or ( new ColorPredicate ( ObjectColor . BLACK ) , new CardTypePredicate ( CardType . ARTIFACT )  )  ) ; } public SoldeviAdnate1 ( UUID ownerId )  { super ( ownerId, 25, "Soldevi Adnate", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new DynamicManaAbility ( Mana . BlackMana ( 1 ) , new SacrificeCostConvertedMana ( "creature" ) , new TapSourceCost (  ) , "add to your mana pool an amount of {B} equal to the sacrificed creature's converted mana cost" ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public SoldeviAdnate1 ( final SoldeviAdnate1 card )  { super ( card ) ; } @Override public SoldeviAdnate1 copy (  )  { return new SoldeviAdnate1 ( this ) ; } } 
public class SoldeviDigger extends CardImpl { public SoldeviDigger ( UUID ownerId )  { super ( ownerId, 174, "Soldevi Digger", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SoldeviDiggerEffect (  ) , new ManaCostsImpl ( "{2}" )  )  ) ; } public SoldeviDigger ( final SoldeviDigger card )  { super ( card ) ; } @Override public SoldeviDigger copy (  )  { return new SoldeviDigger ( this ) ; } } class SoldeviDiggerEffect extends OneShotEffect { public SoldeviDiggerEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "put the top card of your graveyard on the bottom of your library"; } public SoldeviDiggerEffect ( final SoldeviDiggerEffect effect )  { super ( effect ) ; } @Override public SoldeviDiggerEffect copy (  )  { return new SoldeviDiggerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Card topCard = null; for  ( Card card :controller . getGraveyard (  )  . getCards ( game )  )  { topCard = card; } if  ( topCard != null )  { return controller . moveCardToLibraryWithInfo ( topCard, source . getSourceId (  ) , game, Zone . GRAVEYARD, false, true ) ; } return true; } return false; } } 
public class SoldeviExcavations extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an untapped Island" ) ; static { filter . add ( new SubtypePredicate ( "Island" )  ) ; filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public SoldeviExcavations ( UUID ownerId )  { super ( ownerId, 188, "Soldevi Excavations", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, new Mana ( 0, 0, 1, 0, 0, 0, 0, 1 ) , new TapSourceCost (  )  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ScryEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public SoldeviExcavations ( final SoldeviExcavations card )  { super ( card ) ; } @Override public SoldeviExcavations copy (  )  { return new SoldeviExcavations ( this ) ; } } 
public class SoldeviSage1 extends CardImpl { public SoldeviSage1 ( UUID ownerId )  { super ( ownerId, 51, "Soldevi Sage", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new SoldeviSageEffect (  ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( 2, 2, new FilterControlledLandPermanent ( "two lands" ) , true )  )  ) ; this . addAbility ( ability ) ; } public SoldeviSage1 ( final SoldeviSage1 card )  { super ( card ) ; } @Override public SoldeviSage1 copy (  )  { return new SoldeviSage1 ( this ) ; } } class SoldeviSageEffect extends OneShotEffect { public SoldeviSageEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Draw three cards, then discard one of them"; } public SoldeviSageEffect ( final SoldeviSageEffect effect )  { super ( effect ) ; } @Override public SoldeviSageEffect copy (  )  { return new SoldeviSageEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { Cards initialHand = player . getHand (  )  . copy (  ) ; player . drawCards ( 3, game ) ; Cards drawnCards = new CardsImpl (  ) ; for  ( UUID cardId : player . getHand (  )  )  { if  ( !initialHand . contains ( cardId )  )  { drawnCards . add ( cardId ) ; } } if  ( drawnCards . size (  )  > 0 )  { TargetCard cardToDiscard = new TargetCard ( Zone . HAND, new FilterCard ( "card to discard" )  ) ; cardToDiscard . setNotTarget ( true ) ; if  ( player . choose ( Outcome . Discard, drawnCards, cardToDiscard, game )  )  { Card card = player . getHand (  )  . get ( cardToDiscard . getFirstTarget (  ) , game ) ; if  ( card != null )  { return player . discard ( card, source, game ) ; } } } return true; } return false; } } 
public class SoldierOfFortune extends CardImpl { public SoldierOfFortune ( UUID ownerId )  { super ( ownerId, 117, "Soldier of Fortune", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Mercenary" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ShuffleLibraryTargetEffect (  ) , new TapSourceCost (  )  ) ; ability . addManaCost ( new ManaCostsImpl ( "{R}" )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public SoldierOfFortune ( final SoldierOfFortune card )  { super ( card ) ; } @Override public SoldierOfFortune copy (  )  { return new SoldierOfFortune ( this ) ; } } 
public class SolGrail extends CardImpl { public SolGrail ( UUID ownerId )  { super ( ownerId, 173, "Sol Grail", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new EntersBattlefieldAbility ( new ChooseColorEffect ( Outcome . Neutral )  )  ) ; this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD, new SolGrailManaEffect (  ) , new TapSourceCost (  )  )  ) ; } public SolGrail ( final SolGrail card )  { super ( card ) ; } @Override public SolGrail copy (  )  { return new SolGrail ( this ) ; } } class SolGrailManaEffect extends ManaEffect { public SolGrailManaEffect (  )  { super (  ) ; staticText = "Add one mana of the chosen color to your mana pool"; } public SolGrailManaEffect ( final SolGrailManaEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . getManaPool (  )  . addMana ( getMana ( game, source ) , game, source ) ; } return true; } @Override public Mana getMana ( Game game, Ability source )  { ObjectColor color =  ( ObjectColor )  game . getState (  )  . getValue ( source . getSourceId (  )  + "_color" ) ; if  ( color != null )  { return new Mana ( ColoredManaSymbol . lookup ( color . toString (  )  . charAt ( 0 )  )  ) ; } else { return null; } } @Override public SolGrailManaEffect copy (  )  { return new SolGrailManaEffect ( this ) ; } } 
public class StormShaman1 extends CardImpl { public StormShaman1 ( UUID ownerId )  { super ( ownerId, 118, "Storm Shaman", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1,0, Duration . EndOfTurn ) , new ManaCostsImpl ( "{R}" )  )  ) ; } public StormShaman1 ( final StormShaman1 card )  { super ( card ) ; } @Override public StormShaman1 copy (  )  { return new StormShaman1 ( this ) ; } } 
public class SustainingSpirit extends CardImpl { public SustainingSpirit ( UUID ownerId )  { super ( ownerId, 151, "Sustaining Spirit", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Angel" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new CumulativeUpkeepAbility ( new ManaCostsImpl ( "{1}{W}" )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SustainingSpiritReplacementEffect (  )  )  ) ; } public SustainingSpirit ( final SustainingSpirit card )  { super ( card ) ; } @Override public SustainingSpirit copy (  )  { return new SustainingSpirit ( this ) ; } } class SustainingSpiritReplacementEffect extends ReplacementEffectImpl { public SustainingSpiritReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Damage that would reduce your life total to less than 1 reduces it to 1 instead"; } public SustainingSpiritReplacementEffect ( final SustainingSpiritReplacementEffect effect )  { super ( effect ) ; } @Override public SustainingSpiritReplacementEffect copy (  )  { return new SustainingSpiritReplacementEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DAMAGE_CAUSES_LIFE_LOSS; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null &&  ( controller . getLife (  )  > 0 )  && ( controller . getLife (  )  - event . getAmount (  )  )  < 1 && event . getPlayerId (  )  . equals ( controller . getId (  )  )   )  { event . setAmount ( controller . getLife (  )  - 1 ) ; } } return false; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { return false; } } 
public class SwampMosquito1 extends CardImpl { public SwampMosquito1 ( UUID ownerId )  { super ( ownerId, 30, "Swamp Mosquito", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Insect" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Effect effect = new AddPoisonCounterTargetEffect ( 1 ) ; effect . setText ( "defending player gets a poison counter" ) ; this . addAbility ( new AttacksAndIsNotBlockedTriggeredAbility ( effect, false, true )  ) ; } public SwampMosquito1 ( final SwampMosquito1 card )  { super ( card ) ; } @Override public SwampMosquito1 copy (  )  { return new SwampMosquito1 ( this ) ; } } 
public class Tornado extends CardImpl { public Tornado ( UUID ownerId )  { super ( ownerId, 86, "Tornado", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{4}{G}" ) ; this . expansionSetCode = "ALL"; this . addAbility ( new CumulativeUpkeepAbility ( new ManaCostsImpl ( "{G}" )  )  ) ; Ability ability = new LimitedTimesPerTurnActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new ManaCostsImpl ( "{2}{G}" )  ) ; DynamicValue lifeToPayAmount = new MultipliedValue ( new CountersCount ( CounterType . VELOCITY ) , 3 ) ; ability . addCost ( new PayLifeCost ( lifeToPayAmount, "3 life for each velocity counter on {source}" )  ) ; ability . addTarget ( new TargetPermanent (  )  ) ; Effect effect = new AddCountersSourceEffect ( CounterType . VELOCITY . createInstance (  )  ) ; effect . setText ( "and put a velocity counter on {source}" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public Tornado ( final Tornado card )  { super ( card ) ; } @Override public Tornado copy (  )  { return new Tornado ( this ) ; } } 
public class WhipVine1 extends CardImpl { public WhipVine1 ( UUID ownerId )  { super ( ownerId, 89, "Whip Vine", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "ALL"; this . subtype . add ( "Plant" ) ; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new TapSourceCost (  )  ) ; FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying blocked by {this}" ) ; filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; filter . add ( new BlockedByIdPredicate ( this . getId (  )  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filter )  ) ; ability . addEffect ( new DontUntapAsLongAsSourceTappedEffect (  )  ) ; this . addAbility ( ability ) ; } public WhipVine1 ( final WhipVine1 card )  { super ( card ) ; } @Override public WhipVine1 copy (  )  { return new WhipVine1 ( this ) ; } } 
public class VoidmageApprentice extends CardImpl { public VoidmageApprentice ( UUID ownerId )  { super ( ownerId, 4, "Voidmage Apprentice", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "DD3D"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{2}{U}{U}" )  )  ) ; Ability ability = new TurnedFaceUpSourceTriggeredAbility ( new CounterTargetEffect (  ) , false ) ; ability . addTarget ( new TargetSpell (  )  ) ; this . addAbility ( ability ) ; } public VoidmageApprentice ( final VoidmageApprentice card )  { super ( card ) ; } @Override public VoidmageApprentice copy (  )  { return new VoidmageApprentice ( this ) ; } } 
public class WallOfDeceit extends CardImpl { public WallOfDeceit ( UUID ownerId )  { super ( ownerId, 5, "Wall of Deceit", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "DD3D"; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; Effect effect = new BecomesFaceDownCreatureEffect ( Duration . Custom, BecomesFaceDownCreatureEffect . FaceDownType . MANIFESTED ) ; effect . setText ( "Turn Wall of Deceit face down .  <i> ( It becomes a 2/2 creature .  ) </i>" ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{3}" )  )  ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{U}" )  )  ) ; } public WallOfDeceit ( final WallOfDeceit card )  { super ( card ) ; } @Override public WallOfDeceit copy (  )  { return new WallOfDeceit ( this ) ; } } 
public class ArgivianArchaeologist extends CardImpl { private static final FilterArtifactCard filter = new FilterArtifactCard ( "artifact card from your graveyard" ) ; public ArgivianArchaeologist ( UUID ownerId )  { super ( ownerId, 94, "Argivian Archaeologist", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Artificer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ReturnToHandTargetEffect (  ) , new ManaCostsImpl ( "{W}{W}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; Target target = new TargetCardInYourGraveyard ( filter ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public ArgivianArchaeologist ( final ArgivianArchaeologist card )  { super ( card ) ; } @Override public ArgivianArchaeologist copy (  )  { return new ArgivianArchaeologist ( this ) ; } } 
public class ArgivianBlacksmith extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "artifact creature" ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public ArgivianBlacksmith ( UUID ownerId )  { super ( ownerId, 95, "Argivian Blacksmith", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Artificer" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 2 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public ArgivianBlacksmith ( final ArgivianBlacksmith card )  { super ( card ) ; } @Override public ArgivianBlacksmith copy (  )  { return new ArgivianBlacksmith ( this ) ; } } 
public class ArtifactBlast extends CardImpl { public ArtifactBlast ( UUID ownerId )  { super ( ownerId, 87, "Artifact Blast", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{R}" ) ; this . expansionSetCode = "ATQ"; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( new FilterArtifactSpell (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; } public ArtifactBlast ( final ArtifactBlast card )  { super ( card ) ; } @Override public ArtifactBlast copy (  )  { return new ArtifactBlast ( this ) ; } } 
public class AshnodsBattleGear extends CardImpl { public AshnodsBattleGear ( UUID ownerId )  { super ( ownerId, 4, "Ashnod's Battle Gear", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new BoostTargetEffect ( 2, -2, Duration . Custom ) , SourceTappedCondition . getInstance (  ) , "target creature you control gets +2/-2 for as long as {this} remains tapped" ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public AshnodsBattleGear ( final AshnodsBattleGear card )  { super ( card ) ; } @Override public AshnodsBattleGear copy (  )  { return new AshnodsBattleGear ( this ) ; } } 
public class CandelabraOfTawnos extends CardImpl { private final UUID originalId; public CandelabraOfTawnos ( UUID ownerId )  { super ( ownerId, 8, "Candelabra of Tawnos", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "ATQ"; Effect effect = new UntapTargetEffect (  ) ; effect . setText ( "untap X target lands" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{X}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; originalId = ability . getOriginalId (  ) ; this . addAbility ( ability ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability . getOriginalId (  )  . equals ( originalId )  ) { int xValue = ability . getManaCostsToPay (  )  . getX (  ) ; ability . getTargets (  )  . clear (  ) ; ability . addTarget ( new TargetLandPermanent ( xValue, xValue, new FilterLandPermanent (  ) , false )  ) ; } } public CandelabraOfTawnos ( final CandelabraOfTawnos card )  { super ( card ) ; this . originalId = card . originalId; } @Override public CandelabraOfTawnos copy (  )  { return new CandelabraOfTawnos ( this ) ; } } 
public class CitanulDruid extends CardImpl { private static final FilterArtifactSpell filter = new FilterArtifactSpell (  ) ; static { filter . add ( new ControllerPredicate ( TargetController . OPPONENT )  ) ; } public CitanulDruid ( UUID ownerId )  { super ( ownerId, 61, "Citanul Druid", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SpellCastOpponentTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , filter, false )  ) ; } public CitanulDruid ( final CitanulDruid card )  { super ( card ) ; } @Override public CitanulDruid copy (  )  { return new CitanulDruid ( this ) ; } } 
public class ClayStatue extends CardImpl { public ClayStatue ( UUID ownerId )  { super ( ownerId, 9, "Clay Statue", Rarity . COMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{2}" )  )  ) ; } public ClayStatue ( final ClayStatue card )  { super ( card ) ; } @Override public ClayStatue copy (  )  { return new ClayStatue ( this ) ; } } 
public class DampingField extends CardImpl { public DampingField ( UUID ownerId )  { super ( ownerId, 98, "Damping Field", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{W}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DampingFieldEffect (  )  )  ) ; } public DampingField ( final DampingField card )  { super ( card ) ; } @Override public DampingField copy (  )  { return new DampingField ( this ) ; } } class DampingFieldEffect extends RestrictionUntapNotMoreThanEffect { private static final FilterControlledPermanent filter = new FilterControlledArtifactPermanent ( "an artifact" ) ; public DampingFieldEffect (  )  { super ( Duration . WhileOnBattlefield, 1, filter ) ; staticText = "Players can't untap more than one artifact during their untap steps"; } public DampingFieldEffect ( final DampingFieldEffect effect )  { super ( effect ) ; } @Override public boolean applies ( Player player, Ability source, Game game )  { return true; } @Override public DampingFieldEffect copy (  )  { return new DampingFieldEffect ( this ) ; } } 
public class DrafnasRestoration extends CardImpl { public DrafnasRestoration ( UUID ownerId )  { super ( ownerId, 52, "Drafna's Restoration", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{U}" ) ; this . expansionSetCode = "ATQ"; this . getSpellAbility (  )  . addEffect ( new DrafnasRestorationEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addTarget ( new DrafnasRestorationTarget (  )  ) ; } public DrafnasRestoration ( final DrafnasRestoration card )  { super ( card ) ; } @Override public DrafnasRestoration copy (  )  { return new DrafnasRestoration ( this ) ; } } class DrafnasRestorationTarget extends TargetCardInGraveyard { DrafnasRestorationTarget (  )  { super ( 0, Integer . MAX_VALUE, new FilterArtifactCard ( "any number of artifact cards from that player's graveyard" )  ) ; } DrafnasRestorationTarget ( final DrafnasRestorationTarget target )  { super ( target ) ; } @Override public boolean canTarget ( UUID id, Ability source, Game game )  { Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; return targetPlayer != null && targetPlayer . getGraveyard (  )  . contains ( id )  && super . canTarget ( id, source, game ) ; } @Override public Set<UUID> possibleTargets ( UUID sourceId, UUID sourceControllerId, Game game )  { Set<UUID> possibleTargets = new HashSet<> (  ) ; MageObject object = game . getObject ( sourceId ) ; if  ( object != null && object instanceof StackObject )  { Player targetPlayer = game . getPlayer (  (  ( StackObject )  object )  . getStackAbility (  )  . getFirstTarget (  )  ) ; if  ( targetPlayer != null )  { for  ( Card card : targetPlayer . getGraveyard (  )  . getCards ( filter, sourceId, sourceControllerId, game )  )  { if  ( !game . replaceEvent ( GameEvent . getEvent ( GameEvent . EventType . TARGET, card . getId (  ) , sourceId, sourceControllerId )  )  )  { possibleTargets . add ( card . getId (  )  ) ; } } } } return possibleTargets; } @Override public DrafnasRestorationTarget copy (  )  { return new DrafnasRestorationTarget ( this ) ; } } class DrafnasRestorationEffect extends OneShotEffect { DrafnasRestorationEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "Return any number of target artifact cards from target player's graveyard to the top of his or her library in any order"; } DrafnasRestorationEffect ( final DrafnasRestorationEffect effect )  { super ( effect ) ; } @Override public DrafnasRestorationEffect copy (  )  { return new DrafnasRestorationEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Cards cards = new CardsImpl ( source . getTargets (  )  . get ( 1 )  . getTargets (  )  ) ; controller . putCardsOnTopOfLibrary ( cards, game, source, true ) ; return true; } return false; } } 
public class EnergyFlux extends CardImpl { public EnergyFlux ( UUID ownerId )  { super ( ownerId, 53, "Energy Flux", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{U}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility (  Zone . BATTLEFIELD, new GainAbilityAllEffect (  new BeginningOfUpkeepTriggeredAbility (  new SacrificeSourceUnlessPaysEffect ( new GenericManaCost ( 2 )  ) , TargetController . YOU, false ) , Duration . WhileOnBattlefield, new FilterArtifactPermanent (  ) , "All artifacts have \"At the beginning of your upkeep, sacrifice this artifact unless you pay {2} . \"" )  )  ) ; } public EnergyFlux ( final EnergyFlux card )  { super ( card ) ; } @Override public EnergyFlux copy (  )  { return new EnergyFlux ( this ) ; } } 
public class GateToPhyrexia extends CardImpl { public GateToPhyrexia ( UUID ownerId )  { super ( ownerId, 46, "Gate to Phyrexia", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}{B}" ) ; this . expansionSetCode = "ATQ"; Ability ability = new GateToPhyrexiaAbility ( new DestroyTargetEffect (  ) , new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; ability . addTarget ( new TargetArtifactPermanent (  )  ) ; this . addAbility ( ability ) ; } public GateToPhyrexia ( final GateToPhyrexia card )  { super ( card ) ; } @Override public GateToPhyrexia copy (  )  { return new GateToPhyrexia ( this ) ; } } class GateToPhyrexiaAbility extends LimitedTimesPerTurnActivatedAbility { public GateToPhyrexiaAbility ( Effect effect, Cost cost )  { super ( Zone . BATTLEFIELD, effect, cost ) ; } public GateToPhyrexiaAbility ( final GateToPhyrexiaAbility ability )  { super ( ability ) ; } @Override public GateToPhyrexiaAbility copy (  )  { return new GateToPhyrexiaAbility ( this ) ; } @Override public boolean canActivate ( UUID playerId, Game game )  { if  ( !game . getActivePlayerId (  )  . equals ( controllerId )  || !PhaseStep . UPKEEP . equals ( game . getStep (  )  . getType (  )  )  )  { return false; } return super . canActivate ( playerId, game ) ; } @Override public String getRule (  )  { return "Sacrifice a creature: Destroy target artifact .  Activate this ability only during your upkeep and only once each turn . "; } } 
public class IvoryTower extends CardImpl { public IvoryTower ( UUID ownerId )  { super ( ownerId, 18, "Ivory Tower", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new IvoryTowerEffect (  ) , TargetController . YOU, false )  ) ; } public IvoryTower ( final IvoryTower card )  { super ( card ) ; } @Override public IvoryTower copy (  )  { return new IvoryTower ( this ) ; } } class IvoryTowerEffect extends OneShotEffect { public IvoryTowerEffect (  )  { super ( Outcome . GainLife ) ; this . staticText = "you gain X life, where X is the number of cards in your hand minus 4 . "; } public IvoryTowerEffect ( IvoryTowerEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if ( player != null )  { int amount = player . getHand (  )  . size (  )  - 4; if ( amount > 0 )  { player . gainLife ( amount, game ) ; } return true; } return false; } @Override public IvoryTowerEffect copy (  )  { return new IvoryTowerEffect ( this ) ; } } 
public class Mightstone extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "attacking creatures" ) ; static { filter . add ( new AttackingPredicate (  )  ) ; } public Mightstone ( UUID ownerId )  { super ( ownerId, 20, "Mightstone", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostAllEffect (  1, 0, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public Mightstone ( final Mightstone card )  { super ( card ) ; } @Override public Mightstone copy (  )  { return new Mightstone ( this ) ; } } 
public class OrcishMechanics extends CardImpl { public OrcishMechanics ( UUID ownerId )  { super ( ownerId, 92, "Orcish Mechanics", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Orc" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 2 ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( new FilterControlledArtifactPermanent ( "an artifact" )  )  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public OrcishMechanics ( final OrcishMechanics card )  { super ( card ) ; } @Override public OrcishMechanics copy (  )  { return new OrcishMechanics ( this ) ; } } 
public class PhyrexianGremlins extends CardImpl { public PhyrexianGremlins ( UUID ownerId )  { super ( ownerId, 48, "Phyrexian Gremlins", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Gremlin" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetArtifactPermanent (  )  ) ; ability . addEffect ( new DontUntapAsLongAsSourceTappedEffect (  )  ) ; this . addAbility ( ability ) ; } public PhyrexianGremlins ( final PhyrexianGremlins card )  { super ( card ) ; } @Override public PhyrexianGremlins copy (  )  { return new PhyrexianGremlins ( this ) ; } } 
public class PowerArtifact extends CardImpl { public PowerArtifact ( UUID ownerId )  { super ( ownerId, 55, "Power Artifact", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{U}{U}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetArtifactPermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Benefit )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new PowerArtifactCostModificationEffect (  )  )  ) ; } public PowerArtifact ( final PowerArtifact card )  { super ( card ) ; } @Override public PowerArtifact copy (  )  { return new PowerArtifact ( this ) ; } } class PowerArtifactCostModificationEffect extends CostModificationEffectImpl { PowerArtifactCostModificationEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "The activation cost of target artifact is reduced by {2} .  If this would reduce target artifact's activation cost below {1}, target artifact's activation cost becomes {1} .  Power artifact has no effect on artifacts that have no activation cost or whose activation cost is {0} . "; } PowerArtifactCostModificationEffect ( PowerArtifactCostModificationEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { Player controller = game . getPlayer ( abilityToModify . getControllerId (  )  ) ; if  ( controller != null )  { Mana mana = abilityToModify . getManaCostsToPay (  )  . getMana (  ) ; int reduce = mana . getGeneric (  ) ; if  ( reduce > 0 && mana . count (  )  == mana . getGeneric (  )  )  { reduce--; } if  ( reduce > 2 )  { reduce = 2; } CardUtil . reduceCost ( abilityToModify, reduce ) ; } return true; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { Permanent artifact = game . getPermanent ( abilityToModify . getSourceId (  )  ) ; if  ( artifact != null && artifact . getAttachments (  )  . contains ( source . getSourceId (  )  )  )  { if  ( abilityToModify . getAbilityType (  )  . equals ( AbilityType . ACTIVATED )  ||  ( abilityToModify . getAbilityType (  )  . equals ( AbilityType . MANA )  &&  ( abilityToModify instanceof ActivatedAbility )  )  )  { return true; } } return false; } @Override public PowerArtifactCostModificationEffect copy (  )  { return new PowerArtifactCostModificationEffect ( this ) ; } } 
public class SageOfLatNam extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "an Artifact" ) ; static { filter . add ( new CardTypePredicate ( CardType . ARTIFACT )  ) ; } public SageOfLatNam ( UUID ownerId )  { super ( ownerId, 57, "Sage of Lat-Nam", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "ATQ"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Artificer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public SageOfLatNam ( final SageOfLatNam card )  { super ( card ) ; } @Override public SageOfLatNam copy (  )  { return new SageOfLatNam ( this ) ; } } 
public class TransmuteArtifact extends CardImpl { public TransmuteArtifact ( UUID ownerId )  { super ( ownerId, 58, "Transmute Artifact", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{U}{U}" ) ; this . expansionSetCode = "ATQ"; this . getSpellAbility (  )  . addEffect ( new TransmuteArtifactEffect (  )  ) ; } public TransmuteArtifact ( final TransmuteArtifact card )  { super ( card ) ; } @Override public TransmuteArtifact copy (  )  { return new TransmuteArtifact ( this ) ; } } class TransmuteArtifactEffect extends SearchEffect { public TransmuteArtifactEffect (  )  { super ( new TargetCardInLibrary ( new FilterArtifactCard (  )  ) , Outcome . PutCardInPlay ) ; staticText = "Sacrifice an artifact .  If you do, search your library for an artifact card .  If that card's converted mana cost is less than or equal to the sacrificed artifact's converted mana cost, put it onto the battlefield .  If it's greater, you may pay {X}, where X is the difference .  If you do, put it onto the battlefield .  If you don't, put it into its owner's graveyard .  Then shuffle your library"; } public TransmuteArtifactEffect ( final TransmuteArtifactEffect effect )  { super ( effect ) ; } @Override public TransmuteArtifactEffect copy (  )  { return new TransmuteArtifactEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } int convertedManaCost = 0; boolean sacrifice = false; TargetControlledPermanent targetArtifact = new TargetControlledPermanent ( new FilterControlledArtifactPermanent (  )  ) ; if  ( controller . chooseTarget ( Outcome . Sacrifice, targetArtifact, source, game )  )  { Permanent permanent = game . getPermanent ( targetArtifact . getFirstTarget (  )  ) ; if  ( permanent != null )  { convertedManaCost = permanent . getManaCost (  )  . convertedManaCost (  ) ; sacrifice = permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } else { return true; } if  ( sacrifice && controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { for  ( UUID cardId : target . getTargets (  )  )  { Card card = controller . getLibrary (  )  . getCard ( cardId, game ) ; if  ( card != null )  { if  ( card . getManaCost (  )  . convertedManaCost (  )  <= convertedManaCost )  { controller . moveCards ( card, Zone . BATTLEFIELD, source, game ) ; } else { GenericManaCost cost = new GenericManaCost ( card . getManaCost (  )  . convertedManaCost (  )  - convertedManaCost ) ; if  ( cost . pay ( source, game, source . getSourceId (  ) , source . getControllerId (  ) , false )  )  { controller . moveCards ( card, Zone . BATTLEFIELD, source, game ) ; } else { controller . moveCards ( card, Zone . GRAVEYARD, source, game ) ; } } } } } controller . shuffleLibrary ( game ) ; return true; } controller . shuffleLibrary ( game ) ; return false; } } 
public class Weakstone extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "attacking creatures" ) ; static { filter . add ( new AttackingPredicate (  )  ) ; } public Weakstone ( UUID ownerId )  { super ( ownerId, 43, "Weakstone", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "ATQ"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostAllEffect (  -1, 0, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public Weakstone ( final Weakstone card )  { super ( card ) ; } @Override public Weakstone copy (  )  { return new Weakstone ( this ) ; } } 
public class AEtherMutation extends CardImpl { public AEtherMutation ( UUID ownerId )  { super ( ownerId, 91, "AEther Mutation", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{G}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new SaprolingToken (  ) , new TargetConvertedManaCost (  )  )  ) ; } public AEtherMutation ( final AEtherMutation card )  { super ( card ) ; } @Override public AEtherMutation copy (  )  { return new AEtherMutation ( this ) ; } } 
public class AnaDisciple extends CardImpl { public AnaDisciple ( UUID ownerId )  { super ( ownerId, 73, "Ana Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilityTargetEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . U )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . B )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( secondAbility ) ; } public AnaDisciple ( final AnaDisciple card )  { super ( card ) ; } @Override public AnaDisciple copy (  )  { return new AnaDisciple ( this ) ; } } 
public class Anavolver extends CardImpl { public Anavolver ( UUID ownerId )  { super ( ownerId, 75, "Anavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{U}" ) ; kickerAbility . addKickerCost ( "{B}" ) ; this . addAbility ( kickerAbility ) ; EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) ,false ) , new KickedCostCondition ( "{1}{U}" ) , "If {this} was kicked with its {1}{U} kicker, it enters the battlefield with two +1/+1 counters on it and with flying . ", "{this} enters the battlefield with two +1/+1 counters on it and with flying" ) ;  (  ( EntersBattlefieldEffect ) ability1 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability1 ) ; EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 ) ,false ) , new KickedCostCondition ( "{B}" ) , "If {this} was kicked with its {B} kicker, it enters the battlefield with a +1/+1 counter on it and with \"Pay 3 life: Regenerate Anavolver . \"", "{this} enters the battlefield with a +1/+1 counter on it and with \"Pay 3 life: Regenerate Anavolver . \"" ) ;  (  ( EntersBattlefieldEffect ) ability2 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new PayLifeCost ( 3 )  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability2 ) ; } public Anavolver ( final Anavolver card )  { super ( card ) ; } @Override public Anavolver copy (  )  { return new Anavolver ( this ) ; } } 
public class AngelfireCrusader extends CardImpl { public AngelfireCrusader ( UUID ownerId )  { super ( ownerId, 1, "Angelfire Crusader", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  )  ) ; } public AngelfireCrusader ( final AngelfireCrusader card )  { super ( card ) ; } @Override public AngelfireCrusader copy (  )  { return new AngelfireCrusader ( this ) ; } } 
public class BattlefieldForge extends CardImpl { public BattlefieldForge ( UUID ownerId )  { super ( ownerId, 139, "Battlefield Forge", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability redManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . RedMana ( 1 ) , new TapSourceCost (  )  ) ; redManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( redManaAbility ) ; Ability whiteManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . WhiteMana ( 1 ) , new TapSourceCost (  )  ) ; whiteManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( whiteManaAbility ) ; } public BattlefieldForge ( final BattlefieldForge card )  { super ( card ) ; } @Override public BattlefieldForge copy (  )  { return new BattlefieldForge ( this ) ; } } 
public class BloodfireColossus extends CardImpl { public BloodfireColossus ( UUID ownerId )  { super ( ownerId, 55, "Bloodfire Colossus", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{R}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Giant" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageEverythingEffect ( 6 ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BloodfireColossus ( final BloodfireColossus card )  { super ( card ) ; } @Override public BloodfireColossus copy (  )  { return new BloodfireColossus ( this ) ; } } 
public class BloodfireDwarf extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature without flying" ) ; static { filter . add ( Predicates . not ( new AbilityPredicate ( FlyingAbility . class )  )  ) ; } public BloodfireDwarf ( UUID ownerId )  { super ( ownerId, 56, "Bloodfire Dwarf", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Dwarf" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageAllEffect ( 1, filter ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BloodfireDwarf ( final BloodfireDwarf card )  { super ( card ) ; } @Override public BloodfireDwarf copy (  )  { return new BloodfireDwarf ( this ) ; } } 
public class BloodfireKavu extends CardImpl { public BloodfireKavu ( UUID ownerId )  { super ( ownerId, 58, "Bloodfire Kavu", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageAllEffect ( 2, new FilterCreaturePermanent (  )  ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public BloodfireKavu ( final BloodfireKavu card )  { super ( card ) ; } @Override public BloodfireKavu copy (  )  { return new BloodfireKavu ( this ) ; } } 
public class BogGnarr extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "a black spell" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . BLACK )  ) ; } public BogGnarr ( UUID ownerId )  { super ( ownerId, 76, "Bog Gnarr", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SpellCastAllTriggeredAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , filter, false )  ) ; } public BogGnarr ( final BogGnarr card )  { super ( card ) ; } @Override public BogGnarr copy (  )  { return new BogGnarr ( this ) ; } } 
public class BrassHerald extends CardImpl { public BrassHerald ( UUID ownerId )  { super ( ownerId, 133, "Brass Herald", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{6}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new ChooseCreatureTypeEffect ( Outcome . BoostCreature )  )  ) ; FilterCard filter = new FilterCard ( "creature cards of the chosen type" ) ; filter . add ( new ChosenSubtypePredicate ( this . getId (  )  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; FilterCreaturePermanent filter2 = new FilterCreaturePermanent ( "creatures of the chosen type" ) ; filter2 . add ( new ChosenSubtypePredicate ( this . getId (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostAllEffect ( 1, 1, Duration . WhileOnBattlefield, filter2, false )  )  ) ; } public BrassHerald ( final BrassHerald card )  { super ( card ) ; } @Override public BrassHerald copy (  )  { return new BrassHerald ( this ) ; } } 
public class CavesOfKoilos extends CardImpl { public CavesOfKoilos ( UUID ownerId )  { super ( ownerId, 140, "Caves of Koilos", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability whiteManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . WhiteMana ( 1 ) , new TapSourceCost (  )  ) ; whiteManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( whiteManaAbility ) ; Ability blackManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlackMana ( 1 ) , new TapSourceCost (  )  ) ; blackManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blackManaAbility ) ; } public CavesOfKoilos ( final CavesOfKoilos card )  { super ( card ) ; } @Override public CavesOfKoilos copy (  )  { return new CavesOfKoilos ( this ) ; } } 
public class CetaDisciple extends CardImpl { public CetaDisciple ( UUID ownerId )  { super ( ownerId, 19, "Ceta Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new AnyColorManaAbility ( new ColoredManaCost ( ColoredManaSymbol . G )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( secondAbility ) ; } public CetaDisciple ( final CetaDisciple card )  { super ( card ) ; } @Override public CetaDisciple copy (  )  { return new CetaDisciple ( this ) ; } } 
public class Cetavolver extends CardImpl { public Cetavolver ( UUID ownerId )  { super ( ownerId, 21, "Cetavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{R}" ) ; kickerAbility . addKickerCost ( "{G}" ) ; this . addAbility ( kickerAbility ) ; EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) ,false ) , new KickedCostCondition ( "{1}{R}" ) , "If Cetavolver was kicked with its {1}{R} kicker, it enters the battlefield with two +1/+1 counters on it and with first strike . ", "{this} enters the battlefield with two +1/+1 counters on it and with first strike" ) ;  (  ( EntersBattlefieldEffect ) ability1 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( FirstStrikeAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability1 ) ; EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 ) ,false ) , new KickedCostCondition ( "{G}" ) , "If Cetavolver was kicked with its {G} kicker, it enters the battlefield with a +1/+1 counter on it and with trample . ", "{this} enters the battlefield with a +1/+1 counter on it and with trample" ) ;  (  ( EntersBattlefieldEffect ) ability2 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( TrampleAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability2 ) ; } public Cetavolver ( final Cetavolver card )  { super ( card ) ; } @Override public Cetavolver copy (  )  { return new Cetavolver ( this ) ; } } 
public class CoastalDrake extends CardImpl { public CoastalDrake ( UUID ownerId )  { super ( ownerId, 22, "Coastal Drake", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ReturnToHandTargetEffect ( true ) , new ManaCostsImpl ( "{1}{U}" )  ) ; ability . addTarget ( new TargetCreaturePermanent ( new FilterCreaturePermanent ( "Kavu", "Kavu" )  )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public CoastalDrake ( final CoastalDrake card )  { super ( card ) ; } @Override public CoastalDrake copy (  )  { return new CoastalDrake ( this ) ; } } 
public class ConsumeStrength extends CardImpl { public ConsumeStrength ( UUID ownerId )  { super ( ownerId, 93, "Consume Strength", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{B}{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new ConsumeStrengthEffect (  )  ) ; FilterCreaturePermanent filter1 = new FilterCreaturePermanent ( "creature to get +2/+2" ) ; TargetCreaturePermanent target1 = new TargetCreaturePermanent ( filter1 ) ; target1 . setTargetTag ( 1 ) ; this . getSpellAbility (  )  . addTarget ( target1 ) ; FilterCreaturePermanent filter2 = new FilterCreaturePermanent ( "another creature to get -2/-2" ) ; filter2 . add ( new AnotherTargetPredicate ( 2 )  ) ; TargetCreaturePermanent target2 = new TargetCreaturePermanent ( filter2 ) ; target2 . setTargetTag ( 2 ) ; this . getSpellAbility (  )  . addTarget ( target2 ) ; } public ConsumeStrength ( final ConsumeStrength card )  { super ( card ) ; } @Override public ConsumeStrength copy (  )  { return new ConsumeStrength ( this ) ; } } class ConsumeStrengthEffect extends ContinuousEffectImpl { public ConsumeStrengthEffect (  )  { super ( Duration . EndOfTurn, Layer . PTChangingEffects_7, SubLayer . ModifyPT_7c, Outcome . BoostCreature ) ; this . staticText = "Target creature gets +2/+2 until end of turn .  Another target creature gets -2/-2 until end of turn"; } public ConsumeStrengthEffect ( final ConsumeStrengthEffect effect )  { super ( effect ) ; } @Override public ConsumeStrengthEffect copy (  )  { return new ConsumeStrengthEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . addPower ( 2 ) ; permanent . addToughness ( 2 ) ; } permanent = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { permanent . addPower ( -2 ) ; permanent . addToughness ( -2 ) ; } return true; } } 
public class DeathGrasp extends CardImpl { public DeathGrasp  ( UUID ownerId )  { super ( ownerId, 95, "Death Grasp", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{W}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public DeathGrasp  ( final DeathGrasp card )  { super ( card ) ; } @Override public DeathGrasp copy (  )  { return new DeathGrasp ( this ) ; } } 
public class DeathMutation extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonblack creature" ) ; static { filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public DeathMutation ( UUID ownerId )  { super ( ownerId, 96, "Death Mutation", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{6}{B}{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new SaprolingToken (  ) , new TargetConvertedManaCost (  )  )  ) ; } public DeathMutation ( final DeathMutation card )  { super ( card ) ; } @Override public DeathMutation copy (  )  { return new DeathMutation ( this ) ; } } 
public class DegaDisciple extends CardImpl { public DegaDisciple ( UUID ownerId )  { super ( ownerId, 4, "Dega Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . B )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 2, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( secondAbility ) ; } public DegaDisciple ( final DegaDisciple card )  { super ( card ) ; } @Override public DegaDisciple copy (  )  { return new DegaDisciple ( this ) ; } } 
public class Degavolver extends CardImpl { public Degavolver ( UUID ownerId )  { super ( ownerId, 6, "Degavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{B}" ) ; kickerAbility . addKickerCost ( "{R}" ) ; this . addAbility ( kickerAbility ) ; EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) ,false ) , new KickedCostCondition ( "{1}{B}" ) , "If Degavolver was kicked with its {1}{B} kicker, it enters the battlefield with two +1/+1 counters on it and with \"Pay 3 life: Regenerate Degavolver . \"", "{this} enters the battlefield with two +1/+1 counters on it and with \"Pay 3 life: Regenerate Degavolver . \"" ) ;  (  ( EntersBattlefieldEffect ) ability1 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new PayLifeCost ( 3 )  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability1 ) ; EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility (  new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 ) ,false ) , new KickedCostCondition ( "{R}" ) , "If Degavolver was kicked with its {R} kicker, it enters the battlefield with a +1/+1 counter on it and with first strike . ", "{this} enters the battlefield with a +1/+1 counter on it and with first strike" ) ;  (  ( EntersBattlefieldEffect ) ability2 . getEffects (  )  . get ( 0 )  )  . addEffect ( new GainAbilitySourceEffect ( FirstStrikeAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability2 ) ; } public Degavolver ( final Degavolver card )  { super ( card ) ; } @Override public Degavolver copy (  )  { return new Degavolver ( this ) ; } } 
public class DesolationAngel extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent ( "lands" ) ; private static final FilterLandPermanent filter2 = new FilterLandPermanent ( "lands you control" ) ; static { filter2 . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DesolationAngel ( UUID ownerId )  { super ( ownerId, 38, "Desolation Angel", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new KickerAbility ( "{W}{W}" )  ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ConditionalOneShotEffect ( new DestroyAllEffect ( filter ) , new DestroyAllEffect ( filter2 ) , KickedCondition . getInstance (  ) , "destroy all lands you control .  If it was kicked, destroy all lands instead . " )  )  ) ; } public DesolationAngel ( final DesolationAngel card )  { super ( card ) ; } @Override public DesolationAngel copy (  )  { return new DesolationAngel ( this ) ; } } 
public class DesolationGiant extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "other creatures" ) ; private static final FilterCreaturePermanent filter2 = new FilterCreaturePermanent ( "other creatures you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter2 . add ( new AnotherPredicate (  )  ) ; filter2 . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DesolationGiant ( UUID ownerId )  { super ( ownerId, 59, "Desolation Giant", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Giant" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new KickerAbility ( "{W}{W}" )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ConditionalOneShotEffect ( new DestroyAllEffect ( filter ) , new DestroyAllEffect ( filter2 ) , KickedCondition . getInstance (  ) , "destroy all other creatures you control .  If it was kicked, destroy all other creatures instead . " )  )  ) ; } public DesolationGiant ( final DesolationGiant card )  { super ( card ) ; } @Override public DesolationGiant copy (  )  { return new DesolationGiant ( this ) ; } } 
public class DiversionaryTactics extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creatures you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public DiversionaryTactics ( UUID ownerId )  { super ( ownerId, 7, "Diversionary Tactics", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new TapTargetCost ( new TargetControlledCreaturePermanent ( 2, 2, filter, false )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public DiversionaryTactics ( final DiversionaryTactics card )  { super ( card ) ; } @Override public DiversionaryTactics copy (  )  { return new DiversionaryTactics ( this ) ; } } 
public class DivineLight extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creatures you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DivineLight ( UUID ownerId )  { super ( ownerId, 8, "Divine Light", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{W}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new PreventAllDamageToAllEffect ( Duration . EndOfTurn, filter )  ) ; } public DivineLight ( final DivineLight card )  { super ( card ) ; } @Override public DivineLight copy (  )  { return new DivineLight ( this ) ; } } 
public class Dodecapod extends CardImpl { public Dodecapod ( UUID ownerId )  { super ( ownerId, 134, "Dodecapod", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{4}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Golem" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . HAND, new DodecapodEffect (  )  )  ) ; } public Dodecapod ( final Dodecapod card )  { super ( card ) ; } @Override public Dodecapod copy (  )  { return new Dodecapod ( this ) ; } } class DodecapodEffect extends DiscardOntoBattlefieldEffect { public DodecapodEffect (  )  { super (  ) ; staticText = "If a spell or ability an opponent controls causes you to discard {this}, put it onto the battlefield with two +1/+1 counters on it instead of putting it into your graveyard"; } public DodecapodEffect ( final DodecapodEffect effect )  { super ( effect ) ; } @Override public DodecapodEffect copy (  )  { return new DodecapodEffect ( this ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { if ( super . replaceEvent ( event, source, game )  )  { new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  )  . apply ( game, source ) ; return true; } return false; } } 
public class DragonArch extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "a multicolored creature card" ) ; static { filter . add ( new MulticoloredPredicate (  )  ) ; } public DragonArch ( UUID ownerId )  { super ( ownerId, 135, "Dragon Arch", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{5}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PutPermanentOnBattlefieldEffect ( filter ) , new ManaCostsImpl ( "{2}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public DragonArch ( final DragonArch card )  { super ( card ) ; } @Override public DragonArch copy (  )  { return new DragonArch ( this ) ; } } 
public class DwarvenLandslide extends CardImpl { public DwarvenLandslide ( UUID ownerId )  { super ( ownerId, 60, "Dwarven Landslide", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{R}" ) ; this . expansionSetCode = "APC"; Costs<Cost> kickerCosts = new CostsImpl<> (  ) ; kickerCosts . add ( new ManaCostsImpl<> ( "{2}{R}" )  ) ; kickerCosts . add ( new SacrificeTargetCost ( new TargetControlledPermanent ( new FilterControlledLandPermanent ( "a land" )  )  )  ) ; this . addAbility ( new KickerAbility ( kickerCosts )  ) ; getSpellAbility (  )  . addEffect ( new DestroyTargetEffect ( "Destroy target land .  If {this} was kicked, destroy another target land" )  ) ; getSpellAbility (  )  . addTarget ( new TargetLandPermanent (  )  ) ; } public DwarvenLandslide ( final DwarvenLandslide card )  { super ( card ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SpellAbility )  { if  ( KickedCondition . getInstance (  )  . apply ( game, ability )  )  { getSpellAbility (  )  . addTarget ( new TargetLandPermanent ( new FilterLandPermanent ( "land  ( Kicker ) " )  )  ) ; } } } @Override public DwarvenLandslide copy (  )  { return new DwarvenLandslide ( this ) ; } } 
public class DwarvenPatrol extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "nonred spell" ) ; static { filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . RED )  )  ) ; } public DwarvenPatrol ( UUID ownerId )  { super ( ownerId, 61, "Dwarven Patrol", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Dwarf" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DontUntapInControllersUntapStepSourceEffect (  )  )  ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new UntapSourceEffect (  ) , filter, false )  ) ; } public DwarvenPatrol ( final DwarvenPatrol card )  { super ( card ) ; } @Override public DwarvenPatrol copy (  )  { return new DwarvenPatrol ( this ) ; } } 
public class EbonyTreefolk extends CardImpl { public EbonyTreefolk ( UUID ownerId )  { super ( ownerId, 97, "Ebony Treefolk", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Treefolk" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , new ManaCostsImpl ( "{B}{G}" )  )  ) ; } public EbonyTreefolk ( final EbonyTreefolk card )  { super ( card ) ; } @Override public EbonyTreefolk copy (  )  { return new EbonyTreefolk ( this ) ; } } 
public class EnlistmentOfficer extends CardImpl { private static final FilterCard filter = new FilterCard ( "Soldier cards" ) ; static { filter . add ( new SubtypePredicate ( "Soldier" )  ) ; } public EnlistmentOfficer ( UUID ownerId )  { super ( ownerId, 9, "Enlistment Officer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public EnlistmentOfficer ( final EnlistmentOfficer card )  { super ( card ) ; } @Override public EnlistmentOfficer copy (  )  { return new EnlistmentOfficer ( this ) ; } } 
public class EvasiveAction extends CardImpl { public EvasiveAction ( UUID ownerId )  { super ( ownerId, 23, "Evasive Action", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new CounterUnlessPaysEffect ( new DomainValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell (  )  ) ; } public EvasiveAction ( final EvasiveAction card )  { super ( card ) ; } @Override public EvasiveAction copy (  )  { return new EvasiveAction ( this ) ; } } 
public class FerventCharge extends CardImpl { public FerventCharge ( UUID ownerId )  { super ( ownerId, 98, "Fervent Charge", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{B}{R}" ) ; this . expansionSetCode = "APC"; Effect effect = new BoostTargetEffect ( 2, 2, Duration . EndOfTurn ) ; effect . setText ( "it gets +2/+2 until end of turn" ) ; this . addAbility ( new AttacksCreatureYouControlTriggeredAbility ( effect, false, true )  ) ; } public FerventCharge ( final FerventCharge card )  { super ( card ) ; } @Override public FerventCharge copy (  )  { return new FerventCharge ( this ) ; } } 
public class FlowstoneCharger extends CardImpl { public FlowstoneCharger ( UUID ownerId )  { super ( ownerId, 99, "Flowstone Charger", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( 3, -3, Duration . EndOfTurn ) , false )  ) ; } public FlowstoneCharger ( final FlowstoneCharger card )  { super ( card ) ; } @Override public FlowstoneCharger copy (  )  { return new FlowstoneCharger ( this ) ; } } 
public class FoulPresence extends CardImpl { public FoulPresence ( UUID ownerId )  { super ( ownerId, 39, "Foul Presence", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . UnboostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( -1, -1, Duration . WhileOnBattlefield )  ) ; Ability gainedAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -1, -1, Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; gainedAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA, Duration . WhileOnBattlefield ) ; effect . setText ( "and has \"{T}: Target creature gets -1/-1 until end of turn . \"" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public FoulPresence ( final FoulPresence card )  { super ( card ) ; } @Override public FoulPresence copy (  )  { return new FoulPresence ( this ) ; } } 
public class GerrardCapashen extends CardImpl { public GerrardCapashen ( UUID ownerId )  { super ( ownerId, 11, "Gerrard Capashen", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{W}{W}" ) ; this . expansionSetCode = "APC"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; Ability ability1 = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new GerrardCapashenEffect (  ) , TargetController . YOU, false, true ) ; ability1 . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability1 ) ; Ability ability2 = new ActivateIfConditionActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new ManaCostsImpl ( "{3}{W}" ) , new SourceAttackingCondition (  )  ) ; ability2 . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability2 ) ; } public GerrardCapashen ( final GerrardCapashen card )  { super ( card ) ; } @Override public GerrardCapashen copy (  )  { return new GerrardCapashen ( this ) ; } } class GerrardCapashenEffect extends OneShotEffect { public GerrardCapashenEffect (  )  { super ( Outcome . GainLife ) ; staticText = "you gain 1 life for each card in target opponent's hand . "; } public GerrardCapashenEffect ( final GerrardCapashenEffect effect )  { super ( effect ) ; } @Override public GerrardCapashenEffect copy (  )  { return new GerrardCapashenEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetOpponent = game . getPlayer ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && targetOpponent != null )  { int cardsInHand = targetOpponent . getHand (  )  . size (  ) ; if  ( cardsInHand > 0 )  { controller . gainLife ( cardsInHand, game ) ; } return true; } return false; } } 
public class GerrardsVerdict extends CardImpl { public GerrardsVerdict ( UUID ownerId )  { super ( ownerId, 102, "Gerrard's Verdict", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{W}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new GerrardsVerdictEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public GerrardsVerdict ( final GerrardsVerdict card )  { super ( card ) ; } @Override public GerrardsVerdict copy (  )  { return new GerrardsVerdict ( this ) ; } } class GerrardsVerdictEffect extends OneShotEffect { public GerrardsVerdictEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "Target player discards two cards .  You gain 3 life for each land card discarded this way"; } public GerrardsVerdictEffect ( final GerrardsVerdictEffect effect )  { super ( effect ) ; } @Override public GerrardsVerdictEffect copy (  )  { return new GerrardsVerdictEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller != null && targetPlayer != null )  { controller . gainLife ( targetPlayer . discard ( 2, false, source, game )  . count ( new FilterLandCard (  ) , game )  * 3, game ) ; return true; } return false; } } 
public class GladeGnarr extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "a blue spell" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; } public GladeGnarr ( UUID ownerId )  { super ( ownerId, 78, "Glade Gnarr", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SpellCastAllTriggeredAbility ( new BoostSourceEffect ( 2, 2, Duration . EndOfTurn ) , filter, false )  ) ; } public GladeGnarr ( final GladeGnarr card )  { super ( card ) ; } @Override public GladeGnarr copy (  )  { return new GladeGnarr ( this ) ; } } 
public class GoblinLegionnaire extends CardImpl { public GoblinLegionnaire ( UUID ownerId )  { super ( ownerId, 103, "Goblin Legionnaire", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Goblin" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 2 ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; firstAbility . addCost ( new SacrificeSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 2 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; secondAbility . addCost ( new SacrificeSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( secondAbility ) ; } public GoblinLegionnaire ( final GoblinLegionnaire card )  { super ( card ) ; } @Override public GoblinLegionnaire copy (  )  { return new GoblinLegionnaire ( this ) ; } } 
public class GoblinRingleader extends CardImpl { private static final FilterCard filter = new FilterCard ( "Goblin cards" ) ; static { filter . add ( new SubtypePredicate ( "Goblin" )  ) ; } public GoblinRingleader ( UUID ownerId )  { super ( ownerId, 62, "Goblin Ringleader", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Goblin" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public GoblinRingleader ( final GoblinRingleader card )  { super ( card ) ; } @Override public GoblinRingleader copy (  )  { return new GoblinRingleader ( this ) ; } } 
public class GoblinTrenches extends CardImpl { final static FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a land" ) ; public GoblinTrenches ( UUID ownerId )  { super ( ownerId, 104, "Goblin Trenches", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}{W}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CreateTokenEffect ( new GoblinTrenchesToken (  ) , 2 ) , new GenericManaCost ( 2 )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  ) ; this . addAbility ( ability ) ; } public GoblinTrenches ( final GoblinTrenches card )  { super ( card ) ; } @Override public GoblinTrenches copy (  )  { return new GoblinTrenches ( this ) ; } } class GoblinTrenchesToken extends Token { GoblinTrenchesToken (  )  { super ( "Goblin Soldier", "1/1 red and white Goblin Soldier creature tokens" ) ; cardType . add ( CardType . CREATURE ) ; color . setRed ( true ) ; color . setWhite ( true ) ; subtype . add ( "Goblin" ) ; subtype . add ( "Soldier" ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; } } 
public class GraveDefiler extends CardImpl { private static final FilterCard filter = new FilterCard ( "Zombie cards" ) ; static { filter . add ( new SubtypePredicate ( "Zombie" )  ) ; } public GraveDefiler ( UUID ownerId )  { super ( ownerId, 40, "Grave Defiler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{1}{B}" )  )  ) ; } public GraveDefiler ( final GraveDefiler card )  { super ( card ) ; } @Override public GraveDefiler copy (  )  { return new GraveDefiler ( this ) ; } } 
public class HauntedAngel extends CardImpl { public HauntedAngel ( UUID ownerId )  { super ( ownerId, 12, "Haunted Angel", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new DiesTriggeredAbility ( new ExileSourceEffect (  )  ) ; ability . addEffect ( new HauntedAngelEffect (  )  ) ; this . addAbility ( ability ) ; } public HauntedAngel ( final HauntedAngel card )  { super ( card ) ; } @Override public HauntedAngel copy (  )  { return new HauntedAngel ( this ) ; } } class HauntedAngelEffect extends OneShotEffect { public HauntedAngelEffect (  )  { super ( Outcome . Detriment ) ; staticText = "and each other player puts a 3/3 black Angel creature token with flying onto the battlefield . "; } public HauntedAngelEffect ( HauntedAngelEffect copy )  { super ( copy ) ; } @Override public HauntedAngelEffect copy (  )  { return new HauntedAngelEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID controllerId = source . getControllerId (  ) ; HauntedAngelToken token = new HauntedAngelToken (  ) ; for ( UUID playerId: game . getState (  )  . getPlayersInRange ( controllerId, game )  )  { if ( !playerId . equals ( controllerId )  )  { token . putOntoBattlefield ( 1, game, source . getSourceId (  ) , playerId ) ; } } return true; } } class HauntedAngelToken extends Token { public HauntedAngelToken (  )  { super ( "Angel", "3/3 black Angel creature token with flying" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Angel" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class Helionaut extends CardImpl { public Helionaut ( UUID ownerId )  { super ( ownerId, 13, "Helionaut", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new AnyColorManaAbility ( new GenericManaCost ( 1 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public Helionaut ( final Helionaut card )  { super ( card ) ; } @Override public Helionaut copy (  )  { return new Helionaut ( this ) ; } } 
public class Illuminate extends CardImpl { public Illuminate ( UUID ownerId )  { super ( ownerId, 63, "Illuminate", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{X}{R}" ) ; this . expansionSetCode = "APC"; KickerAbility kickerAbility = new KickerAbility ( "{2}{R}" ) ; kickerAbility . addKickerCost ( "{3}{U}" ) ; this . addAbility ( kickerAbility ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( new ManacostVariableValue (  )  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new DamageTargetControllerEffect ( new ManacostVariableValue (  )  ) , new KickedCostCondition ( "{2}{R}" ) , "If {this} was kicked with its {2}{R} kicker, it deals X damage to that creature's controller . " )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new DrawCardSourceControllerEffect ( new ManacostVariableValue (  )  ) , new KickedCostCondition ( "{3}{U}" ) , "If {this} was kicked with its {3}{U} kicker, you draw X cards . " )  ) ; } public Illuminate ( final Illuminate card )  { super ( card ) ; } @Override public Illuminate copy (  )  { return new Illuminate ( this ) ; } } 
public class Index extends CardImpl { public Index ( UUID ownerId )  { super ( ownerId, 25, "Index", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new LookLibraryControllerEffect ( 5 )  ) ; } public Index ( final Index card )  { super ( card ) ; } @Override public Index copy (  )  { return new Index ( this ) ; } } 
public class Jilt extends CardImpl { public Jilt ( UUID ownerId )  { super ( ownerId, 27, "Jilt", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new KickerAbility ( "{1}{R}" )  ) ; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; Effect effect = new ConditionalOneShotEffect (  new DamageTargetEffect ( 2 ) , KickedCondition . getInstance (  ) , "If {this} was kicked, it deals 2 damage to another target creature" ) ; effect . setTargetPointer ( new SecondTargetPointer (  )  ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SpellAbility && KickedCondition . getInstance (  )  . apply ( game, ability )  )  { ability . addTarget ( new TargetOtherCreaturePermanent ( new FilterCreaturePermanent ( "another target creature" )  )  ) ; } } public Jilt ( final Jilt card )  { super ( card ) ; } @Override public Jilt copy (  )  { return new Jilt ( this ) ; } } class TargetOtherCreaturePermanent extends TargetCreaturePermanent { public TargetOtherCreaturePermanent ( FilterCreaturePermanent filter )  { super ( filter ) ; } public TargetOtherCreaturePermanent ( final TargetOtherCreaturePermanent target )  { super ( target ) ; } @Override public boolean canTarget ( UUID controllerId, UUID id, Ability source, Game game )  { if  ( source . getTargets (  )  . get ( 0 )  . getTargets (  )  . contains ( id )  )  { return false; } return super . canTarget ( controllerId, id, source, game ) ; } @Override public TargetOtherCreaturePermanent copy (  )  { return new TargetOtherCreaturePermanent ( this ) ; } } 
public class JungleBarrier extends CardImpl { public JungleBarrier ( UUID ownerId )  { super ( ownerId, 106, "Jungle Barrier", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Plant" ) ; this . subtype . add ( "Wall" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; } public JungleBarrier ( final JungleBarrier card )  { super ( card ) ; } @Override public JungleBarrier copy (  )  { return new JungleBarrier ( this ) ; } } 
public class KavuGlider extends CardImpl { public KavuGlider ( UUID ownerId )  { super ( ownerId, 64, "Kavu Glider", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 0, 1, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . W )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . U )  )  ) ; } public KavuGlider ( final KavuGlider card )  { super ( card ) ; } @Override public KavuGlider copy (  )  { return new KavuGlider ( this ) ; } } 
public class KavuHowler extends CardImpl { private static final FilterCard filter = new FilterCard ( "Kavu cards" ) ; static { filter . add ( new SubtypePredicate ( "Kavu" )  ) ; } public KavuHowler ( UUID ownerId )  { super ( ownerId, 79, "Kavu Howler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public KavuHowler ( final KavuHowler card )  { super ( card ) ; } @Override public KavuHowler copy (  )  { return new KavuHowler ( this ) ; } } 
public class KavuMauler extends CardImpl { private static final FilterAttackingCreature filter = new FilterAttackingCreature ( "other attacking Kavu" ) ; static { filter . add ( new SubtypePredicate ( "Kavu" )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public KavuMauler ( UUID ownerId )  { super ( ownerId, 80, "Kavu Mauler", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount ( filter ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( value, value, Duration . EndOfTurn, true ) , false )  ) ; } public KavuMauler ( final KavuMauler card )  { super ( card ) ; } @Override public KavuMauler copy (  )  { return new KavuMauler ( this ) ; } } 
public class LastCaress extends CardImpl { public LastCaress ( UUID ownerId )  { super ( ownerId, 41, "Last Caress", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new LoseLifeTargetEffect ( 1 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 1 )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public LastCaress ( final LastCaress card )  { super ( card ) ; } @Override public LastCaress copy (  )  { return new LastCaress ( this ) ; } } 
public class LayOfTheLand extends CardImpl { private static final FilterBasicLandCard filter = new FilterBasicLandCard (  ) ; public LayOfTheLand ( UUID ownerId )  { super ( ownerId, 81, "Lay of the Land", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( 1, 1, filter ) , true )  ) ; } public LayOfTheLand ( final LayOfTheLand card )  { super ( card ) ; } @Override public LayOfTheLand copy (  )  { return new LayOfTheLand ( this ) ; } } 
public class LivingAirship extends CardImpl { public LivingAirship ( UUID ownerId )  { super ( ownerId, 28, "Living Airship", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Metathran" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{2}{G}" )  )  ) ; } public LivingAirship ( final LivingAirship card )  { super ( card ) ; } @Override public LivingAirship copy (  )  { return new LivingAirship ( this ) ; } } 
public class LlanowarDead extends CardImpl { public LlanowarDead ( UUID ownerId )  { super ( ownerId, 109, "Llanowar Dead", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Elf" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public LlanowarDead ( final LlanowarDead card )  { super ( card ) ; } @Override public LlanowarDead copy (  )  { return new LlanowarDead ( this ) ; } } 
public class LlanowarWastes extends CardImpl { public LlanowarWastes ( UUID ownerId )  { super ( ownerId, 141, "Llanowar Wastes", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability blackManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlackMana ( 1 ) , new TapSourceCost (  )  ) ; blackManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blackManaAbility ) ; Ability greenManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . GreenMana ( 1 ) , new TapSourceCost (  )  ) ; greenManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( greenManaAbility ) ; } public LlanowarWastes ( final LlanowarWastes card )  { super ( card ) ; } @Override public LlanowarWastes copy (  )  { return new LlanowarWastes ( this ) ; } } 
public class ManaclesOfDecay extends CardImpl { public ManaclesOfDecay ( UUID ownerId )  { super ( ownerId, 14, "Manacles of Decay", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantAttackAttachedEffect ( AttachmentType . AURA )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( -1, -1, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . B )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBlockAttachedEffect ( AttachmentType . AURA, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  )  ) ; } public ManaclesOfDecay ( final ManaclesOfDecay card )  { super ( card ) ; } @Override public ManaclesOfDecay copy (  )  { return new ManaclesOfDecay ( this ) ; } } 
public class MartyrsTomb extends CardImpl { public MartyrsTomb ( UUID ownerId )  { super ( ownerId, 110, "Martyrs' Tomb", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{W}{B}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 1 ) , new PayLifeCost ( 2 )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MartyrsTomb ( final MartyrsTomb card )  { super ( card ) ; } @Override public MartyrsTomb copy (  )  { return new MartyrsTomb ( this ) ; } } 
public class MaskOfIntolerance extends CardImpl { public MaskOfIntolerance ( UUID ownerId )  { super ( ownerId, 138, "Mask of Intolerance", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{2}" ) ; this . expansionSetCode = "APC"; TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 3 ) , TargetController . ANY, false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, new MaskOfIntoleranceCondition (  ) , "At the beginning of each player's upkeep, if there are four or more basic land types among lands that player controls, {this} deals 3 damage to him or her . " )  ) ; } public MaskOfIntolerance ( final MaskOfIntolerance card )  { super ( card ) ; } @Override public MaskOfIntolerance copy (  )  { return new MaskOfIntolerance ( this ) ; } } class MaskOfIntoleranceCondition extends IntCompareCondition { public MaskOfIntoleranceCondition (  )  { super ( ComparisonType . GreaterThan, 3 ) ; } @Override protected int getInputValue ( Game game, Ability source )  { return new DomainValue ( 1, game . getActivePlayerId (  )  )  . calculate ( game, source, null ) ; } } 
public class MinotaurIllusionist extends CardImpl { public MinotaurIllusionist ( UUID ownerId )  { super ( ownerId, 111, "Minotaur Illusionist", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( ShroudAbility . getInstance (  ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{1}{U}" )  )  ) ; Effect effect = new DamageTargetEffect ( new SourcePermanentPowerCount (  )  ) ; effect . setText ( "{this} deals damage equal to its power to target creature . " ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new ManaCostsImpl ( "{R}" )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MinotaurIllusionist ( final MinotaurIllusionist card )  { super ( card ) ; } @Override public MinotaurIllusionist copy (  )  { return new MinotaurIllusionist ( this ) ; } } 
public class MinotaurTactician extends CardImpl { private static final FilterControlledCreaturePermanent filterWhite = new FilterControlledCreaturePermanent (  ) ; private static final FilterControlledCreaturePermanent filterBlue = new FilterControlledCreaturePermanent (  ) ; static { filterWhite . add ( new ColorPredicate ( ObjectColor . WHITE )  ) ; filterBlue . add ( new ColorPredicate ( ObjectColor . BLUE )  ) ; } final private String ruleWhite = "{this} gets +1/+1 as long as you control another white creature"; final private String ruleBlue = "{this} gets +1/+1 as long as you control another white creature"; public MinotaurTactician ( UUID ownerId )  { super ( ownerId, 65, "Minotaur Tactician", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Minotaur" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Condition conditionWhite = new PermanentsOnTheBattlefieldCondition ( filterWhite, CountType . MORE_THAN, 0 ) ; Effect effectWhite = new ConditionalContinuousEffect ( new BoostSourceEffect ( 1, 1, Duration . WhileOnBattlefield ) , conditionWhite, ruleWhite ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effectWhite )  ) ; Condition conditionBlue = new PermanentsOnTheBattlefieldCondition ( filterBlue, CountType . MORE_THAN, 0 ) ; Effect effectBlue = new ConditionalContinuousEffect ( new BoostSourceEffect ( 1, 1, Duration . WhileOnBattlefield ) , conditionBlue, ruleBlue ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effectBlue )  ) ; } public MinotaurTactician ( final MinotaurTactician card )  { super ( card ) ; } @Override public MinotaurTactician copy (  )  { return new MinotaurTactician ( this ) ; } } 
public class MournfulZombie extends CardImpl { public MournfulZombie ( UUID ownerId )  { super ( ownerId, 43, "Mournful Zombie", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeTargetEffect ( 1 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPlayer ( 1 )  ) ; this . addAbility ( ability ) ; } public MournfulZombie ( final MournfulZombie card )  { super ( card ) ; } @Override public MournfulZombie copy (  )  { return new MournfulZombie ( this ) ; } } 
public class MysticSnake extends CardImpl { public MysticSnake ( UUID ownerId )  { super ( ownerId, 112, "Mystic Snake", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{U}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlashAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new CounterTargetEffect (  )  ) ; ability . addTarget ( new TargetSpell (  )  ) ; this . addAbility ( ability ) ; } public MysticSnake ( final MysticSnake card )  { super ( card ) ; } @Override public MysticSnake copy (  )  { return new MysticSnake ( this ) ; } } 
public class NecraDisciple extends CardImpl { public NecraDisciple ( UUID ownerId )  { super ( ownerId, 44, "Necra Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new AnyColorManaAbility ( new ColoredManaCost ( ColoredManaSymbol . G )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 1 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( secondAbility ) ; } public NecraDisciple ( final NecraDisciple card )  { super ( card ) ; } @Override public NecraDisciple copy (  )  { return new NecraDisciple ( this ) ; } } 
public class Necravolver extends CardImpl { public Necravolver ( UUID ownerId )  { super ( ownerId, 46, "Necravolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{G}" ) ; kickerAbility . addKickerCost ( "{W}" ) ; this . addAbility ( kickerAbility ) ; Ability ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  ) , new KickedCostCondition ( "{1}{G}" ) , "If {this} was kicked with its {1}{G} kicker, it enters the battlefield with two +1/+1 counters on it and with trample . ", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( TrampleAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 )  ) , new KickedCostCondition ( "{W}" ) , "If {this} was kicked with its {W} kicker, it enters the battlefield with a +1/+1 counter on it and with \"Whenever {this} deals damage, you gain that much life . \"", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( new DealsDamageGainLifeSourceTriggeredAbility (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; } public Necravolver ( final Necravolver card )  { super ( card ) ; } @Override public Necravolver copy (  )  { return new Necravolver ( this ) ; } } 
public class OrimsThunder extends CardImpl { public OrimsThunder ( UUID ownerId )  { super ( ownerId, 15, "Orim's Thunder", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{W}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new KickerAbility ( "{R}" )  ) ; this . getSpellAbility (  )  . addEffect ( new OrimsThunderEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( new FilterArtifactOrEnchantmentPermanent (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new ConditionalOneShotEffect (  new OrimsThunderEffect2 (  ) , KickedCondition . getInstance (  ) , "If Orim's Thunder was kicked, it deals damage equal to that permanent's converted mana cost to target creature" )  ) ; } @Override public void adjustTargets ( Ability ability, Game game )  { if  ( ability instanceof SpellAbility )  { if  ( KickedCondition . getInstance (  )  . apply ( game, ability )  )  { ability . addTarget ( new TargetCreaturePermanent (  )  ) ; } } } public OrimsThunder ( final OrimsThunder card )  { super ( card ) ; } @Override public OrimsThunder copy (  )  { return new OrimsThunder ( this ) ; } } class OrimsThunderEffect2 extends OneShotEffect { OrimsThunderEffect2 (  )  { super ( Outcome . Damage ) ; } OrimsThunderEffect2 ( final OrimsThunderEffect2 effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { int damage = 0; MageObject firstTarget = game . getLastKnownInformation ( source . getFirstTarget (  ) , Zone . BATTLEFIELD ) ; Permanent secondTarget = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( firstTarget != null )  { damage = firstTarget . getManaCost (  )  . convertedManaCost (  ) ; } boolean kicked = KickedCondition . getInstance (  )  . apply ( game, source ) ; if  ( kicked && secondTarget != null )  { secondTarget . damage ( damage, source . getSourceId (  ) , game, false, true ) ; return true; } return false; } @Override public OrimsThunderEffect2 copy (  )  { return new OrimsThunderEffect2 ( this ) ; } } class OrimsThunderEffect extends OneShotEffect { OrimsThunderEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy target artifact or enchantment"; } OrimsThunderEffect ( final OrimsThunderEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent target = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( target != null )  { return target . destroy ( source . getSourceId (  ) , game, false ) ; } return false; } @Override public OrimsThunderEffect copy (  )  { return new OrimsThunderEffect ( this ) ; } } 
public class OvergrownEstate extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledLandPermanent ( "a land" ) ; public OvergrownEstate ( UUID ownerId )  { super ( ownerId, 113, "Overgrown Estate", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{B}{G}{W}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( 3 ) , new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  ) ; } public OvergrownEstate ( final OvergrownEstate card )  { super ( card ) ; } @Override public OvergrownEstate copy (  )  { return new OvergrownEstate ( this ) ; } } 
public class PenumbraBobcat extends CardImpl { public PenumbraBobcat ( UUID ownerId )  { super ( ownerId, 82, "Penumbra Bobcat", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Cat" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new PenumbraBobcatToken (  ) , 1 ) , false )  ) ; } public PenumbraBobcat ( final PenumbraBobcat card )  { super ( card ) ; } @Override public PenumbraBobcat copy (  )  { return new PenumbraBobcat ( this ) ; } } class PenumbraBobcatToken extends Token { PenumbraBobcatToken (  )  { super ( "Cat", "2/1 black Cat creature token" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Cat" ) ; power = new MageInt ( 2 ) ; toughness = new MageInt ( 1 ) ; } } 
public class PenumbraKavu extends CardImpl { public PenumbraKavu ( UUID ownerId )  { super ( ownerId, 83, "Penumbra Kavu", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new PenumbraKavuToken (  ) , 1 ) , false )  ) ; } public PenumbraKavu ( final PenumbraKavu card )  { super ( card ) ; } @Override public PenumbraKavu copy (  )  { return new PenumbraKavu ( this ) ; } } class PenumbraKavuToken extends Token { PenumbraKavuToken (  )  { super ( "Kavu", "3/3 black Kavu creature token" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Kavu" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; } } 
public class PenumbraWurm extends CardImpl { public PenumbraWurm ( UUID ownerId )  { super ( ownerId, 84, "Penumbra Wurm", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{G}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new PenumbraWurmToken (  ) , 1 ) , false )  ) ; } public PenumbraWurm ( final PenumbraWurm card )  { super ( card ) ; } @Override public PenumbraWurm copy (  )  { return new PenumbraWurm ( this ) ; } } class PenumbraWurmToken extends Token { PenumbraWurmToken (  )  { super ( "Wurm", "6/6 black Wurm creature token with trample" ) ; cardType . add ( CardType . CREATURE ) ; color . setBlack ( true ) ; subtype . add ( "Wurm" ) ; power = new MageInt ( 6 ) ; toughness = new MageInt ( 6 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; } } 
public class PerniciousDeed extends CardImpl { public PerniciousDeed ( UUID ownerId )  { super ( ownerId, 114, "Pernicious Deed", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{B}{G}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PerniciousDeedEffect (  ) , new VariableManaCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; this . addAbility ( ability ) ; } public PerniciousDeed ( final PerniciousDeed card )  { super ( card ) ; } @Override public PerniciousDeed copy (  )  { return new PerniciousDeed ( this ) ; } } class PerniciousDeedEffect extends OneShotEffect { public PerniciousDeedEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy each artifact, creature, and enchantment with converted mana cost X or less"; } public PerniciousDeedEffect ( final PerniciousDeedEffect effect )  { super ( effect ) ; } @Override public PerniciousDeedEffect copy (  )  { return new PerniciousDeedEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { FilterPermanent filter = new FilterPermanent ( "artifacts, creatures, and enchantments" ) ; filter . add ( Predicates . or (  new CardTypePredicate ( CardType . ARTIFACT ) , new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . ENCHANTMENT )  )  ) ; filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, source . getManaCostsToPay (  )  . getX (  )  + 1 )  ) ; for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . destroy ( source . getSourceId (  ) , game, false ) ; } return true; } } 
public class PlanarDespair extends CardImpl { public PlanarDespair ( UUID ownerId )  { super ( ownerId, 50, "Planar Despair", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{B}{B}" ) ; this . expansionSetCode = "APC"; DynamicValue dv = new SignInversionDynamicValue ( new DomainValue (  )  ) ; Effect effect = new BoostAllEffect ( dv, dv, Duration . EndOfTurn ) ; effect . setText ( "Domain - All creatures get -1/-1 until end of turn for each basic land type among lands you control . " ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public PlanarDespair ( final PlanarDespair card )  { super ( card ) ; } @Override public PlanarDespair copy (  )  { return new PlanarDespair ( this ) ; } } 
public class PutridWarrior extends CardImpl { public PutridWarrior ( UUID ownerId )  { super ( ownerId, 117, "Putrid Warrior", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Soldier" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new PutridWarriorDealsDamageTriggeredAbility ( new LoseLifeAllPlayersEffect ( 1 )  ) ; Mode mode = new Mode (  ) ; mode . getEffects (  )  . add ( new PutridWarriorGainLifeEffect (  )  ) ; ability . addMode ( mode ) ; this . addAbility ( ability ) ; } public PutridWarrior ( final PutridWarrior card )  { super ( card ) ; } @Override public PutridWarrior copy (  )  { return new PutridWarrior ( this ) ; } } class PutridWarriorDealsDamageTriggeredAbility extends TriggeredAbilityImpl { public PutridWarriorDealsDamageTriggeredAbility ( Effect effect )  { super ( Zone . BATTLEFIELD, effect, false ) ; } public PutridWarriorDealsDamageTriggeredAbility ( final PutridWarriorDealsDamageTriggeredAbility ability )  { super ( ability ) ; } @Override public PutridWarriorDealsDamageTriggeredAbility copy (  )  { return new PutridWarriorDealsDamageTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER || event . getType (  )  == EventType . DAMAGED_CREATURE || event . getType (  )  == EventType . DAMAGED_PLANESWALKER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { return event . getSourceId (  )  . equals ( this . sourceId ) ; } @Override public String getRule (  )  { return "Whenever {this} deals damage, " + super . getRule (  ) ; } } class PutridWarriorGainLifeEffect extends OneShotEffect { public PutridWarriorGainLifeEffect (  )  { super ( Outcome . GainLife ) ; staticText = "Each player gains 1 life . "; } public PutridWarriorGainLifeEffect ( final PutridWarriorGainLifeEffect effect )  { super ( effect ) ; } @Override public PutridWarriorGainLifeEffect copy (  )  { return new PutridWarriorGainLifeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for ( UUID playerId: game . getState (  )  . getPlayersInRange ( source . getControllerId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if ( player != null )  { player . gainLife ( 1, game ) ; } } return true; } } 
public class QuagmireDruid extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "enchantment" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public QuagmireDruid ( UUID ownerId )  { super ( ownerId, 51, "Quagmire Druid", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect ( false ) , new ColoredManaCost ( ColoredManaSymbol . G )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public QuagmireDruid ( final QuagmireDruid card )  { super ( card ) ; } @Override public QuagmireDruid copy (  )  { return new QuagmireDruid ( this ) ; } } 
public class QuicksilverDagger extends CardImpl { public QuicksilverDagger ( UUID ownerId )  { super ( ownerId, 118, "Quicksilver Dagger", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability gainAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; gainAbility . addTarget ( new TargetPlayer (  )  ) ; gainAbility . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( gainAbility, AttachmentType . AURA )  )  ) ; } public QuicksilverDagger ( final QuicksilverDagger card )  { super ( card ) ; } @Override public QuicksilverDagger copy (  )  { return new QuicksilverDagger ( this ) ; } } 
public class RakaDisciple extends CardImpl { public RakaDisciple ( UUID ownerId )  { super ( ownerId, 66, "Raka Disciple", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Minotaur" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability firstAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventDamageToTargetEffect ( Duration . EndOfTurn, 1 ) , new ColoredManaCost ( ColoredManaSymbol . W )  ) ; firstAbility . addCost ( new TapSourceCost (  )  ) ; firstAbility . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( firstAbility ) ; Ability secondAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilityTargetEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . U )  ) ; secondAbility . addCost ( new TapSourceCost (  )  ) ; secondAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( secondAbility ) ; } public RakaDisciple ( final RakaDisciple card )  { super ( card ) ; } @Override public RakaDisciple copy (  )  { return new RakaDisciple ( this ) ; } } 
public class Rakavolver extends CardImpl { public Rakavolver ( UUID ownerId )  { super ( ownerId, 68, "Rakavolver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Volver" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; KickerAbility kickerAbility = new KickerAbility ( "{1}{W}" ) ; kickerAbility . addKickerCost ( "{U}" ) ; this . addAbility ( kickerAbility ) ; Ability ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 )  ) , new KickedCostCondition ( "{1}{W}" ) , "If {this} was kicked with its {1}{W} kicker, it enters the battlefield with two +1/+1 counters on it and with \"Whenever {this} deals damage, you gain that much life . \"", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( new DealsDamageGainLifeSourceTriggeredAbility (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; ability = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 )  ) , new KickedCostCondition ( "{U}" ) , "If {this} was kicked with its {U} kicker, it enters the battlefield with a +1/+1 counter on it and with flying . ", "" ) ; ability . addEffect ( new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . WhileOnBattlefield )  ) ; this . addAbility ( ability ) ; } public Rakavolver ( final Rakavolver card )  { super ( card ) ; } @Override public Rakavolver copy (  )  { return new Rakavolver ( this ) ; } } 
public class RazorfinHunter extends CardImpl { public RazorfinHunter ( UUID ownerId )  { super ( ownerId, 119, "Razorfin Hunter", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Goblin" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( ability ) ; } public RazorfinHunter ( final RazorfinHunter card )  { super ( card ) ; } @Override public RazorfinHunter copy (  )  { return new RazorfinHunter ( this ) ; } } 
public class ReefShaman extends CardImpl { public ReefShaman ( UUID ownerId )  { super ( ownerId, 29, "Reef Shaman", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesBasicLandTargetEffect ( Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetLandPermanent (  )  ) ; this . addAbility ( ability ) ; } public ReefShaman ( final ReefShaman card )  { super ( card ) ; } @Override public ReefShaman copy (  )  { return new ReefShaman ( this ) ; } } 
public class SavageGorilla extends CardImpl { public SavageGorilla ( UUID ownerId )  { super ( ownerId, 85, "Savage Gorilla", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Ape" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( -3, -3, Duration . EndOfTurn ) , new ManaCostsImpl ( "{U}{B}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public SavageGorilla ( final SavageGorilla card )  { super ( card ) ; } @Override public SavageGorilla copy (  )  { return new SavageGorilla ( this ) ; } } 
public class ShieldOfDutyAndReason extends CardImpl { private static final FilterCard filter = new FilterCard ( "green and from blue" ) ; static { filter . add ( Predicates . or ( new ColorPredicate ( ObjectColor . GREEN ) , new ColorPredicate ( ObjectColor . BLUE )  )  ) ; } public ShieldOfDutyAndReason ( UUID ownerId )  { super ( ownerId, 16, "Shield of Duty and Reason", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( new ProtectionAbility ( filter ) , AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public ShieldOfDutyAndReason ( final ShieldOfDutyAndReason card )  { super ( card ) ; } @Override public ShieldOfDutyAndReason copy (  )  { return new ShieldOfDutyAndReason ( this ) ; } } 
public class ShimmeringMirage extends CardImpl { public ShimmeringMirage ( UUID ownerId )  { super ( ownerId, 30, "Shimmering Mirage", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new BecomesBasicLandTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetLandPermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public ShimmeringMirage ( final ShimmeringMirage card )  { super ( card ) ; } @Override public ShimmeringMirage copy (  )  { return new ShimmeringMirage ( this ) ; } } 
public class ShivanReef extends CardImpl { public ShivanReef ( UUID ownerId )  { super ( ownerId, 142, "Shivan Reef", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability blueManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlueMana ( 1 ) , new TapSourceCost (  )  ) ; blueManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blueManaAbility ) ; Ability redManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . RedMana ( 1 ) , new TapSourceCost (  )  ) ; redManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( redManaAbility ) ; } public ShivanReef ( final ShivanReef card )  { super ( card ) ; } @Override public ShivanReef copy (  )  { return new ShivanReef ( this ) ; } } 
public class Smash extends CardImpl { public Smash ( UUID ownerId )  { super ( ownerId, 69, "Smash", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( new FilterArtifactPermanent (  )  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public Smash ( final Smash card )  { super ( card ) ; } @Override public Smash copy (  )  { return new Smash ( this ) ; } } 
public class SoulLink extends CardImpl { public SoulLink ( UUID ownerId )  { super ( ownerId, 120, "Soul Link", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}{B}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new DealsDamageAttachedTriggeredAbility ( Zone . BATTLEFIELD, new GainLifeEffect ( new NumericSetToEffectValues ( "that much", "damage" )  ) , false )  ) ; this . addAbility ( new DamageDealtToAttachedTriggeredAbility ( new GainLifeEffect ( new NumericSetToEffectValues ( "that much", "damage" )  ) , false )  ) ; } public SoulLink ( final SoulLink card )  { super ( card ) ; } @Override public SoulLink copy (  )  { return new SoulLink ( this ) ; } } 
public class SpectralLynx extends CardImpl { private static final FilterCard filter = new FilterCard ( "green" ) ; static { filter . add ( new ColorPredicate ( ObjectColor . GREEN )  ) ; } public SpectralLynx ( UUID ownerId )  { super ( ownerId, 17, "Spectral Lynx", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Cat" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new ProtectionAbility ( filter )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; } public SpectralLynx ( final SpectralLynx card )  { super ( card ) ; } @Override public SpectralLynx copy (  )  { return new SpectralLynx ( this ) ; } } 
public class Spiritmonger extends CardImpl { public Spiritmonger ( UUID ownerId )  { super ( ownerId, 121, "Spiritmonger", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( new DealsDamageToACreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  ) , true ) , false, false, false )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new ManaCostsImpl ( "{B}" )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesColorSourceEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{G}" )  )  ) ; } public Spiritmonger ( final Spiritmonger card )  { super ( card ) ; } @Override public Spiritmonger copy (  )  { return new Spiritmonger ( this ) ; } } 
public class SqueesEmbrace extends CardImpl { public SqueesEmbrace ( UUID ownerId )  { super ( ownerId, 122, "Squee's Embrace", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{R}{W}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 2, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new DiesAttachedTriggeredAbility ( new ReturnToHandAttachedEffect (  ) , "enchanted creature" )  ) ; } public SqueesEmbrace ( final SqueesEmbrace card )  { super ( card ) ; } @Override public SqueesEmbrace copy (  )  { return new SqueesEmbrace ( this ) ; } } 
public class SqueesRevenge extends CardImpl { public SqueesRevenge ( UUID ownerId )  { super ( ownerId, 123, "Squee's Revenge", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{1}{U}{R}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new SqueesRevengeEffect (  )  ) ; } public SqueesRevenge ( final SqueesRevenge card )  { super ( card ) ; } @Override public SqueesRevenge copy (  )  { return new SqueesRevenge ( this ) ; } } class SqueesRevengeEffect extends OneShotEffect { public SqueesRevengeEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Choose a number .  Flip a coin that many times or until you lose a flip, whichever comes first .  If you win all the flips, draw two cards for each flip . "; } public SqueesRevengeEffect ( final SqueesRevengeEffect effect )  { super ( effect ) ; } @Override public SqueesRevengeEffect copy (  )  { return new SqueesRevengeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if ( player != null )  { int number = player . announceXMana ( 0, Integer . MAX_VALUE, "Choose how many times to flip a coin", game, source ) ; game . informPlayers ( player . getLogName (  )  + " chooses " + number + " . " ) ; for ( int i = 0; i < number; i++ )  { if ( !player . flipCoin ( game )  )  { return true; } } player . drawCards ( 2 * number, game ) ; return true; } return false; } }
public class SylvanMessenger extends CardImpl { private static final FilterCard filter = new FilterCard ( "Elf cards" ) ; static { filter . add ( new SubtypePredicate ( "Elf" )  ) ; } public SylvanMessenger ( UUID ownerId )  { super ( ownerId, 87, "Sylvan Messenger", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Elf" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; } public SylvanMessenger ( final SylvanMessenger card )  { super ( card ) ; } @Override public SylvanMessenger copy (  )  { return new SylvanMessenger ( this ) ; } } 
public class SymbioticDeployment extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creatures you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public SymbioticDeployment ( UUID ownerId )  { super ( ownerId, 88, "Symbiotic Deployment", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SkipDrawStepEffect (  )  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new ManaCostsImpl ( "{1}" )  ) ; ability . addCost ( new TapTargetCost ( new TargetControlledCreaturePermanent ( 2, 2, filter, false )  )  ) ; this . addAbility ( ability ) ; } public SymbioticDeployment ( final SymbioticDeployment card )  { super ( card ) ; } @Override public SymbioticDeployment copy (  )  { return new SymbioticDeployment ( this ) ; } } 
public class TemporalSpring extends CardImpl { public TemporalSpring ( UUID ownerId )  { super ( ownerId, 125, "Temporal Spring", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{G}{U}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; } public TemporalSpring ( final TemporalSpring card )  { super ( card ) ; } @Override public TemporalSpring copy (  )  { return new TemporalSpring ( this ) ; } } 
public class TidalCourier extends CardImpl { private static final FilterCard filter = new FilterCard ( "Merfolk cards" ) ; static { filter . add ( new SubtypePredicate ( "Merfolk" )  ) ; } public TidalCourier ( UUID ownerId )  { super ( ownerId, 31, "Tidal Courier", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new EnvoyEffect ( filter, 4 )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}{U}" )  )  ) ; } public TidalCourier ( final TidalCourier card )  { super ( card ) ; } @Override public TidalCourier copy (  )  { return new TidalCourier ( this ) ; } } 
public class TranquilPath extends CardImpl { public TranquilPath ( UUID ownerId )  { super ( ownerId, 89, "Tranquil Path", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{G}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new TranquilPathEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public TranquilPath ( final TranquilPath card )  { super ( card ) ; } @Override public TranquilPath copy (  )  { return new TranquilPath ( this ) ; } } class TranquilPathEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterPermanent ( "" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public TranquilPathEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy all enchantments"; } public TranquilPathEffect ( final TranquilPathEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { permanent . destroy ( source . getSourceId (  ) , game, false ) ; } return true; } @Override public TranquilPathEffect copy (  )  { return new TranquilPathEffect ( this ) ; } } 
public class TundraKavu extends CardImpl { public TundraKavu ( UUID ownerId )  { super ( ownerId, 71, "Tundra Kavu", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Kavu" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TundraKavuEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetLandPermanent (  )  ) ; this . addAbility ( ability ) ; } public TundraKavu ( final TundraKavu card )  { super ( card ) ; } @Override public TundraKavu copy (  )  { return new TundraKavu ( this ) ; } } class TundraKavuEffect extends BecomesBasicLandTargetEffect { public TundraKavuEffect (  )  { super ( Duration . EndOfTurn, false, true, "" ) ; staticText = "Target land becomes a Plains or an Island until end of turn . "; } public TundraKavuEffect ( final TundraKavuEffect effect )  { super ( effect ) ; } public TundraKavuEffect copy (  )  { return new TundraKavuEffect ( this ) ; } @Override public void init ( Ability source, Game game )  { landTypes . clear (  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if ( controller != null )  { Set<String> choiceSet = new LinkedHashSet<> (  ) ; choiceSet . add ( "Island" ) ; choiceSet . add ( "Plains" ) ; ChoiceImpl choice = new ChoiceImpl ( true ) ; choice . setChoices ( choiceSet ) ; choice . setMessage ( "Choose a basic land type" ) ; controller . choose ( outcome, choice, game ) ; landTypes . add ( choice . getChoice (  )  ) ; } else { this . discard (  ) ; } super . init ( source, game ) ; } } 
public class UnnaturalSelection extends CardImpl { public UnnaturalSelection ( UUID ownerId )  { super ( ownerId, 32, "Unnatural Selection", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "APC"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesChosenCreatureTypeTargetEffect ( true ) , new GenericManaCost ( 1 )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public UnnaturalSelection ( final UnnaturalSelection card )  { super ( card ) ; } @Override public UnnaturalSelection copy (  )  { return new UnnaturalSelection ( this ) ; } } 
public class UrborgElf extends CardImpl { public UrborgElf ( UUID ownerId )  { super ( ownerId, 90, "Urborg Elf", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Elf" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new GreenManaAbility (  )  ) ; this . addAbility ( new BlueManaAbility (  )  ) ; this . addAbility ( new BlackManaAbility (  )  ) ; } public UrborgElf ( final UrborgElf card )  { super ( card ) ; } @Override public UrborgElf copy (  )  { return new UrborgElf ( this ) ; } } 
public class UrborgUprising extends CardImpl { public UrborgUprising ( UUID ownerId )  { super ( ownerId, 53, "Urborg Uprising", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( 0, 2, new FilterCreatureCard ( "creature cards from your graveyard" )  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public UrborgUprising ( final UrborgUprising card )  { super ( card ) ; } @Override public UrborgUprising copy (  )  { return new UrborgUprising ( this ) ; } } 
public class Vindicate extends CardImpl { public Vindicate  ( UUID ownerId )  { super ( ownerId, 126, "Vindicate", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{1}{W}{B}" ) ; this . expansionSetCode = "APC"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent (  )  ) ; } public Vindicate  ( final Vindicate card )  { super ( card ) ; } @Override public Vindicate copy (  )  { return new Vindicate ( this ) ; } } 
public class VodalianMystic extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant or sorcery spell" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . INSTANT ) , new CardTypePredicate ( CardType . SORCERY )  )  ) ; } public VodalianMystic ( UUID ownerId )  { super ( ownerId, 33, "Vodalian Mystic", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BecomesColorTargetEffect ( Duration . WhileOnStack ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetSpell ( filter )  ) ; this . addAbility ( ability ) ; } public VodalianMystic ( final VodalianMystic card )  { super ( card ) ; } @Override public VodalianMystic copy (  )  { return new VodalianMystic ( this ) ; } } 
public class WhirlpoolDrake extends CardImpl { public WhirlpoolDrake ( UUID ownerId )  { super ( ownerId, 34, "Whirlpool Drake", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ShuffleHandIntoLibraryDrawThatManySourceEffect (  ) , false )  ) ; this . addAbility ( new DiesTriggeredAbility ( new ShuffleHandIntoLibraryDrawThatManySourceEffect (  ) , false )  ) ; } public WhirlpoolDrake ( final WhirlpoolDrake card )  { super ( card ) ; } @Override public WhirlpoolDrake copy (  )  { return new WhirlpoolDrake ( this ) ; } } 
public class WhirlpoolRider extends CardImpl { public WhirlpoolRider ( UUID ownerId )  { super ( ownerId, 35, "Whirlpool Rider", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Merfolk" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ShuffleHandIntoLibraryDrawThatManySourceEffect (  )  )  ) ; } public WhirlpoolRider ( final WhirlpoolRider card )  { super ( card ) ; } @Override public WhirlpoolRider copy (  )  { return new WhirlpoolRider ( this ) ; } } 
public class WildResearch extends CardImpl { private static final FilterCard filterEnchantment = new FilterCard ( "enchantment card" ) ; private static final FilterCard filterInstant = new FilterCard ( "instant card" ) ; static { filterEnchantment . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filterInstant . add ( new CardTypePredicate ( CardType . INSTANT )  ) ; } public WildResearch ( UUID ownerId )  { super ( ownerId, 72, "Wild Research", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}" ) ; this . expansionSetCode = "APC"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new WildResearchEffect ( filterEnchantment ) , new ManaCostsImpl<> ( "{1}{W}" )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new WildResearchEffect ( filterInstant ) , new ManaCostsImpl<> ( "{1}{U}" )  )  ) ; } public WildResearch ( final WildResearch card )  { super ( card ) ; } @Override public WildResearch copy (  )  { return new WildResearch ( this ) ; } } class WildResearchEffect extends OneShotEffect { protected final FilterCard filter; WildResearchEffect ( FilterCard filter )  { super ( Outcome . DrawCard ) ; this . staticText = "Search your library for an " + filter . getMessage (  )  + " and reveal that card .  Put it into your hand, then discard a card at random .  Then shuffle your library . "; this . filter = filter; } WildResearchEffect ( final WildResearchEffect effect )  { super ( effect ) ; this . filter = effect . filter; } @Override public WildResearchEffect copy (  )  { return new WildResearchEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller != null && sourceObject != null )  { TargetCardInLibrary target = new TargetCardInLibrary ( filter ) ; if  ( controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { Card card = controller . getLibrary (  )  . remove ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { controller . moveCards ( card, null, Zone . HAND, source, game ) ; Cards cards = new CardsImpl (  ) ; cards . add ( card ) ; controller . revealCards ( sourceObject . getIdName (  ) , cards, game, true ) ; } } } controller . discardOne ( true, source, game ) ; controller . shuffleLibrary ( game ) ; return true; } return false; } } 
public class YavimayaCoast extends CardImpl { public YavimayaCoast ( UUID ownerId )  { super ( ownerId, 143, "Yavimaya Coast", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "APC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability greenManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . GreenMana ( 1 ) , new TapSourceCost (  )  ) ; greenManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( greenManaAbility ) ; Ability blueManaAbility = new SimpleManaAbility ( Zone . BATTLEFIELD, Mana . BlueMana ( 1 ) , new TapSourceCost (  )  ) ; blueManaAbility . addEffect ( new DamageControllerEffect ( 1 )  ) ; this . addAbility ( blueManaAbility ) ; } public YavimayaCoast ( final YavimayaCoast card )  { super ( card ) ; } @Override public YavimayaCoast copy (  )  { return new YavimayaCoast ( this ) ; } } 
public class YavimayasEmbrace extends CardImpl { public YavimayasEmbrace ( UUID ownerId )  { super ( ownerId, 127, "Yavimaya's Embrace", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{5}{G}{U}{U}" ) ; this . expansionSetCode = "APC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Detriment )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ControlEnchantedEffect (  )  )  ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 2, Duration . WhileOnBattlefield )  ) ; Effect effect = new GainAbilityAttachedEffect ( TrampleAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( "and has trample" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public YavimayasEmbrace ( final YavimayasEmbrace card )  { super ( card ) ; } @Override public YavimayasEmbrace copy (  )  { return new YavimayasEmbrace ( this ) ; } } 
public class AliBaba extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Wall" ) ; static { filter . add ( new SubtypePredicate ( "Wall" )  ) ; } public AliBaba ( UUID ownerId )  { super ( ownerId, 43, "Ali Baba", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new TapTargetEffect (  ) , new ManaCostsImpl ( "{R}" )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public AliBaba ( final AliBaba card )  { super ( card ) ; } @Override public AliBaba copy (  )  { return new AliBaba ( this ) ; } } 
public class AliFromCairo extends CardImpl { public AliFromCairo ( UUID ownerId )  { super ( ownerId, 44, "Ali from Cairo", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AliFromCairoReplacementEffect (  )  )  ) ; } public AliFromCairo ( final AliFromCairo card )  { super ( card ) ; } @Override public AliFromCairo copy (  )  { return new AliFromCairo ( this ) ; } } class AliFromCairoReplacementEffect extends ReplacementEffectImpl { public AliFromCairoReplacementEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Damage that would reduce your life total to less than 1 reduces it to 1 instead"; } public AliFromCairoReplacementEffect ( final AliFromCairoReplacementEffect effect )  { super ( effect ) ; } @Override public AliFromCairoReplacementEffect copy (  )  { return new AliFromCairoReplacementEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DAMAGE_CAUSES_LIFE_LOSS; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null &&  ( controller . getLife (  )  > 0 )  && ( controller . getLife (  )  - event . getAmount (  )  )  < 1 && event . getPlayerId (  )  . equals ( controller . getId (  )  )   )  { return true; } } return false; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { event . setAmount ( controller . getLife (  )  - 1 ) ; } return false; } } 
public class DiamondValley extends CardImpl { public DiamondValley ( UUID ownerId )  { super ( ownerId, 87, "Diamond Valley", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ARN"; Effect effect = new GainLifeEffect ( new SacrificeCostCreaturesToughness (  )  ) ; effect . setText ( "You gain life equal to the sacrificed creature's toughness" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new TapSourceCost (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; this . addAbility ( ability ) ; } public DiamondValley ( final DiamondValley card )  { super ( card ) ; } @Override public DiamondValley copy (  )  { return new DiamondValley ( this ) ; } } 
public class ElHajjaj extends CardImpl { public ElHajjaj ( UUID ownerId )  { super ( ownerId, 2, "El-Hajjaj", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DealsDamageGainLifeSourceTriggeredAbility (  )  ) ; } public ElHajjaj ( final ElHajjaj card )  { super ( card ) ; } @Override public ElHajjaj copy (  )  { return new ElHajjaj ( this ) ; } } 
public class FishliverOil1 extends CardImpl { public FishliverOil1 ( UUID ownerId )  { super ( ownerId, 17, "Fishliver Oil", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( new IslandwalkAbility (  ) , AttachmentType . AURA, Duration . WhileOnBattlefield )  )  ) ; } public FishliverOil1 ( final FishliverOil1 card )  { super ( card ) ; } @Override public FishliverOil1 copy (  )  { return new FishliverOil1 ( this ) ; } } 
public class IslandOfWakWak extends CardImpl { private static final FilterCreaturePermanent filterWithFlying = new FilterCreaturePermanent ( "creature with flying" ) ; static { filterWithFlying . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public IslandOfWakWak ( UUID ownerId )  { super ( ownerId, 89, "Island of Wak-Wak", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ARN"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new IslandOfWakWakEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( filterWithFlying )  ) ; this . addAbility ( ability ) ; } public IslandOfWakWak ( final IslandOfWakWak card )  { super ( card ) ; } @Override public IslandOfWakWak copy (  )  { return new IslandOfWakWak ( this ) ; } } class IslandOfWakWakEffect extends OneShotEffect { public IslandOfWakWakEffect (  )  { super ( Outcome . Detriment ) ; staticText = "The power of target creature with flying becomes 0 until end of turn"; } public IslandOfWakWakEffect ( final IslandOfWakWakEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent targetCreature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( targetCreature != null )  { MageInt toughness = targetCreature . getToughness (  ) ; game . addEffect ( new SetPowerToughnessTargetEffect ( 0, toughness . getValue (  ) , Duration . EndOfTurn ) , source ) ; return true; } return false; } @Override public Effect copy (  )  { return new IslandOfWakWakEffect ( this ) ; } } 
public class JuzamDjinn extends CardImpl { public JuzamDjinn ( UUID ownerId )  { super ( ownerId, 9, "Juzam Djinn", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}{B}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Djinn" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new DamageControllerEffect ( 1 ) , TargetController . YOU, false )  ) ; } public JuzamDjinn ( final JuzamDjinn card )  { super ( card ) ; } @Override public JuzamDjinn copy (  )  { return new JuzamDjinn ( this ) ; } } 
public class KingSuleiman extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "Djinn or Efreet" ) ; static { filter . add (  Predicates . or (  new SubtypePredicate ( "Djinn" ) , new SubtypePredicate ( "Efreet" )  )  ) ; } public KingSuleiman ( UUID ownerId )  { super ( ownerId, 61, "King Suleiman", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect (  ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( ability ) ; } public KingSuleiman ( final KingSuleiman card )  { super ( card ) ; } @Override public KingSuleiman copy (  )  { return new KingSuleiman ( this ) ; } } 
public class MerchantShip extends CardImpl { public MerchantShip ( UUID ownerId )  { super ( ownerId, 23, "Merchant Ship", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Human" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantAttackUnlessDefenderControllsPermanent ( new FilterLandPermanent ( "Island", "an Island" )  )  )  ) ; this . addAbility ( new AttacksAndIsNotBlockedTriggeredAbility ( new GainLifeEffect ( 2 )  )  ) ; this . addAbility ( new ControlsPermanentsControllerTriggeredAbility (  new FilterLandPermanent ( "Island", "no Islands" ) , Filter . ComparisonType . Equal, 0, new SacrificeSourceEffect (  )  )  ) ; } public MerchantShip ( final MerchantShip card )  { super ( card ) ; } @Override public MerchantShip copy (  )  { return new MerchantShip ( this ) ; } } 
public class NafsAsp extends CardImpl { public NafsAsp ( UUID ownerId )  { super ( ownerId, 36, "Nafs Asp", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{G}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Snake" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DealsDamageToAPlayerTriggeredAbility ( new UnlessPaysDelayedEffect (  new ManaCostsImpl ( "{1}" ) , new LoseLifeTargetEffect ( 1 ) , PhaseStep . DRAW, true, "that player loses 1 life at the beginning of his or her next draw step unless he or she pays {1} before that draw step . " ) , false, true )  ) ; } public NafsAsp ( final NafsAsp card )  { super ( card ) ; } @Override public NafsAsp copy (  )  { return new NafsAsp ( this ) ; } } 
public class OldManOfTheSea extends CardImpl { public OldManOfTheSea ( UUID ownerId )  { super ( ownerId, 24, "Old Man of the Sea", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{U}{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Djinn" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SkipUntapOptionalAbility (  )  ) ; FilterCreaturePermanent controllableCreatures = new FilterCreaturePermanent ( "creature with power less than or equal to Old Man of the Sea's power" ) ; controllableCreatures . add ( new PowerLowerEqualSourcePredicate ( this . getId (  )  )  ) ; ConditionalContinuousEffect effect = new ConditionalContinuousEffect (  new OldManOfTheSeaGainControlTargetEffect ( Duration . Custom, true ) , new CompoundCondition ( SourceTappedCondition . getInstance (  ) , new SourcePowerGreaterEqualTargetCondition (  )  ) , "Gain control of target creature with power less than or equal to {this}'s power for as long as {this} remains tapped and that creature's power remains less than or equal to {this}'s power" ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, effect, new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent ( controllableCreatures )  ) ; this . addAbility ( ability ) ; this . addAbility ( new OldManOfTheSeaStateBasedTriggeredAbility (  )  ) ; } public OldManOfTheSea ( final OldManOfTheSea card )  { super ( card ) ; } @Override public OldManOfTheSea copy (  )  { return new OldManOfTheSea ( this ) ; } } class OldManOfTheSeaGainControlTargetEffect extends GainControlTargetEffect { public OldManOfTheSeaGainControlTargetEffect ( Duration duration, boolean fixedControl )  { super ( duration, fixedControl ) ; } public OldManOfTheSeaGainControlTargetEffect ( final OldManOfTheSeaGainControlTargetEffect effect )  { super ( effect ) ; } @Override public void init ( Ability source, Game game )  { super . init ( source, game ) ; game . getState (  )  . setValue ( "target" + source . getSourceId (  ) , getTargetPointer (  )  . getFirst ( game, source )  ) ; } @Override public OldManOfTheSeaGainControlTargetEffect copy (  )  { return new OldManOfTheSeaGainControlTargetEffect ( this ) ; } } /* used a state based triggered effect here  ( not going to stack, so running hidden )  to compare power of the controlled creature to Old Man of the seas power .  It's not possible to do this as condition of continuous effect, because the time the effect checks its condition, the layered effects that modify power are not applied yet .  result is save to a state value to be available for the condition of the continuous effect */ class OldManOfTheSeaStateBasedTriggeredAbility extends StateTriggeredAbility { public OldManOfTheSeaStateBasedTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new InfoEffect ( "" )  ) ; this . setRuleVisible ( false ) ; this . usesStack = false; } public OldManOfTheSeaStateBasedTriggeredAbility ( final OldManOfTheSeaStateBasedTriggeredAbility ability )  { super ( ability ) ; } @Override public OldManOfTheSeaStateBasedTriggeredAbility copy (  )  { return new OldManOfTheSeaStateBasedTriggeredAbility ( this ) ; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { Permanent sourcePermanent = game . getPermanent ( getSourceId (  )  ) ; if  ( sourcePermanent != null && sourcePermanent . isTapped (  )  )  { UUID controlledCreatureId =  ( UUID )  game . getState (  )  . getValue ( "target" + getSourceId (  )  ) ; if  ( controlledCreatureId != null )  { Permanent controlledCreature = game . getPermanent ( controlledCreatureId ) ; if  ( controlledCreature != null )  { if  ( controlledCreature . getPower (  )  . getValue (  )  > sourcePermanent . getPower (  )  . getValue (  )  )  { game . getState (  )  . setValue ( "powerCondition" + getSourceId (  ) , Boolean . TRUE ) ; } } } } return false; } } class SourcePowerGreaterEqualTargetCondition implements Condition { @Override public boolean apply ( Game game, Ability source )  { Object object = game . getState (  )  . getValue ( "powerCondition" + source . getSourceId (  )  ) ; if  ( object != null &&  ( Boolean )  object )  { game . getState (  )  . setValue ( "powerCondition" + source . getSourceId (  ) , Boolean . FALSE ) ; game . getState (  )  . setValue ( "target" + source . getSourceId (  ) , null ) ; return false; } return true; } } class PowerLowerEqualSourcePredicate implements ObjectPlayerPredicate<ObjectPlayer<Permanent>> { UUID sourceId; public PowerLowerEqualSourcePredicate ( UUID sourceId )  { this . sourceId = sourceId; } @Override public boolean apply ( ObjectPlayer<Permanent> input, Game game )  { Permanent sourcePermanent = game . getPermanent ( sourceId ) ; Permanent permanent = input . getObject (  ) ; if  ( permanent != null && sourcePermanent != null )  { if  ( permanent . getPower (  )  . getValue (  )  <= sourcePermanent . getPower (  )  . getValue (  )  )  { return true; } } return false; } @Override public String toString (  )  { return "creature with power less than or equal to {source}'s power"; } } 
public class RukhEgg1 extends CardImpl { public RukhEgg1 ( UUID ownerId )  { super ( ownerId, 52, "Rukh Egg", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 3 ) ; Effect effect = new CreateDelayedTriggeredAbilityEffect ( new AtTheBeginOfNextEndStepDelayedTriggeredAbility ( new CreateTokenEffect ( new BirdToken (  )  )  )  ) ; effect . setText ( "put a 4/4 red Bird creature token with flying onto the battlefield at the beginning of the next end step" ) ; Ability ability = new DiesTriggeredAbility ( effect ) ; this . addAbility ( ability ) ; } public RukhEgg1 ( final RukhEgg1 card )  { super ( card ) ; } @Override public RukhEgg1 copy (  )  { return new RukhEgg1 ( this ) ; } } class BirdToken extends Token { public BirdToken (  )  { this ( "ARN" ) ;  
public class StoneThrowingDevils1 extends CardImpl { public StoneThrowingDevils1 ( UUID ownerId )  { super ( ownerId, 14, "Stone-Throwing Devils", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Devil" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; } public StoneThrowingDevils1 ( final StoneThrowingDevils1 card )  { super ( card ) ; } @Override public StoneThrowingDevils1 copy (  )  { return new StoneThrowingDevils1 ( this ) ; } } 
public class UnstableMutation extends CardImpl { public UnstableMutation ( UUID ownerId )  { super ( ownerId, 28, "Unstable Mutation", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{U}" ) ; this . expansionSetCode = "ARN"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 3, 3 )  )  ) ; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new AddCountersAttachedEffect ( CounterType . M1M1 . createInstance (  ) , "that creature" ) , TargetController . CONTROLLER_ATTACHED_TO, false )  ) ; } public UnstableMutation ( final UnstableMutation card )  { super ( card ) ; } @Override public UnstableMutation copy (  )  { return new UnstableMutation ( this ) ; } } 
public class AvatarOfWoe extends CardImpl { public AvatarOfWoe ( UUID ownerId )  { super ( ownerId, 9, "Avatar of Woe", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{B}{B}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Avatar" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . STACK, new AvatarOfWoeCostReductionEffect (  )  )  ) ; this . addAbility ( FearAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DestroyTargetEffect ( true ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public AvatarOfWoe ( final AvatarOfWoe card )  { super ( card ) ; } @Override public AvatarOfWoe copy (  )  { return new AvatarOfWoe ( this ) ; } } class AvatarOfWoeCostReductionEffect extends CostModificationEffectImpl { AvatarOfWoeCostReductionEffect (  )  { super ( Duration . Custom, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "If there are ten or more creature cards total in all graveyards, {this} costs {6} less to cast"; } AvatarOfWoeCostReductionEffect ( final AvatarOfWoeCostReductionEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { SpellAbility spellAbility =  ( SpellAbility )  abilityToModify; Mana mana = spellAbility . getManaCostsToPay (  )  . getMana (  ) ; if  ( mana . getGeneric (  )  > 0 )  { int newCount = mana . getGeneric (  )  - 6; if  ( newCount < 0 )  { newCount = 0; } mana . setGeneric ( newCount ) ; spellAbility . getManaCostsToPay (  )  . load ( mana . toString (  )  ) ; return true; } return false; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { return abilityToModify . getSourceId (  )  . equals ( source . getSourceId (  )  )  &&  ( abilityToModify instanceof SpellAbility )  && new CardsInAllGraveyardsCount ( new FilterCreatureCard (  )  )  . calculate ( game, source, this )  >= 10; } @Override public AvatarOfWoeCostReductionEffect copy (  )  { return new AvatarOfWoeCostReductionEffect ( this ) ; } } 
public class BatteringCraghorn extends CardImpl { public BatteringCraghorn ( UUID ownerId )  { super ( ownerId, 30, "Battering Craghorn", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Goat" ) ; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{1}{R}{R}" )  )  ) ; } public BatteringCraghorn ( final BatteringCraghorn card )  { super ( card ) ; } @Override public BatteringCraghorn copy (  )  { return new BatteringCraghorn ( this ) ; } } 
public class DragonBreath extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "a creature with converted mana cost 6 or greater" ) ; static { filter . add ( new ConvertedManaCostPredicate ( ComparisonType . GreaterThan, 5 )  ) ; } public DragonBreath ( UUID ownerId )  { super ( ownerId, 33, "Dragon Breath", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( HasteAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1, 0, Duration . EndOfTurn ) , new ColoredManaCost ( ColoredManaSymbol . R )  )  ) ; this . addAbility ( new EntersBattlefieldAllTriggeredAbility ( Zone . GRAVEYARD, new DragonBreathEffect (  ) , filter, true, SetTargetPointer . PERMANENT, null )  ) ; } public DragonBreath ( final DragonBreath card )  { super ( card ) ; } @Override public DragonBreath copy (  )  { return new DragonBreath ( this ) ; } } class DragonBreathEffect extends OneShotEffect { DragonBreathEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "return {this} from your graveyard to the battlefield attached to that creature"; } DragonBreathEffect ( final DragonBreathEffect effect )  { super ( effect ) ; } @Override public DragonBreathEffect copy (  )  { return new DragonBreathEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card sourceCard =  ( Card )  source . getSourceObjectIfItStillExists ( game ) ; Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( sourceCard != null && permanent != null && controller != null )  { game . getState (  )  . setValue ( "attachTo:" + sourceCard . getId (  ) , permanent ) ; if  ( controller . moveCards ( sourceCard, Zone . BATTLEFIELD, source, game )  )  { permanent . addAttachment ( sourceCard . getId (  ) , game ) ; } return true; } return false; } } 
public class ImperialHellkite extends CardImpl { public ImperialHellkite ( UUID ownerId )  { super ( ownerId, 42, "Imperial Hellkite", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{R}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new MorphAbility ( this, new ManaCostsImpl ( "{6}{R}{R}" )  )  ) ; Effect effect = new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( 0, 1, new FilterBySubtypeCard ( "Dragon" )  ) , true, true ) ; effect . setText ( "you may search your library for a Dragon card, reveal it, and put it into your hand .  If you do, shuffle your library" ) ; this . addAbility ( new TurnedFaceUpSourceTriggeredAbility ( effect )  ) ; } public ImperialHellkite ( final ImperialHellkite card )  { super ( card ) ; } @Override public ImperialHellkite copy (  )  { return new ImperialHellkite ( this ) ; } } 
public class MakeshiftMannequin extends CardImpl { public MakeshiftMannequin ( UUID ownerId )  { super ( ownerId, 20, "Makeshift Mannequin", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{B}" ) ; this . expansionSetCode = "ARC"; this . getSpellAbility (  )  . addEffect ( new MakeshiftMannequinEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "creature card from your graveyard" )  )  ) ; } public MakeshiftMannequin ( final MakeshiftMannequin card )  { super ( card ) ; } @Override public MakeshiftMannequin copy (  )  { return new MakeshiftMannequin ( this ) ; } } class MakeshiftMannequinEffect extends OneShotEffect { MakeshiftMannequinEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; this . staticText = "Return target creature card from your graveyard to the battlefield with a mannequin counter on it .  For as long as that creature has a mannequin counter on it, it has \"When this creature becomes the target of a spell or ability, sacrifice it . \""; } MakeshiftMannequinEffect ( final MakeshiftMannequinEffect effect )  { super ( effect ) ; } @Override public MakeshiftMannequinEffect copy (  )  { return new MakeshiftMannequinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { UUID cardId = this . getTargetPointer (  )  . getFirst ( game, source ) ; Card card = controller . getGraveyard (  )  . get ( cardId, game ) ; if  ( card != null )  { Counters counters = new Counters (  ) ; counters . addCounter ( CounterType . MANNEQUIN . createInstance (  )  ) ; game . setEnterWithCounters ( cardId, counters ) ; if  ( controller . moveCards ( card, Zone . BATTLEFIELD, source, game )  )  { Permanent permanent = game . getPermanent ( cardId ) ; if  ( permanent != null )  { ContinuousEffect gainedEffect = new MakeshiftMannequinGainAbilityEffect (  ) ; gainedEffect . setTargetPointer ( new FixedTarget ( permanent, game )  ) ; game . addEffect ( gainedEffect, source ) ; } } return true; } } return false; } } class MakeshiftMannequinGainAbilityEffect extends ContinuousEffectImpl { MakeshiftMannequinGainAbilityEffect (  )  { super ( Duration . Custom, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; } MakeshiftMannequinGainAbilityEffect ( final MakeshiftMannequinGainAbilityEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( permanent != null )  { permanent . addAbility ( new BecomesTargetTriggeredAbility ( new SacrificeSourceEffect (  )  ) , source . getSourceId (  ) , game ) ; return true; } return false; } @Override public boolean isInactive ( Ability source, Game game )  { Permanent permanent = game . getPermanent ( this . getTargetPointer (  )  . getFirst ( game, source )  ) ; return permanent == null || permanent . getCounters (  )  . getCount ( CounterType . MANNEQUIN )  < 1; } @Override public MakeshiftMannequinGainAbilityEffect copy (  )  { return new MakeshiftMannequinGainAbilityEffect ( this ) ; } } 
public class NantukoMonastery extends CardImpl { public NantukoMonastery ( UUID ownerId )  { super ( ownerId, 131, "Nantuko Monastery", Rarity . UNCOMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "ARC"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new ConditionalActivatedAbility ( Zone . BATTLEFIELD, new BecomesCreatureSourceEffect (  new NantukoMonasteryToken (  ) , "land", Duration . EndOfTurn ) , new ManaCostsImpl<> ( "{G}{W}" ) , new CardsInControllerGraveCondition ( 7 )  ) ; ability . setAbilityWord ( AbilityWord . THRESHOLD ) ; this . addAbility ( ability ) ; } public NantukoMonastery ( final NantukoMonastery card )  { super ( card ) ; } @Override public NantukoMonastery copy (  )  { return new NantukoMonastery ( this ) ; } } class NantukoMonasteryToken extends Token { public NantukoMonasteryToken (  )  { super ( "", "4/4 green and white Insect Monk creature with first strike" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Insect" ) ; subtype . add ( "Monk" ) ; color . setGreen ( true ) ; color . setWhite ( true ) ; power = new MageInt ( 4 ) ; toughness = new MageInt ( 4 ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; } } 
public class SpinIntoMyth extends CardImpl { public SpinIntoMyth ( UUID ownerId )  { super ( ownerId, 8, "Spin into Myth", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{4}{U}" ) ; this . expansionSetCode = "ARC"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; Effect effect = new FatesealEffect ( 2 ) ; effect . setText ( ", then fateseal 2 .  <i> ( To fateseal 2, look at the top two cards of an opponent's library, then put any number of them on the bottom of that player's library and the rest on top in any order .  ) </i>" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; } public SpinIntoMyth ( final SpinIntoMyth card )  { super ( card ) ; } @Override public SpinIntoMyth copy (  )  { return new SpinIntoMyth ( this ) ; } } 
public class VampiricDragon extends CardImpl { public VampiricDragon ( UUID ownerId )  { super ( ownerId, 99, "Vampiric Dragon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{6}{B}{R}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new DiesAndDealtDamageThisTurnTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new ManaCostsImpl ( "{1}{R}" )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public VampiricDragon ( final VampiricDragon card )  { super ( card ) ; } @Override public VampiricDragon copy (  )  { return new VampiricDragon ( this ) ; } } 
public class YavimayaDryad extends CardImpl { private static final FilterLandCard filter = new FilterLandCard ( "a Forest card" ) ; static { filter . add ( new SubtypePredicate ( "Forest" )  ) ; } public YavimayaDryad ( UUID ownerId )  { super ( ownerId, 75, "Yavimaya Dryad", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "ARC"; this . subtype . add ( "Dryad" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new ForestwalkAbility (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new YavimayaDryadEffect ( new TargetCardInLibrary ( filter )  ) , true ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public YavimayaDryad ( final YavimayaDryad card )  { super ( card ) ; } @Override public YavimayaDryad copy (  )  { return new YavimayaDryad ( this ) ; } } class YavimayaDryadEffect extends SearchEffect { public YavimayaDryadEffect ( TargetCardInLibrary target )  { super ( target, Outcome . PutLandInPlay ) ; staticText = "you may search your library for a Forest card and put it onto the battlefield tapped under target player's control .  If you do, shuffle your library"; } public YavimayaDryadEffect ( final YavimayaDryadEffect effect )  { super ( effect ) ; } @Override public YavimayaDryadEffect copy (  )  { return new YavimayaDryadEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( getTargetPointer (  )  . getFirst ( game, source )  ) ; if  ( controller == null || targetPlayer == null )  { return false; } if  ( controller . searchLibrary ( target, game )  )  { if  ( target . getTargets (  )  . size (  )  > 0 )  { targetPlayer . moveCards ( new CardsImpl ( target . getTargets (  )  )  . getCards ( game ) , Zone . BATTLEFIELD, source, game, true, false, false, null ) ; } controller . shuffleLibrary ( game ) ; return true; } return false; } } 
public class AbundantGrowth extends CardImpl { public AbundantGrowth ( UUID ownerId )  { super ( ownerId, 167, "Abundant Growth", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetLandPermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Benefit )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , false )  ) ; Ability gainedAbility = new AnyColorManaAbility ( new TapSourceCost (  )  ) ; Effect effect = new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA ) ; effect . setText ( "Enchanted land has \"{T}: Add one mana of any color to your mana pool . \"" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public AbundantGrowth ( final AbundantGrowth card )  { super ( card ) ; } @Override public AbundantGrowth copy (  )  { return new AbundantGrowth ( this ) ; } } 
public class Aggravate extends CardImpl { public Aggravate ( UUID ownerId )  { super ( ownerId, 125, "Aggravate", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{3}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new AggravateEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new AggravateRequirementEffect (  )  ) ; this . getSpellAbility (  )  . addWatcher ( new DamagedByWatcher (  )  ) ; } public Aggravate ( final Aggravate card )  { super ( card ) ; } @Override public Aggravate copy (  )  { return new Aggravate ( this ) ; } } class AggravateEffect extends OneShotEffect { public AggravateEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "{this} deals 1 damage to each creature target player controls"; } public AggravateEffect ( final AggravateEffect effect )  { super ( effect ) ; } @Override public AggravateEffect copy (  )  { return new AggravateEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null )  { FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; filter . add ( new ControllerIdPredicate ( player . getId (  )  )  ) ; List<Permanent> creatures = game . getBattlefield (  )  . getActivePermanents ( filter, source . getControllerId (  ) , source . getSourceId (  ) , game ) ; for  ( Permanent creature : creatures )  { creature . damage ( 1, source . getSourceId (  ) , game, false, true ) ; } return true; } return false; } } class AggravateRequirementEffect extends RequirementEffect { public AggravateRequirementEffect (  )  { super ( Duration . EndOfTurn ) ; this . staticText = "Each creature dealt damage this way attacks this turn if able"; } public AggravateRequirementEffect ( final AggravateRequirementEffect effect )  { super ( effect ) ; } @Override public AggravateRequirementEffect copy (  )  { return new AggravateRequirementEffect ( this ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { DamagedByWatcher watcher =  ( DamagedByWatcher )  game . getState (  )  . getWatchers (  )  . get ( "DamagedByWatcher", source . getSourceId (  )  ) ; if  ( watcher != null )  { return watcher . wasDamaged ( permanent, game ) ; } return false; } @Override public boolean mustAttack ( Game game )  { return true; } @Override public boolean mustBlock ( Game game )  { return false; } } 
public class AlchemistsApprentice extends CardImpl { public AlchemistsApprentice ( UUID ownerId )  { super ( ownerId, 42, "Alchemist's Apprentice", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new SacrificeSourceCost (  )  )  ) ; } public AlchemistsApprentice ( final AlchemistsApprentice card )  { super ( card ) ; } @Override public AlchemistsApprentice copy (  )  { return new AlchemistsApprentice ( this ) ; } } 
public class AlchemistsRefuge extends CardImpl { private static final FilterCard filter = new FilterCard ( "nonland cards" ) ; static { filter . add ( Predicates . not ( new CardTypePredicate ( CardType . LAND )  )  ) ; } public AlchemistsRefuge ( UUID ownerId )  { super ( ownerId, 225, "Alchemist's Refuge", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new ColorlessManaAbility (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddContinuousEffectToGame ( new CastAsThoughItHadFlashAllEffect ( Duration . EndOfTurn, filter )  ) , new CompositeCost ( new ManaCostsImpl ( "{G}{U}" ) , new TapSourceCost (  ) , "{G}{U}, {T}" )  )  ) ; } public AlchemistsRefuge ( final AlchemistsRefuge card )  { super ( card ) ; } @Override public AlchemistsRefuge copy (  )  { return new AlchemistsRefuge ( this ) ; } } 
public class AmassTheComponents extends CardImpl { public AmassTheComponents ( UUID ownerId )  { super ( ownerId, 43, "Amass the Components", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new AmassTheComponentsEffect (  )  ) ; } public AmassTheComponents ( final AmassTheComponents card )  { super ( card ) ; } @Override public AmassTheComponents copy (  )  { return new AmassTheComponents ( this ) ; } } class AmassTheComponentsEffect extends OneShotEffect { public AmassTheComponentsEffect (  )  { super ( Outcome . DrawCard ) ; this . staticText = "Draw three cards, then put a card from your hand on the bottom of your library"; } public AmassTheComponentsEffect ( final AmassTheComponentsEffect effect )  { super ( effect ) ; } @Override public AmassTheComponentsEffect copy (  )  { return new AmassTheComponentsEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player == null )  { return false; } player . drawCards ( 3, game ) ; if  ( player . getHand (  )  . size (  )  > 0 )  { FilterCard filter = new FilterCard ( "card from your hand to put on the bottom of your library" ) ; TargetCard target = new TargetCard ( Zone . HAND, filter ) ; if  ( player . choose ( Outcome . Detriment, player . getHand (  ) , target, game )  )  { Card card = player . getHand (  )  . get ( target . getFirstTarget (  ) , game ) ; if  ( card != null )  { player . removeFromHand ( card, game ) ; card . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } } } return true; } } 
public class AngelicArmaments extends CardImpl { public AngelicArmaments ( UUID ownerId )  { super ( ownerId, 212, "Angelic Armaments", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 2, 2 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardColorAttachedEffect ( ObjectColor . WHITE, Duration . WhileOnBattlefield, AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardSubtypeAttachedEffect ( "Angel", Duration . WhileOnBattlefield, AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . BoostCreature, new GenericManaCost ( 4 )  )  ) ; } public AngelicArmaments ( final AngelicArmaments card )  { super ( card ) ; } @Override public AngelicArmaments copy (  )  { return new AngelicArmaments ( this ) ; } } 
public class AngelOfGlorysRise extends CardImpl { public AngelOfGlorysRise ( UUID ownerId )  { super ( ownerId, 1, "Angel of Glory's Rise", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{5}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new AngelOfGlorysRiseEffect (  )  ) ; this . addAbility ( ability ) ; } public AngelOfGlorysRise ( final AngelOfGlorysRise card )  { super ( card ) ; } @Override public AngelOfGlorysRise copy (  )  { return new AngelOfGlorysRise ( this ) ; } } class AngelOfGlorysRiseEffect extends OneShotEffect { private static final FilterCreatureCard filterHuman = new FilterCreatureCard (  ) ; private static final FilterCreaturePermanent filterZombie = new FilterCreaturePermanent (  ) ; static { filterZombie . add ( new SubtypePredicate ( "Zombie" )  ) ; filterHuman . add ( new SubtypePredicate ( "Human" )  ) ; } public AngelOfGlorysRiseEffect (  )  { super ( Outcome . PutCreatureInPlay ) ; staticText = "Exile all Zombies, then return all Human creature cards from your graveyard to the battlefield"; } public AngelOfGlorysRiseEffect ( final AngelOfGlorysRiseEffect effect )  { super ( effect ) ; } @Override public AngelOfGlorysRiseEffect copy (  )  { return new AngelOfGlorysRiseEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { for  ( Permanent zombie : game . getBattlefield (  )  . getActivePermanents ( filterZombie, source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { zombie . moveToExile ( source . getSourceId (  ) , zombie . getName (  ) , source . getSourceId (  ) , game ) ; } for  ( Card human : player . getGraveyard (  )  . getCards ( filterHuman, game )  )  { human . putOntoBattlefield ( game, Zone . GRAVEYARD, source . getSourceId (  ) , source . getControllerId (  )  ) ; } } return true; } } 
public class AngelOfJubilation extends CardImpl { private static final FilterCreaturePermanent filterNonBlack = new FilterCreaturePermanent ( "nonblack creatures" ) ; static { filterNonBlack . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public AngelOfJubilation ( UUID ownerId )  { super ( ownerId, 2, "Angel of Jubilation", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1, 1, Duration . WhileOnBattlefield, filterNonBlack, true )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AngelOfJubilationEffect ( Duration . WhileOnBattlefield )  )  ) ; } public AngelOfJubilation ( final AngelOfJubilation card )  { super ( card ) ; } @Override public AngelOfJubilation copy (  )  { return new AngelOfJubilation ( this ) ; } } class AngelOfJubilationEffect extends ContinuousEffectImpl { public AngelOfJubilationEffect ( Duration duration )  { super ( duration, Layer . PlayerEffects, SubLayer . NA, Outcome . Detriment ) ; staticText = "Players can't pay life or sacrifice creatures to cast spells or activate abilities"; } public AngelOfJubilationEffect ( final AngelOfJubilationEffect effect )  { super ( effect ) ; } @Override public AngelOfJubilationEffect copy (  )  { return new AngelOfJubilationEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { for  ( Player player : game . getPlayers (  )  . values (  )  )  { player . setCanPayLifeCost ( false ) ; player . setCanPaySacrificeCost ( false ) ; } return true; } } 
public class AngelsTomb extends CardImpl { public AngelsTomb ( UUID ownerId )  { super ( ownerId, 211, "Angel's Tomb", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new CreatureEntersBattlefieldTriggeredAbility ( new BecomesCreatureSourceEffect ( new AngelTombToken (  ) , "", Duration . EndOfTurn ) , true )  ) ; } public AngelsTomb ( final AngelsTomb card )  { super ( card ) ; } @Override public AngelsTomb copy (  )  { return new AngelsTomb ( this ) ; } } class AngelTombToken extends Token { public AngelTombToken (  )  { super ( "", "a 3/3 white Angel artifact creature with flying" ) ; cardType . add ( CardType . ARTIFACT ) ; cardType . add ( CardType . CREATURE ) ; color . setWhite ( true ) ; subtype . add ( "Angel" ) ; power = new MageInt ( 3 ) ; toughness = new MageInt ( 3 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class AppetiteForBrains extends CardImpl { private static final FilterCard filter = new FilterCard ( "a card from it with converted mana cost 4 or greater" ) ; static { filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . GreaterThan, 3 )  ) ; } public AppetiteForBrains ( UUID ownerId )  { super ( ownerId, 84, "Appetite for Brains", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ExileCardYouChooseTargetOpponentEffect ( filter )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public AppetiteForBrains ( final AppetiteForBrains card )  { super ( card ) ; } @Override public AppetiteForBrains copy (  )  { return new AppetiteForBrains ( this ) ; } } 
public class ArcaneMelee extends CardImpl { public ArcaneMelee ( UUID ownerId )  { super ( ownerId, 44, "Arcane Melee", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{4}{U}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ArcaneMeleeCostReductionEffect (  )  )  ) ; } public ArcaneMelee ( final ArcaneMelee card )  { super ( card ) ; } @Override public ArcaneMelee copy (  )  { return new ArcaneMelee ( this ) ; } } class ArcaneMeleeCostReductionEffect extends CostModificationEffectImpl { ArcaneMeleeCostReductionEffect  (   )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "Instant and sorcery spells cost {2} less to cast"; } ArcaneMeleeCostReductionEffect ( ArcaneMeleeCostReductionEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { SpellAbility spellAbility =  ( SpellAbility )  abilityToModify; CardUtil . adjustCost ( spellAbility, 2 ) ; return true; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { if  (  abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility )  { Card sourceCard = game . getCard (  (  ( SpellAbility ) abilityToModify )  . getSourceId (  )  ) ; if  (  sourceCard != null &&  ( sourceCard . getCardType (  )  . contains ( CardType . INSTANT )  || sourceCard . getCardType (  )  . contains ( CardType . SORCERY )  )  )  { return true; } } return false; } @Override public ArcaneMeleeCostReductionEffect copy (  )  { return new ArcaneMeleeCostReductionEffect ( this ) ; } } 
public class Archangel extends CardImpl { public Archangel ( UUID ownerId )  { super ( ownerId, 5, "Archangel", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; } public Archangel ( final Archangel card )  { super ( card ) ; } @Override public Archangel copy (  )  { return new Archangel ( this ) ; } } 
public class ArchwingDragon extends CardImpl { public ArchwingDragon ( UUID ownerId )  { super ( ownerId, 126, "Archwing Dragon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Dragon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; this . addAbility ( new OnEventTriggeredAbility ( GameEvent . EventType . END_TURN_STEP_PRE, "beginning of the end step", new ReturnToHandSourceEffect ( true ) , false )  ) ; } public ArchwingDragon ( final ArchwingDragon card )  { super ( card ) ; } @Override public ArchwingDragon copy (  )  { return new ArchwingDragon ( this ) ; } } 
public class AvacynAngelOfHope extends CardImpl { public AvacynAngelOfHope ( UUID ownerId )  { super ( ownerId, 6, "Avacyn, Angel of Hope", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{5}{W}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 8 ) ; this . toughness = new MageInt ( 8 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( IndestructibleAbility . getInstance (  )  ) ; FilterControlledPermanent filter = new FilterControlledPermanent ( "Other permanents you control" ) ; Effect effect = new GainAbilityAllEffect ( IndestructibleAbility . getInstance (  ) , Duration . WhileOnBattlefield, filter, true ) ; effect . setText ( "Other permanents you control are indestructible" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, effect )  ) ; } public AvacynAngelOfHope ( final AvacynAngelOfHope card )  { super ( card ) ; } @Override public AvacynAngelOfHope copy (  )  { return new AvacynAngelOfHope ( this ) ; } } 
public class BanishingStroke extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "artifact, creature, or enchantment" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . ARTIFACT ) , new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . ENCHANTMENT )  )  ) ; } public BanishingStroke ( UUID ownerId )  { super ( ownerId, 7, "Banishing Stroke", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{5}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new PutOnLibraryTargetEffect ( false )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{W}" )  )  ) ; } public BanishingStroke ( final BanishingStroke card )  { super ( card ) ; } @Override public BanishingStroke copy (  )  { return new BanishingStroke ( this ) ; } } 
public class BattleHymn extends CardImpl { public BattleHymn ( UUID ownerId )  { super ( ownerId, 128, "Battle Hymn", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DynamicManaEffect ( Mana . RedMana ( 1 ) , new PermanentsOnBattlefieldCount ( new FilterControlledCreaturePermanent (  )  )  )  ) ; } public BattleHymn ( final BattleHymn card )  { super ( card ) ; } @Override public BattleHymn copy (  )  { return new BattleHymn ( this ) ; } } 
public class BladedBracers extends CardImpl { private static final String ruleText = "As long as equipped creature is a Human or an Angel, it has vigilance"; public BladedBracers ( UUID ownerId )  { super ( ownerId, 213, "Bladed Bracers", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEquippedEffect ( 1, 1 )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ConditionalContinuousEffect (  new GainAbilityAttachedEffect ( VigilanceAbility . getInstance (  ) , AttachmentType . EQUIPMENT ) , new EquippedHasSubtypeCondition ( "Human", "Angel" ) , ruleText )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . BoostCreature, new GenericManaCost ( 2 )  )  ) ; } public BladedBracers ( final BladedBracers card )  { super ( card ) ; } @Override public BladedBracers copy (  )  { return new BladedBracers ( this ) ; } } 
public class BlessingsOfNature extends CardImpl { public BlessingsOfNature ( UUID ownerId )  { super ( ownerId, 168, "Blessings of Nature", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DistributeCountersEffect ( CounterType . P1P1, 4, false, "any number of target creatures" )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanentAmount ( 4 )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{G}" )  )  ) ; } public BlessingsOfNature ( final BlessingsOfNature card )  { super ( card ) ; } @Override public BlessingsOfNature copy (  )  { return new BlessingsOfNature ( this ) ; } } 
public class BloodArtist extends CardImpl { public BloodArtist ( UUID ownerId )  { super ( ownerId, 86, "Blood Artist", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new DiesThisOrAnotherCreatureTriggeredAbility ( new LoseLifeTargetEffect ( 1 ) , false ) ; ability . addEffect ( new GainLifeEffect ( 1 )  ) ; Target target = new TargetPlayer (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public BloodArtist ( final BloodArtist card )  { super ( card ) ; } @Override public BloodArtist copy (  )  { return new BloodArtist ( this ) ; } } 
public class BloodflowConnoisseur extends CardImpl { public BloodflowConnoisseur ( UUID ownerId )  { super ( ownerId, 87, "Bloodflow Connoisseur", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , new ManaCostsImpl (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; this . addAbility ( ability ) ; } public BloodflowConnoisseur ( final BloodflowConnoisseur card )  { super ( card ) ; } @Override public BloodflowConnoisseur copy (  )  { return new BloodflowConnoisseur ( this ) ; } } 
public class BonfireOfTheDamned extends CardImpl { public BonfireOfTheDamned ( UUID ownerId )  { super ( ownerId, 129, "Bonfire of the Damned", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{X}{X}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new BonfireOfTheDamnedEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{X}{R}" )  )  ) ; } public BonfireOfTheDamned ( final BonfireOfTheDamned card )  { super ( card ) ; } @Override public BonfireOfTheDamned copy (  )  { return new BonfireOfTheDamned ( this ) ; } } class BonfireOfTheDamnedEffect extends OneShotEffect { private static FilterPermanent filter = new FilterCreaturePermanent (  ) ; public BonfireOfTheDamnedEffect (  )  { super ( Outcome . Damage ) ; staticText = "{this} deals X damage to target player and each creature he or she controls"; } public BonfireOfTheDamnedEffect ( final BonfireOfTheDamnedEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null )  { int damage = source . getManaCostsToPay (  )  . getX (  ) ; if  ( damage > 0 )  { player . damage ( damage, source . getSourceId (  ) , game, false, true ) ; for  ( Permanent perm: game . getBattlefield (  )  . getAllActivePermanents ( filter, player . getId (  ) , game )  )  { perm . damage ( damage, source . getSourceId (  ) , game, false, true ) ; } } return true; } return false; } @Override public BonfireOfTheDamnedEffect copy (  )  { return new BonfireOfTheDamnedEffect ( this ) ; } } 
public class BowerPassage extends CardImpl { public BowerPassage ( UUID ownerId )  { super ( ownerId, 170, "Bower Passage", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BowerPassageEffect (  )  )  ) ; } public BowerPassage ( final BowerPassage card )  { super ( card ) ; } @Override public BowerPassage copy (  )  { return new BowerPassage ( this ) ; } } class BowerPassageEffect extends RestrictionEffect { BowerPassageEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "Creatures with flying can't block creatures you control"; } BowerPassageEffect ( final BowerPassageEffect effect )  { super ( effect ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { return true; } @Override public BowerPassageEffect copy (  )  { return new BowerPassageEffect ( this ) ; } @Override public boolean canBlock ( Permanent attacker, Permanent blocker, Ability source, Game game )  { if  ( attacker != null && attacker . getControllerId (  )  . equals ( source . getControllerId (  )  )  && blocker . getAbilities (  )  . contains ( FlyingAbility . getInstance (  )  )  )  { return false; } return true; } } 
public class BrunaLightOfAlabaster extends CardImpl { public BrunaLightOfAlabaster ( UUID ownerId )  { super ( ownerId, 208, "Bruna, Light of Alabaster", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{W}{W}{U}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( new AttacksOrBlocksTriggeredAbility ( new BrunaLightOfAlabasterEffect (  ) , true )  ) ; } public BrunaLightOfAlabaster ( final BrunaLightOfAlabaster card )  { super ( card ) ; } @Override public BrunaLightOfAlabaster copy (  )  { return new BrunaLightOfAlabaster ( this ) ; } } class BrunaLightOfAlabasterEffect extends OneShotEffect { public BrunaLightOfAlabasterEffect (  )  { super ( Outcome . Benefit ) ; this . staticText = "attach to it any number of Auras on the battlefield and you may put onto the battlefield attached to it any number of Aura cards that could enchant it from your graveyard and/or hand"; } public BrunaLightOfAlabasterEffect ( final BrunaLightOfAlabasterEffect effect )  { super ( effect ) ; } @Override public BrunaLightOfAlabasterEffect copy (  )  { return new BrunaLightOfAlabasterEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID bruna = source . getSourceId (  ) ; Player player = game . getPlayer ( source . getControllerId (  )  ) ; FilterPermanent filterAura = new FilterPermanent ( "Aura" ) ; FilterCard filterAuraCard = new FilterCard ( "Aura card" ) ; filterAura . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filterAura . add ( new SubtypePredicate ( "Aura" )  ) ; filterAura . add ( new AuraPermanentCanAttachToPermanentId ( bruna )  ) ; filterAuraCard . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; filterAuraCard . add ( new SubtypePredicate ( "Aura" )  ) ; filterAuraCard . add ( new AuraCardCanAttachToPermanentId ( bruna )  ) ; if  ( player == null )  { return false; } Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent == null )  { return false; } while  ( player . canRespond (  )  && player . chooseUse ( Outcome . Benefit, "Attach an Aura from the battlefield?", source, game )  )  { Target targetAura = new TargetPermanent ( filterAura ) ; if  ( player . choose ( Outcome . Benefit, targetAura, source . getSourceId (  ) , game )  )  { Permanent aura = game . getPermanent ( targetAura . getFirstTarget (  )  ) ; if  ( aura != null )  { Permanent attachedTo = game . getPermanent ( aura . getAttachedTo (  )  ) ; if  ( attachedTo != null )  { attachedTo . removeAttachment ( aura . getId (  ) , game ) ; } permanent . addAttachment ( aura . getId (  ) , game ) ; } } } int count = player . getHand (  )  . count ( filterAuraCard, game ) ; while  ( player . canRespond (  )  && count > 0 && player . chooseUse ( Outcome . Benefit, "Attach an Aura from your hand?", source, game )  )  { TargetCard targetAura = new TargetCard ( Zone . HAND, filterAuraCard ) ; if  ( player . choose ( Outcome . Benefit, player . getHand (  ) , targetAura, game )  )  { Card aura = game . getCard ( targetAura . getFirstTarget (  )  ) ; if  ( aura != null )  { game . getState (  )  . setValue ( "attachTo:" + aura . getId (  ) , permanent ) ; aura . putOntoBattlefield ( game, Zone . HAND, source . getSourceId (  ) , player . getId (  )  ) ; permanent . addAttachment ( aura . getId (  ) , game ) ; } } count = player . getHand (  )  . count ( filterAuraCard, game ) ; } count = player . getGraveyard (  )  . count ( filterAuraCard, game ) ; while  ( player . canRespond (  )  && count > 0 && player . chooseUse ( Outcome . Benefit, "Attach an Aura from your graveyard?", source, game )  )  { TargetCard targetAura = new TargetCard ( Zone . GRAVEYARD, filterAuraCard ) ; if  ( player . choose ( Outcome . Benefit, player . getGraveyard (  ) , targetAura, game )  )  { Card aura = game . getCard ( targetAura . getFirstTarget (  )  ) ; if  ( aura != null )  { game . getState (  )  . setValue ( "attachTo:" + aura . getId (  ) , permanent ) ; aura . putOntoBattlefield ( game, Zone . GRAVEYARD, source . getSourceId (  ) , player . getId (  )  ) ; permanent . addAttachment ( aura . getId (  ) , game ) ; } } count = player . getGraveyard (  )  . count ( filterAuraCard, game ) ; } return true; } } 
public class BuildersBlessing extends CardImpl { public BuildersBlessing ( UUID ownerId )  { super ( ownerId, 8, "Builder's Blessing", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 0, 2, Duration . WhileOnBattlefield, new FilterUntappedCreature (  )  )  )  ) ; } public BuildersBlessing ( final BuildersBlessing card )  { super ( card ) ; } @Override public BuildersBlessing copy (  )  { return new BuildersBlessing ( this ) ; } } 
public class BurnAtTheStake extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "untapped creatures you control" ) ; static { filter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; } public BurnAtTheStake ( UUID ownerId )  { super ( ownerId, 130, "Burn at the Stake", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{2}{R}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addCost ( new TapVariableTargetCost ( filter, true, "any number of" )  ) ; this . getSpellAbility (  )  . addEffect ( new BurnAtTheStakeEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public BurnAtTheStake ( final BurnAtTheStake card )  { super ( card ) ; } @Override public BurnAtTheStake copy (  )  { return new BurnAtTheStake ( this ) ; } } class BurnAtTheStakeEffect extends OneShotEffect { public BurnAtTheStakeEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "{this} deals damage to target creature or player equal to three times the number of creatures tapped this way"; } public BurnAtTheStakeEffect ( final BurnAtTheStakeEffect effect )  { super ( effect ) ; } @Override public BurnAtTheStakeEffect copy (  )  { return new BurnAtTheStakeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int amount =  ( new GetXValue (  )  )  . calculate ( game, source, this )  * 3; Permanent permanent = game . getPermanent ( targetPointer . getFirst ( game, source )  ) ; if  ( permanent != null )  { permanent . damage ( amount, source . getSourceId (  ) , game, false, true ) ; return true; } Player player = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; if  ( player != null )  { player . damage ( amount, source . getSourceId (  ) , game, false, true ) ; return true; } return false; } } 
public class ButcherGhoul extends CardImpl { public ButcherGhoul ( UUID ownerId )  { super ( ownerId, 89, "Butcher Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public ButcherGhoul ( final ButcherGhoul card )  { super ( card ) ; } @Override public ButcherGhoul copy (  )  { return new ButcherGhoul ( this ) ; } } 
public class CallToServe extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "nonblack creature" ) ; static { filter . add ( Predicates . not ( new ColorPredicate ( ObjectColor . BLACK )  )  ) ; } public CallToServe ( UUID ownerId )  { super ( ownerId, 9, "Call to Serve", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent ( filter ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 1, 2, Duration . WhileOnBattlefield )  ) ; Effect effect = new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA ) ; effect . setText ( ", has flying" ) ; ability . addEffect ( effect ) ; effect = new AddCardSubtypeAttachedEffect ( "Angel", Duration . WhileOnBattlefield, AttachmentType . AURA ) ; effect . setText ( ", and is an Angel in addition to its other types" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public CallToServe ( final CallToServe card )  { super ( card ) ; } @Override public CallToServe copy (  )  { return new CallToServe ( this ) ; } } 
public class CaptainOfTheMists extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "another Human" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( new SubtypePredicate ( "Human" )  ) ; } public CaptainOfTheMists ( UUID ownerId )  { super ( ownerId, 45, "Captain of the Mists", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( new UntapSourceEffect (  ) , filter )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new MayTapOrUntapTargetEffect (  ) , new ManaCostsImpl ( "{1}{U}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( ability ) ; } public CaptainOfTheMists ( final CaptainOfTheMists card )  { super ( card ) ; } @Override public CaptainOfTheMists copy (  )  { return new CaptainOfTheMists ( this ) ; } } 
public class CatharsCrusade extends CardImpl { public CatharsCrusade ( UUID ownerId )  { super ( ownerId, 10, "Cathars' Crusade", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new CreatureEntersBattlefieldTriggeredAbility ( new AddCountersAllEffect ( CounterType . P1P1 . createInstance (  ) , new FilterControlledCreaturePermanent (  )  )  )  ) ; } public CatharsCrusade ( final CatharsCrusade card )  { super ( card ) ; } @Override public CatharsCrusade copy (  )  { return new CatharsCrusade ( this ) ; } } 
public class CathedralSanctifier extends CardImpl { public CathedralSanctifier ( UUID ownerId )  { super ( ownerId, 11, "Cathedral Sanctifier", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( 3 )  )  ) ; } public CathedralSanctifier ( final CathedralSanctifier card )  { super ( card ) ; } @Override public CathedralSanctifier copy (  )  { return new CathedralSanctifier ( this ) ; } } 
public class CavernOfSouls extends CardImpl { public CavernOfSouls ( UUID ownerId )  { super ( ownerId, 226, "Cavern of Souls", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new AsEntersBattlefieldAbility ( new ChooseCreatureTypeEffect ( Outcome . BoostCreature )  )  ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new ConditionalAnyColorManaAbility ( new TapSourceCost (  ) , 1, new CavernOfSoulsManaBuilder (  ) , true ) ; this . addAbility ( ability, new CavernOfSoulsWatcher ( ability . getOriginalId (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new CavernOfSoulsCantCounterEffect (  )  )  ) ; } public CavernOfSouls ( final CavernOfSouls card )  { super ( card ) ; } @Override public CavernOfSouls copy (  )  { return new CavernOfSouls ( this ) ; } } class CavernOfSoulsManaBuilder extends ConditionalManaBuilder { String creatureType; @Override public ConditionalManaBuilder setMana ( Mana mana, Ability source, Game game )  { Object value = game . getState (  )  . getValue ( source . getSourceId (  )  + "_type" ) ; if  ( value != null && value instanceof String )  { creatureType =  ( String )  value; } Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( controller != null && sourceObject != null )  { game . informPlayers ( controller . getLogName (  )  + " produces " + mana . toString (  )  + " with " + sourceObject . getLogName (  )  + "  ( can only be spend to cast for creatures of type " + creatureType + " and that spell can't be countered ) " ) ; } return super . setMana ( mana, source, game ) ; } @Override public ConditionalMana build ( Object .  options )  { return new CavernOfSoulsConditionalMana ( this . mana, creatureType ) ; } @Override public String getRule (  )  { return "Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered"; } } class CavernOfSoulsConditionalMana extends ConditionalMana { public CavernOfSoulsConditionalMana ( Mana mana, String creatureType )  { super ( mana ) ; staticText = "Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered"; addCondition ( new CavernOfSoulsManaCondition ( creatureType )  ) ; } } class CavernOfSoulsManaCondition extends CreatureCastManaCondition { String creatureType; CavernOfSoulsManaCondition ( String creatureType )  { this . creatureType = creatureType; } @Override public boolean apply ( Game game, Ability source, UUID originalId, Cost costToPay )  { if  ( super . apply ( game, source )  )  { MageObject object = game . getObject ( source . getSourceId (  )  ) ; if  ( creatureType != null && object . hasSubtype ( creatureType )  )  { return true; } } return false; } } class CavernOfSoulsWatcher extends Watcher { private List<UUID> spells = new ArrayList<> (  ) ; private final String originalId; public CavernOfSoulsWatcher ( UUID originalId )  { super ( "ManaPaidFromCavernOfSoulsWatcher", WatcherScope . CARD ) ; this . originalId = originalId . toString (  ) ; } public CavernOfSoulsWatcher ( final CavernOfSoulsWatcher watcher )  { super ( watcher ) ; this . spells . addAll ( watcher . spells ) ; this . originalId = watcher . originalId; } @Override public CavernOfSoulsWatcher copy (  )  { return new CavernOfSoulsWatcher ( this ) ; } @Override public void watch ( GameEvent event, Game game )  { if  ( event . getType (  )  == GameEvent . EventType . MANA_PAYED )  { if  ( event . getData (  )  != null && event . getData (  )  . equals ( originalId )  )  { spells . add ( event . getTargetId (  )  ) ; } } } public boolean spellCantBeCountered ( UUID spellId )  { return spells . contains ( spellId ) ; } @Override public void reset (  )  { super . reset (  ) ; spells . clear (  ) ; } } class CavernOfSoulsCantCounterEffect extends ContinuousRuleModifyingEffectImpl { public CavernOfSoulsCantCounterEffect (  )  { super ( Duration . EndOfGame, Outcome . Benefit ) ; staticText = null; } public CavernOfSoulsCantCounterEffect ( final CavernOfSoulsCantCounterEffect effect )  { super ( effect ) ; } @Override public CavernOfSoulsCantCounterEffect copy (  )  { return new CavernOfSoulsCantCounterEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public String getInfoMessage ( Ability source, GameEvent event, Game game )  { MageObject sourceObject = game . getObject ( source . getSourceId (  )  ) ; if  ( sourceObject != null )  { return "This spell can't be countered because a colored mana from " + sourceObject . getName (  )  + " was spent to cast it . "; } return null; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . COUNTER; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { CavernOfSoulsWatcher watcher =  ( CavernOfSoulsWatcher )  game . getState (  )  . getWatchers (  )  . get ( "ManaPaidFromCavernOfSoulsWatcher", source . getSourceId (  )  ) ; Spell spell = game . getStack (  )  . getSpell ( event . getTargetId (  )  ) ; return spell != null && watcher != null && watcher . spellCantBeCountered ( spell . getId (  )  ) ; } } 
public class ChampionOfLambholt extends CardImpl { public ChampionOfLambholt ( UUID ownerId )  { super ( ownerId, 171, "Champion of Lambholt", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ChampionOfLambholtEffect (  )  )  ) ; this . addAbility ( new EntersAnotherCreatureYourControlTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  )  )  ) ; } public ChampionOfLambholt ( final ChampionOfLambholt card )  { super ( card ) ; } @Override public ChampionOfLambholt copy (  )  { return new ChampionOfLambholt ( this ) ; } } class ChampionOfLambholtEffect extends RestrictionEffect { ChampionOfLambholtEffect (  )  { super ( Duration . WhileOnBattlefield ) ; staticText = "Creatures with power less than {this}'s power can't block creatures you control"; } ChampionOfLambholtEffect ( final ChampionOfLambholtEffect effect )  { super ( effect ) ; } @Override public boolean applies ( Permanent permanent, Ability source, Game game )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { return true; } return false; } @Override public boolean canBlock ( Permanent attacker, Permanent blocker, Ability source, Game game )  { if  ( attacker != null && blocker != null )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && attacker . getControllerId (  )  . equals ( sourcePermanent . getControllerId (  )  )  )  { return blocker . getPower (  )  . getValue (  )  >= sourcePermanent . getPower (  )  . getValue (  ) ; } } return true; } @Override public ChampionOfLambholtEffect copy (  )  { return new ChampionOfLambholtEffect ( this ) ; } } 
public class Cloudshift extends CardImpl { public Cloudshift ( UUID ownerId )  { super ( ownerId, 12, "Cloudshift", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; Effect effect = new ExileTargetForSourceEffect (  ) ; effect . setApplyEffectsAfter (  ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . getSpellAbility (  )  . addEffect ( new ReturnToBattlefieldUnderYourControlTargetEffect ( true )  ) ; } public Cloudshift ( final Cloudshift card )  { super ( card ) ; } @Override public Cloudshift copy (  )  { return new Cloudshift ( this ) ; } } 
public class CorpseTraders extends CardImpl { public CorpseTraders ( UUID ownerId )  { super ( ownerId, 90, "Corpse Traders", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new ActivateAsSorceryActivatedAbility ( Zone . BATTLEFIELD, new DiscardCardYouChooseTargetEffect (  ) , new ManaCostsImpl ( "{2}{B}" )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; ability . addCost ( new SacrificeTargetCost ( new TargetControlledCreaturePermanent (  )  )  ) ; this . addAbility ( ability ) ; } public CorpseTraders ( final CorpseTraders card )  { super ( card ) ; } @Override public CorpseTraders copy (  )  { return new CorpseTraders ( this ) ; } } 
public class CraterhoofBehemoth extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public CraterhoofBehemoth ( UUID ownerId )  { super ( ownerId, 172, "Craterhoof Behemoth", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{5}{G}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Beast" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new GainAbilityControlledEffect ( TrampleAbility . getInstance (  ) , Duration . EndOfTurn, filter )  ) ; PermanentsOnBattlefieldCount controlledCreatures = new PermanentsOnBattlefieldCount ( new FilterControlledCreaturePermanent ( "the number of creatures you control" ) , null ) ; ability . addEffect ( new BoostControlledEffect ( controlledCreatures, controlledCreatures, Duration . EndOfTurn, filter, false, true )  ) ; this . addAbility ( ability ) ; } public CraterhoofBehemoth ( final CraterhoofBehemoth card )  { super ( card ) ; } @Override public CraterhoofBehemoth copy (  )  { return new CraterhoofBehemoth ( this ) ; } } 
public class CripplingChill extends CardImpl { public CripplingChill ( UUID ownerId )  { super ( ownerId, 46, "Crippling Chill", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addEffect ( new TapTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DontUntapInControllersNextUntapStepTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 1 )  ) ; } public CripplingChill ( final CripplingChill card )  { super ( card ) ; } @Override public CripplingChill copy (  )  { return new CripplingChill ( this ) ; } } 
public class CryptCreeper extends CardImpl { public CryptCreeper ( UUID ownerId )  { super ( ownerId, 91, "Crypt Creeper", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ExileTargetEffect (  ) , new SacrificeSourceCost (  )  ) ; ability . addTarget ( new TargetCardInGraveyard (  )  ) ; this . addAbility ( ability ) ; } public CryptCreeper ( final CryptCreeper card )  { super ( card ) ; } @Override public CryptCreeper copy (  )  { return new CryptCreeper ( this ) ; } } 
public class Cursebreak extends CardImpl { private static final FilterPermanent filter = new FilterPermanent ( "enchantment" ) ; static { filter . add ( new CardTypePredicate ( CardType . ENCHANTMENT )  ) ; } public Cursebreak ( UUID ownerId )  { super ( ownerId, 14, "Cursebreak", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 2 )  ) ; } public Cursebreak ( final Cursebreak card )  { super ( card ) ; } @Override public Cursebreak copy (  )  { return new Cursebreak ( this ) ; } } 
public class DangerousWager extends CardImpl { public DangerousWager ( UUID ownerId )  { super ( ownerId, 131, "Dangerous Wager", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DangerousWagerEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( 2 )  ) ; } public DangerousWager ( final DangerousWager card )  { super ( card ) ; } @Override public DangerousWager copy (  )  { return new DangerousWager ( this ) ; } } class DangerousWagerEffect extends OneShotEffect { public DangerousWagerEffect (  )  { super ( Outcome . Discard ) ; this . staticText = "Discard your hand"; } public DangerousWagerEffect ( final DangerousWagerEffect effect )  { super ( effect ) ; } @Override public DangerousWagerEffect copy (  )  { return new DangerousWagerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { for  ( Card card : player . getHand (  )  . getCards ( game )  )  { player . discard ( card, source, game ) ; } return true; } return false; } } 
public class DarkImpostor extends CardImpl { public DarkImpostor ( UUID ownerId )  { super ( ownerId, 92, "Dark Impostor", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Assassin" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ImprintTargetEffect (  ) , new ManaCostsImpl ( "{4}{B}{B}" )  ) ; ability . addEffect ( new ExileTargetEffect ( null, this . getIdName (  )  )  ) ; ability . addEffect ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DarkImpostorContinuousEffect (  )  )  ) ; } public DarkImpostor ( final DarkImpostor card )  { super ( card ) ; } @Override public DarkImpostor copy (  )  { return new DarkImpostor ( this ) ; } } class DarkImpostorContinuousEffect extends ContinuousEffectImpl { public DarkImpostorContinuousEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; staticText = "{this} has all activated abilities of all creature cards exiled with it"; } public DarkImpostorContinuousEffect ( final DarkImpostorContinuousEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent perm = game . getPermanent ( source . getSourceId (  )  ) ; if  ( perm != null )  { for  ( UUID imprintedId : perm . getImprinted (  )  )  { Card card = game . getCard ( imprintedId ) ; if  ( card != null )  { for  ( Ability ability : card . getAbilities (  )  )  { if  ( ability instanceof ActivatedAbility )  { perm . addAbility ( ability, source . getSourceId (  ) , game ) ; } } } } } return true; } @Override public DarkImpostorContinuousEffect copy (  )  { return new DarkImpostorContinuousEffect ( this ) ; } } 
public class DeadeyeNavigator extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{1}{U}: Exile this creature, then return it to the battlefield under your control . \""; public DeadeyeNavigator ( UUID ownerId )  { super ( ownerId, 47, "Deadeye Navigator", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ExileSourceEffect ( true ) , new ManaCostsImpl ( "{1}{U}" )  ) ; ability . addEffect ( new ReturnToBattlefieldUnderYourControlSourceEffect (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public DeadeyeNavigator ( final DeadeyeNavigator card )  { super ( card ) ; } @Override public DeadeyeNavigator copy (  )  { return new DeadeyeNavigator ( this ) ; } } 
public class DeathWind extends CardImpl { public DeathWind ( UUID ownerId )  { super ( ownerId, 93, "Death Wind", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{X}{B}" ) ; this . expansionSetCode = "AVR"; DynamicValue x = new SignInversionDynamicValue ( new ManacostVariableValue (  )  ) ; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( x, x, Duration . EndOfTurn, true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public DeathWind ( final DeathWind card )  { super ( card ) ; } @Override public DeathWind copy (  )  { return new DeathWind ( this ) ; } } 
public class Defang extends CardImpl { public Defang ( UUID ownerId )  { super ( ownerId, 15, "Defang", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new PreventAllDamageByAttachedEffect ( Duration . WhileOnBattlefield, "enchanted creature", false )  )  ) ; } public Defang ( final Defang card )  { super ( card ) ; } @Override public Defang copy (  )  { return new Defang ( this ) ; } } 
public class DefyDeath extends CardImpl { public DefyDeath ( UUID ownerId )  { super ( ownerId, 16, "Defy Death", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ReturnFromGraveyardToBattlefieldTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DefyDeathEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "creature card from your graveyard" )  )  ) ; } public DefyDeath ( final DefyDeath card )  { super ( card ) ; } @Override public DefyDeath copy (  )  { return new DefyDeath ( this ) ; } } class DefyDeathEffect extends OneShotEffect { public DefyDeathEffect (  )  { super ( Outcome . BoostCreature ) ; this . staticText = "If it's an Angel, put two +1/+1 counters on it"; } public DefyDeathEffect ( final DefyDeathEffect effect )  { super ( effect ) ; } @Override public DefyDeathEffect copy (  )  { return new DefyDeathEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null && permanent . hasSubtype ( "Angel" )  )  { permanent . addCounters ( CounterType . P1P1 . createInstance ( 2 ) , game ) ; return true; } return false; } } 
public class DemonicRising extends CardImpl { private static final String ruleText = "At the beginning of your end step, if you control exactly one creature, put a 5/5 black Demon creature token with flying onto the battlefield"; public DemonicRising ( UUID ownerId )  { super ( ownerId, 94, "Demonic Rising", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; TriggeredAbility ability = new BeginningOfYourEndStepTriggeredAbility ( new CreateTokenEffect ( new DemonToken (  )  ) , false ) ; this . addAbility ( new ConditionalTriggeredAbility ( ability, OneControlledCreatureCondition . getInstance (  ) , ruleText )  ) ; } public DemonicRising ( final DemonicRising card )  { super ( card ) ; } @Override public DemonicRising copy (  )  { return new DemonicRising ( this ) ; } } 
public class DemonicTaskmaster extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "a creature other than Demonic Taskmaster" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public DemonicTaskmaster ( UUID ownerId )  { super ( ownerId, 95, "Demonic Taskmaster", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new BeginningOfUpkeepTriggeredAbility ( new SacrificeEffect ( filter, 1, "" ) , TargetController . YOU, false ) ; this . addAbility ( ability ) ; } public DemonicTaskmaster ( final DemonicTaskmaster card )  { super ( card ) ; } @Override public DemonicTaskmaster copy (  )  { return new DemonicTaskmaster ( this ) ; } } 
public class DemonlordOfAshmouth extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( " another creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public DemonlordOfAshmouth ( UUID ownerId )  { super ( ownerId, 96, "Demonlord of Ashmouth", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ExileSourceUnlessPaysEffect ( new SacrificeTargetCost ( new TargetControlledPermanent ( filter )  )  )  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public DemonlordOfAshmouth ( final DemonlordOfAshmouth card )  { super ( card ) ; } @Override public DemonlordOfAshmouth copy (  )  { return new DemonlordOfAshmouth ( this ) ; } } 
public class DescendantsPath extends CardImpl { public DescendantsPath ( UUID ownerId )  { super ( ownerId, 173, "Descendants' Path", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; Ability ability = new BeginningOfUpkeepTriggeredAbility ( new DescendantsPathEffect (  ) , TargetController . YOU, false ) ; this . addAbility ( ability ) ; } public DescendantsPath ( final DescendantsPath card )  { super ( card ) ; } @Override public DescendantsPath copy (  )  { return new DescendantsPath ( this ) ; } } class DescendantsPathEffect extends OneShotEffect { public DescendantsPathEffect (  )  { super ( Outcome . Discard ) ; this . staticText = "reveal the top card of your library .  If it's a creature card that shares a creature type with a creature you control, you may cast that card without paying its mana cost .  Otherwise, put that card on the bottom of your library"; } public DescendantsPathEffect ( final DescendantsPathEffect effect )  { super ( effect ) ; } @Override public DescendantsPathEffect copy (  )  { return new DescendantsPathEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; MageObject sourceObject = source . getSourceObject ( game ) ; if  ( controller != null && sourceObject != null )  { if  ( controller . getLibrary (  )  . size (  )  > 0 )  { Card card = controller . getLibrary (  )  . getFromTop ( game ) ; if  ( card == null )  { return false; } controller . revealCards ( sourceObject . getIdName (  ) , new CardsImpl ( card ) , game ) ; if  ( card . getCardType (  )  . contains ( CardType . CREATURE )  )  { FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; boolean found = false; for  ( Permanent permanent: game . getBattlefield (  )  . getAllActivePermanents ( filter, controller . getId (  ) , game )  )  { if  ( CardUtil . shareSubtypes ( card, permanent )  )  { found = true; break; } } if  ( found )  { game . informPlayers ( sourceObject . getLogName (  )  + ": Found a creature that shares a creature type with the revealed card . " ) ; if  ( controller . chooseUse ( Outcome . Benefit, "Cast the card?", source, game )  )  { controller . cast ( card . getSpellAbility (  ) , game, true ) ; } else { game . informPlayers ( sourceObject . getLogName (  )  + ": " + controller . getLogName (  )  + " canceled casting the card . " ) ; controller . getLibrary (  )  . putOnBottom ( card, game ) ; } } else { game . informPlayers ( sourceObject . getLogName (  )  + ": No creature that shares a creature type with the revealed card . " ) ; controller . getLibrary (  )  . putOnBottom ( card, game ) ; } } else { game . informPlayers ( sourceObject . getLogName (  )  + ": Put " + card . getLogName (  )  + " on the bottom . " ) ; controller . getLibrary (  )  . putOnBottom ( card, game ) ; } return true; } } return false; } } 
public class DescentIntoMadness extends CardImpl { public DescentIntoMadness ( UUID ownerId )  { super ( ownerId, 97, "Descent into Madness", Rarity . MYTHIC, new CardType[]{CardType . ENCHANTMENT}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new BeginningOfUpkeepTriggeredAbility ( new DescentIntoMadnessEffect (  ) , TargetController . YOU, false )  ) ; } public DescentIntoMadness ( final DescentIntoMadness card )  { super ( card ) ; } @Override public DescentIntoMadness copy (  )  { return new DescentIntoMadness ( this ) ; } } class DescentIntoMadnessEffect extends OneShotEffect { public DescentIntoMadnessEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "put a despair counter on {this}, then each player exiles X permanents he or she controls and/or cards from his or her hand, where X is the number of despair counters on {this}"; } public DescentIntoMadnessEffect ( final DescentIntoMadnessEffect effect )  { super ( effect ) ; } @Override public DescentIntoMadnessEffect copy (  )  { return new DescentIntoMadnessEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && controller != null )  { sourcePermanent . addCounters ( CounterType . DESPAIR . createInstance (  ) , game ) ; } if  ( sourcePermanent == null )  { sourcePermanent =  ( Permanent )  game . getLastKnownInformation ( source . getSourceId (  ) , Zone . BATTLEFIELD ) ; } if  ( sourcePermanent != null && controller != null )  { int count = sourcePermanent . getCounters (  )  . getCount ( CounterType . DESPAIR ) ; if  ( count > 0 )  { LinkedList<UUID> selectedObjects = new LinkedList<> (  ) ; PlayerList playerList = game . getState (  )  . getPlayerList ( controller . getId (  )  ) ; Player currentPlayer = controller; do { selectCards ( currentPlayer, selectedObjects, count, source, game ) ; currentPlayer = playerList . getNextInRange ( controller, game ) ; } while  ( !currentPlayer . equals ( controller )  && controller . canRespond (  )  ) ; for  ( UUID objectId : selectedObjects )  { if  ( game . getState (  )  . getZone ( objectId )  . equals ( Zone . BATTLEFIELD )  )  { Permanent permanent = game . getPermanent ( objectId ) ; if  ( permanent != null )  { Player player = game . getPlayer ( permanent . getControllerId (  )  ) ; if  ( player != null )  { player . moveCardToExileWithInfo ( permanent, null, "", source . getSourceId (  ) , game, Zone . BATTLEFIELD, true ) ; } } } else if  ( game . getState (  )  . getZone ( objectId )  . equals ( Zone . HAND )  )  { Card card = game . getCard ( objectId ) ; if  ( card != null )  { Player player = game . getPlayer ( card . getOwnerId (  )  ) ; if  ( player != null )  { player . moveCardToExileWithInfo ( card, null, "", source . getSourceId (  ) , game, Zone . HAND, true ) ; } } } } } return true; } return false; } private void selectCards ( Player player, List<UUID> selectedObjects, int count, Ability source, Game game )  { int amount = Math . min ( count, player . getHand (  )  . size (  )  + game . getBattlefield (  )  . getAllActivePermanents ( player . getId (  )  )  . size (  )  ) ; int cardsFromHand = 0; while  ( player . canRespond (  )  && amount > 0 )  { Target target; do { FilterControlledPermanent filter = new FilterControlledPermanent (  ) ; filter . setMessage ( "permanent you control  ( " + amount + " left in total ) "  ) ; List<PermanentIdPredicate> uuidPredicates = new ArrayList<> (  ) ; for  ( UUID uuid :selectedObjects )  { uuidPredicates . add ( new PermanentIdPredicate ( uuid )  ) ; } filter . add ( Predicates . not ( Predicates . or ( uuidPredicates )  )  ) ; target = new TargetControlledPermanent ( 0, 1, filter, true ) ; if  ( target . canChoose ( player . getId (  ) , game )  && player . choose ( Outcome . Exile, target, source . getSourceId (  ) , game )  )  { for  ( UUID targetId : target . getTargets (  )  )  { if  ( !selectedObjects . contains ( targetId )  )  { Permanent chosen = game . getPermanent ( targetId ) ; if  ( chosen != null )  { amount--; game . informPlayers ( player . getLogName (  )  + " selects " + chosen . getLogName (  )  + " from battlefield" ) ; selectedObjects . add ( targetId ) ; } } } } } while  ( amount > 0 && !target . getTargets (  )  . isEmpty (  )  && player . canRespond (  )  ) ; if  ( amount > 0 )  { TargetCard targetInHand; do { FilterCard filterInHand = new FilterCard (  ) ; filterInHand . setMessage ( "card from your hand  ( " + amount + " left in total ) " ) ; targetInHand = new TargetCard ( 0, 1, Zone . HAND, filterInHand ) ; List<CardIdPredicate> uuidPredicates = new ArrayList<> (  ) ; for  ( UUID uuid :selectedObjects )  { uuidPredicates . add ( new CardIdPredicate ( uuid )  ) ; } filterInHand . add ( Predicates . not ( Predicates . or ( uuidPredicates )  )  ) ; if  ( targetInHand . canChoose ( player . getId (  ) , game )  && player . choose ( Outcome . Exile, player . getHand (  ) , targetInHand, game )  )  { Card card = player . getHand (  )  . get ( targetInHand . getFirstTarget (  ) , game ) ; if  ( card != null )  { selectedObjects . add ( targetInHand . getFirstTarget (  )  ) ; amount--; cardsFromHand++; } } } while  ( amount > 0 && !targetInHand . getTargets (  )  . isEmpty (  )  && player . canRespond (  )  ) ; } } if  ( cardsFromHand > 0 )  { game . informPlayers ( player . getLogName (  )  + " selects " + cardsFromHand +  ( cardsFromHand == 1?" card":" cards" )  + " from his or her hand" ) ; } } } 
public class DesolateLighthouse extends CardImpl { public DesolateLighthouse ( UUID ownerId )  { super ( ownerId, 227, "Desolate Lighthouse", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new ColorlessManaAbility (  )  ) ; SimpleActivatedAbility ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawDiscardControllerEffect (  ) , new ManaCostsImpl ( "{1}{U}{R}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; this . addAbility ( ability ) ; } public DesolateLighthouse ( final DesolateLighthouse card )  { super ( card ) ; } @Override public DesolateLighthouse copy (  )  { return new DesolateLighthouse ( this ) ; } } 
public class DevastationTide extends CardImpl { public DevastationTide ( UUID ownerId )  { super ( ownerId, 48, "Devastation Tide", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DevastationTideEffect (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{1}{U}" )  )  ) ; } public DevastationTide ( final DevastationTide card )  { super ( card ) ; } @Override public DevastationTide copy (  )  { return new DevastationTide ( this ) ; } } class DevastationTideEffect extends OneShotEffect { public DevastationTideEffect (  )  { super ( Outcome . ReturnToHand ) ; staticText = "Return all nonland permanents to their owners' hands"; } public DevastationTideEffect ( final DevastationTideEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller != null )  { Set<Card> cardsToHand = new LinkedHashSet<> (  ) ; for  ( Permanent permanent : game . getBattlefield (  )  . getActivePermanents ( new FilterNonlandPermanent (  ) , source . getControllerId (  ) , source . getSourceId (  ) , game )  )  { cardsToHand . add (  ( Card )  permanent ) ; } controller . moveCards ( cardsToHand, Zone . HAND, source, game ) ; return true; } return false; } @Override public DevastationTideEffect copy (  )  { return new DevastationTideEffect ( this ) ; } } 
public class DivineDeflection extends CardImpl { public DivineDeflection ( UUID ownerId )  { super ( ownerId, 18, "Divine Deflection", Rarity . RARE, new CardType[]{CardType . INSTANT}, "{X}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DivineDeflectionPreventDamageTargetEffect ( Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; } public DivineDeflection ( final DivineDeflection card )  { super ( card ) ; } @Override public DivineDeflection copy (  )  { return new DivineDeflection ( this ) ; } } class DivineDeflectionPreventDamageTargetEffect extends PreventionEffectImpl { public DivineDeflectionPreventDamageTargetEffect ( Duration duration )  { super ( duration, Integer . MIN_VALUE, false, true ) ; staticText = "Prevent the next X damage that would be dealt to you and/or permanents you control this turn .  If damage is prevented this way, {this} deals that much damage to target creature or player"; } public DivineDeflectionPreventDamageTargetEffect ( final DivineDeflectionPreventDamageTargetEffect effect )  { super ( effect ) ; } @Override public DivineDeflectionPreventDamageTargetEffect copy (  )  { return new DivineDeflectionPreventDamageTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { /* If damage is dealt to multiple permanents you control, or is dealt to you and at least one permanent you control, you choose which of that damage to prevent if the chosen value for X won't prevent all the damage .  For example, if 3 damage would be dealt to you and to each of two creatures you control, and Divine Deflection will prevent the next 3 damage, you might choose to prevent the next 2 damage it would deal to you and the next 1 damage it would deal to one of the creatures, among other choices .  You don't decide until the point at which the damage would be dealt .  TODO: Support to select which damage to prevent */ PreventionEffectData preventionData = preventDamageAction ( event, source, game ) ; /* Divine Deflection's effect is not a redirection effect .  If it prevents damage, Divine Deflection  ( not the original source )  deals damage to the targeted creature or player as part of that prevention effect .  Divine Deflection is the source of the new damage, so the characteristics of the original source  ( such as its color, or whether it had lifelink or deathtouch )  don't affect this damage .  The new damage is not combat damage, even if the prevented damage was .  Since you control the source of the new damage, if you targeted an opponent with Divine Deflection, you may have Divine Deflection deal its damage to a planeswalker that opponent controls .  */ int prevented = preventionData . getPreventedDamage (  ) ; if  ( prevented > 0 )  { UUID dealDamageTo = source . getFirstTarget (  ) ; /* Whether the targeted creature or player is still a legal target is not checked after Divine Deflection resolves .  For example, if a creature targeted by Divine Deflection gains shroud after Divine Deflection resolves, Divine Deflection can still deal damage to that creature .  */ Permanent permanent = game . getPermanent ( dealDamageTo ) ; if  ( permanent != null )  { game . informPlayers ( "Dealing " + prevented + " to " + permanent . getName (  )  + " instead" ) ; permanent . damage ( prevented, source . getSourceId (  ) , game, false, true ) ; } Player player = game . getPlayer ( dealDamageTo ) ; if  ( player != null )  { game . informPlayers ( "Dealing " + prevented + " to " + player . getLogName (  )  + " instead" ) ; player . damage ( prevented, source . getSourceId (  ) , game, false, true ) ; } } return false; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( !this . used && super . applies ( event, source, game )  )  { if  ( amountToPrevent == Integer . MIN_VALUE )  { amountToPrevent = source . getManaCostsToPay (  )  . getX (  ) ; } Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null )  { if  ( permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  )  { return true; } } if  ( source . getControllerId (  )  . equals ( event . getTargetId (  )  )  )  { return true; } } return false; } } 
public class DreadSlaver extends CardImpl { public DreadSlaver ( UUID ownerId )  { super ( ownerId, 98, "Dread Slaver", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new DiesAndDealtDamageThisTurnTriggeredAbility ( new DreadSlaverEffect (  ) , false )  ) ; } public DreadSlaver ( final DreadSlaver card )  { super ( card ) ; } @Override public DreadSlaver copy (  )  { return new DreadSlaver ( this ) ; } } class DreadSlaverEffect extends OneShotEffect { public DreadSlaverEffect (  )  { super ( Outcome . Benefit ) ; staticText = "return it to the battlefield under your control .  That creature is a black Zombie in addition to its other colors and types"; } public DreadSlaverEffect ( final DreadSlaverEffect effect )  { super ( effect ) ; } @Override public DreadSlaverEffect copy (  )  { return new DreadSlaverEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Card card = game . getCard ( targetPointer . getFirst ( game, source )  ) ; if  ( card != null )  { Zone currentZone = game . getState (  )  . getZone ( card . getId (  )  ) ; if  ( card . putOntoBattlefield ( game, currentZone, source . getSourceId (  ) , source . getControllerId (  )  )  )  { ContinuousEffect effect = new DreadSlaverContiniousEffect (  ) ; effect . setTargetPointer ( new FixedTarget ( card . getId (  )  )  ) ; game . addEffect ( effect, source ) ; return true; } } return false; } } class DreadSlaverContiniousEffect extends ContinuousEffectImpl { public DreadSlaverContiniousEffect (  )  { super ( Duration . Custom, Outcome . Neutral ) ; staticText = "That creature is a black Zombie in addition to its other colors and types"; } public DreadSlaverContiniousEffect ( final DreadSlaverContiniousEffect effect )  { super ( effect ) ; } @Override public DreadSlaverContiniousEffect copy (  )  { return new DreadSlaverContiniousEffect ( this ) ; } @Override public boolean apply ( Layer layer, SubLayer sublayer, Ability source, Game game )  { Permanent creature = game . getPermanent ( targetPointer . getFirst ( game, source )  ) ; if  ( creature != null )  { switch  ( layer )  { case TypeChangingEffects_4: if  ( sublayer == SubLayer . NA )  { creature . getSubtype (  )  . add ( "Zombie" ) ; } break; case ColorChangingEffects_5: if  ( sublayer == SubLayer . NA )  { creature . getColor ( game )  . setBlack ( true ) ; } break; } return true; } else { this . used = true; } return false; } @Override public boolean apply ( Game game, Ability source )  { return false; } @Override public boolean hasLayer ( Layer layer )  { return layer == Layer . ColorChangingEffects_5 || layer == Layer . TypeChangingEffects_4; } } 
public class Dreadwaters extends CardImpl { private static final FilterLandPermanent filter = new FilterLandPermanent ( "lands you control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public Dreadwaters ( UUID ownerId )  { super ( ownerId, 49, "Dreadwaters", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new PutLibraryIntoGraveTargetEffect ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public Dreadwaters ( final Dreadwaters card )  { super ( card ) ; } @Override public Dreadwaters copy (  )  { return new Dreadwaters ( this ) ; } } 
public class DriverOfTheDead extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "creature card with converted mana cost 2 or less from your graveyard to the battlefield" ) ; static { filter . add ( new ConvertedManaCostPredicate ( Filter . ComparisonType . LessThan, 3 )  ) ; } public DriverOfTheDead ( UUID ownerId )  { super ( ownerId, 99, "Driver of the Dead", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; Ability ability = new DiesTriggeredAbility ( new ReturnFromGraveyardToBattlefieldTargetEffect (  ) , false ) ; Target target = new TargetCardInYourGraveyard ( filter ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public DriverOfTheDead ( final DriverOfTheDead card )  { super ( card ) ; } @Override public DriverOfTheDead copy (  )  { return new DriverOfTheDead ( this ) ; } } 
public class DruidsFamiliar extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures gets +2/+2"; public DruidsFamiliar ( UUID ownerId )  { super ( ownerId, 175, "Druid's Familiar", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Bear" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostPairedEffect ( 2, 2, ruleText )  )  ) ; } public DruidsFamiliar ( final DruidsFamiliar card )  { super ( card ) ; } @Override public DruidsFamiliar copy (  )  { return new DruidsFamiliar ( this ) ; } } 
public class DruidsRepository extends CardImpl { public DruidsRepository ( UUID ownerId )  { super ( ownerId, 176, "Druids' Repository", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new AttacksCreatureYouControlTriggeredAbility ( new AddCountersSourceEffect ( CounterType . CHARGE . createInstance (  )  )  )  ) ; Ability ability = new SimpleManaAbility ( Zone . BATTLEFIELD, new AddManaOfAnyColorEffect (  ) , new RemoveCountersSourceCost ( CounterType . CHARGE . createInstance (  )  )  ) ; this . addAbility ( ability ) ; } public DruidsRepository ( final DruidsRepository card )  { super ( card ) ; } @Override public DruidsRepository copy (  )  { return new DruidsRepository ( this ) ; } } 
public class DualCasting extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "instant or sorcery spell" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . INSTANT ) , new CardTypePredicate ( CardType . SORCERY )  )  ) ; filter . add ( new ControllerPredicate ( TargetController . YOU )  ) ; } public DualCasting ( UUID ownerId )  { super ( ownerId, 133, "Dual Casting", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CopyTargetSpellEffect (  ) , new ColoredManaCost ( ColoredManaSymbol . R )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetSpell ( filter )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability, AttachmentType . AURA )  )  ) ; } public DualCasting ( final DualCasting card )  { super ( card ) ; } @Override public DualCasting copy (  )  { return new DualCasting ( this ) ; } } 
public class EatenBySpiders extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public EatenBySpiders ( UUID ownerId )  { super ( ownerId, 177, "Eaten by Spiders", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new EatenBySpidersEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public EatenBySpiders ( final EatenBySpiders card )  { super ( card ) ; } @Override public EatenBySpiders copy (  )  { return new EatenBySpiders ( this ) ; } } class EatenBySpidersEffect extends OneShotEffect { public EatenBySpidersEffect (  )  { super ( Outcome . DestroyPermanent ) ; this . staticText = "Destroy target creature with flying and all Equipment attached to that creature"; } public EatenBySpidersEffect ( final EatenBySpidersEffect effect )  { super ( effect ) ; } @Override public EatenBySpidersEffect copy (  )  { return new EatenBySpidersEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { LinkedList<UUID> attachments = new LinkedList<UUID> (  ) ; attachments . addAll ( permanent . getAttachments (  )  ) ; for  ( UUID attachmentId : attachments )  { Permanent attachment = game . getPermanent ( attachmentId ) ; if  ( attachment . hasSubtype ( "Equipment" )  )  { attachment . destroy ( source . getSourceId (  ) , game, false ) ; } } permanent . destroy ( source . getSourceId (  ) , game, false ) ; return true; } return false; } } 
public class ElgaudShieldmate extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have hexproof"; public ElgaudShieldmate ( UUID ownerId )  { super ( ownerId, 50, "Elgaud Shieldmate", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( HexproofAbility . getInstance (  ) , ruleText )  )  ) ; } public ElgaudShieldmate ( final ElgaudShieldmate card )  { super ( card ) ; } @Override public ElgaudShieldmate copy (  )  { return new ElgaudShieldmate ( this ) ; } } 
public class EmancipationAngel extends CardImpl { public EmancipationAngel ( UUID ownerId )  { super ( ownerId, 19, "Emancipation Angel", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new ReturnToHandChosenControlledPermanentEffect ( new FilterControlledPermanent (  )  ) , false )  ) ; } public EmancipationAngel ( final EmancipationAngel card )  { super ( card ) ; } @Override public EmancipationAngel copy (  )  { return new EmancipationAngel ( this ) ; } } 
public class EntreatTheAngels extends CardImpl { public EntreatTheAngels ( UUID ownerId )  { super ( ownerId, 20, "Entreat the Angels", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{X}{X}{W}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CreateTokenEffect ( new AngelToken (  ) , new ManacostVariableValue (  )  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{X}{W}{W}" )  )  ) ; } public EntreatTheAngels ( final EntreatTheAngels card )  { super ( card ) ; } @Override public EntreatTheAngels copy (  )  { return new EntreatTheAngels ( this ) ; } } 
public class EssenceHarvest extends CardImpl { public EssenceHarvest ( UUID ownerId )  { super ( ownerId, 100, "Essence Harvest", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new EssenceHarvestEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public EssenceHarvest ( final EssenceHarvest card )  { super ( card ) ; } @Override public EssenceHarvest copy (  )  { return new EssenceHarvest ( this ) ; } } class EssenceHarvestEffect extends OneShotEffect { public EssenceHarvestEffect (  )  { super ( Outcome . Damage ) ; this . staticText = "Target player loses X life and you gain X life, where X is the greatest power among creatures you control"; } public EssenceHarvestEffect ( final EssenceHarvestEffect effect )  { super ( effect ) ; } @Override public EssenceHarvestEffect copy (  )  { return new EssenceHarvestEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; Player targetPlayer = game . getPlayer ( source . getFirstTarget (  )  ) ; if  ( player != null && targetPlayer != null )  { List<Permanent> creatures = game . getBattlefield (  )  . getAllActivePermanents ( new FilterCreaturePermanent (  ) , player . getId (  ) , game ) ; int amount = 0; for  ( Permanent creature : creatures )  { int power = creature . getPower (  )  . getValue (  ) ; if  ( amount < power )  { amount = power; } } if  ( amount > 0 )  { targetPlayer . loseLife ( amount, game ) ; player . gainLife ( amount, game ) ; } return true; } return false; } } 
public class EvernightShade extends CardImpl { public EvernightShade ( UUID ownerId )  { super ( ownerId, 101, "Evernight Shade", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Shade" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 1, Duration . EndOfTurn ) , new ManaCostsImpl ( "{B}" )  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public EvernightShade ( final EvernightShade card )  { super ( card ) ; } @Override public EvernightShade copy (  )  { return new EvernightShade ( this ) ; } } 
public class ExquisiteBlood extends CardImpl { public ExquisiteBlood ( UUID ownerId )  { super ( ownerId, 102, "Exquisite Blood", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; ExquisiteBloodTriggeredAbility ability = new ExquisiteBloodTriggeredAbility (  ) ; this . addAbility ( ability ) ; } public ExquisiteBlood ( final ExquisiteBlood card )  { super ( card ) ; } @Override public ExquisiteBlood copy (  )  { return new ExquisiteBlood ( this ) ; } } class ExquisiteBloodTriggeredAbility extends TriggeredAbilityImpl { public ExquisiteBloodTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, null ) ; } public ExquisiteBloodTriggeredAbility ( final ExquisiteBloodTriggeredAbility ability )  { super ( ability ) ; } @Override public ExquisiteBloodTriggeredAbility copy (  )  { return new ExquisiteBloodTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . LOST_LIFE; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( game . getOpponents ( this . controllerId )  . contains ( event . getPlayerId (  )  )  )  { this . getEffects (  )  . clear (  ) ; this . addEffect ( new GainLifeEffect ( event . getAmount (  )  )  ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever an opponent loses life, you gain that much life . "; } } 
public class FalkenrathExterminator extends CardImpl { public FalkenrathExterminator ( UUID ownerId )  { super ( ownerId, 134, "Falkenrath Exterminator", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . subtype . add ( "Archer" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( new CountersCount ( CounterType . P1P1 )  ) , new ManaCostsImpl ( "{2}{R}" )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public FalkenrathExterminator ( final FalkenrathExterminator card )  { super ( card ) ; } @Override public FalkenrathExterminator copy (  )  { return new FalkenrathExterminator ( this ) ; } } 
public class FarbogExplorer extends CardImpl { public FarbogExplorer ( UUID ownerId )  { super ( ownerId, 21, "Farbog Explorer", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( new SwampwalkAbility (  )  ) ; } public FarbogExplorer ( final FarbogExplorer card )  { super ( card ) ; } @Override public FarbogExplorer copy (  )  { return new FarbogExplorer ( this ) ; } } 
public class FavorableWinds extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Creatures you control with flying" ) ; static { filter . add ( new AbilityPredicate ( FlyingAbility . class )  ) ; } public FavorableWinds ( UUID ownerId )  { super ( ownerId, 51, "Favorable Winds", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostControlledEffect ( 1, 1, Duration . WhileOnBattlefield, filter, false )  )  ) ; } public FavorableWinds ( final FavorableWinds card )  { super ( card ) ; } @Override public FavorableWinds copy (  )  { return new FavorableWinds ( this ) ; } } 
public class FerventCathar extends CardImpl { public FerventCathar ( UUID ownerId )  { super ( ownerId, 135, "Fervent Cathar", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new CantBlockTargetEffect ( Duration . EndOfTurn )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public FerventCathar ( final FerventCathar card )  { super ( card ) ; } @Override public FerventCathar copy (  )  { return new FerventCathar ( this ) ; } } 
public class GallowsAtWillowHill extends CardImpl { private static final FilterControlledPermanent humanFilter = new FilterControlledPermanent ( "untapped Human you control" ) ; static { humanFilter . add ( Predicates . not ( new TappedPredicate (  )  )  ) ; humanFilter . add ( new SubtypePredicate ( "Human" )  ) ; } public GallowsAtWillowHill ( UUID ownerId )  { super ( ownerId, 215, "Gallows at Willow Hill", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{3}" ) ; this . expansionSetCode = "AVR"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GallowsAtWillowHillEffect (  ) , new GenericManaCost ( 3 )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addCost ( new TapTargetCost ( new TargetControlledPermanent ( 3, 3, humanFilter, false )  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public GallowsAtWillowHill ( final GallowsAtWillowHill card )  { super ( card ) ; } @Override public GallowsAtWillowHill copy (  )  { return new GallowsAtWillowHill ( this ) ; } } class GallowsAtWillowHillEffect extends OneShotEffect { public GallowsAtWillowHillEffect (  )  { super ( Outcome . DestroyPermanent ) ; staticText = "Destroy target creature .  Its controller puts a 1/1 white Spirit creature token with flying onto the battlefield"; } public GallowsAtWillowHillEffect ( final GallowsAtWillowHillEffect effect )  { super ( effect ) ; } @Override public GallowsAtWillowHillEffect copy (  )  { return new GallowsAtWillowHillEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { int affectedTargets = 0; if  ( targetPointer . getTargets ( game, source )  . size (  )  > 0 )  { for  ( UUID permanentId : targetPointer . getTargets ( game, source )  )  { Permanent permanent = game . getPermanent ( permanentId ) ; if  ( permanent != null )  { Player controller = game . getPlayer ( permanent . getControllerId (  )  ) ; permanent . destroy ( source . getSourceId (  ) , game, false ) ; if  ( controller != null )  { new CreateTokenEffect ( new SpiritWhiteToken (  )  )  . apply ( game, source ) ; } affectedTargets++; } } } return affectedTargets > 0; } } 
public class GalvanicAlchemist extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{2}{U}: Untap this creature . \""; public GalvanicAlchemist ( UUID ownerId )  { super ( ownerId, 54, "Galvanic Alchemist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new UntapSourceEffect (  ) , new ManaCostsImpl ( "{2}{U}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public GalvanicAlchemist ( final GalvanicAlchemist card )  { super ( card ) ; } @Override public GalvanicAlchemist copy (  )  { return new GalvanicAlchemist ( this ) ; } } 
public class GangOfDevils extends CardImpl { public GangOfDevils ( UUID ownerId )  { super ( ownerId, 136, "Gang of Devils", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Devil" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new DiesTriggeredAbility ( new DamageMultiEffect ( 3 )  ) ; ability . addTarget ( new TargetCreatureOrPlayerAmount ( 3 )  ) ; this . addAbility ( ability ) ; } public GangOfDevils ( final GangOfDevils card )  { super ( card ) ; } @Override public GangOfDevils copy (  )  { return new GangOfDevils ( this ) ; } } 
public class GeistSnatch extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "creature spell" ) ; static { filter . add ( new CardTypePredicate ( CardType . CREATURE )  ) ; } public GeistSnatch ( UUID ownerId )  { super ( ownerId, 55, "Geist Snatch", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new GeistSnatchCounterTargetEffect (  )  ) ; } public GeistSnatch ( final GeistSnatch card )  { super ( card ) ; } @Override public GeistSnatch copy (  )  { return new GeistSnatch ( this ) ; } } class GeistSnatchCounterTargetEffect extends OneShotEffect { public GeistSnatchCounterTargetEffect (  )  { super ( Outcome . Detriment ) ; staticText = "Counter target creature spell .  Put a 1/1 blue Spirit creature token with flying onto the battlefield"; } public GeistSnatchCounterTargetEffect ( final GeistSnatchCounterTargetEffect effect )  { super ( effect ) ; } @Override public GeistSnatchCounterTargetEffect copy (  )  { return new GeistSnatchCounterTargetEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { game . getStack (  )  . counter ( source . getFirstTarget (  ) , source . getSourceId (  ) , game ) ; Token token = new SpiritBlueToken (  ) ; token . putOntoBattlefield ( 1, game, source . getSourceId (  ) , source . getControllerId (  )  ) ; return true; } } class SpiritBlueToken extends Token { public SpiritBlueToken (  )  { super ( "Spirit", "1/1 blue Spirit creature token with flying" ) ; cardType . add ( CardType . CREATURE ) ; subtype . add ( "Spirit" ) ; color . setBlue ( true ) ; power = new MageInt ( 1 ) ; toughness = new MageInt ( 1 ) ; setTokenType ( 2 ) ; addAbility ( FlyingAbility . getInstance (  )  ) ; } } 
public class GeistTrappers extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have reach"; public GeistTrappers ( UUID ownerId )  { super ( ownerId, 179, "Geist Trappers", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ReachAbility . getInstance (  ) , ruleText )  )  ) ; } public GeistTrappers ( final GeistTrappers card )  { super ( card ) ; } @Override public GeistTrappers copy (  )  { return new GeistTrappers ( this ) ; } } 
public class Ghostform extends CardImpl { public Ghostform ( UUID ownerId )  { super ( ownerId, 56, "Ghostform", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CantBeBlockedTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 2 )  ) ; } public Ghostform ( final Ghostform card )  { super ( card ) ; } @Override public Ghostform copy (  )  { return new Ghostform ( this ) ; } } 
public class GhostlyFlicker extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "artifacts, creatures, and/or lands you control" ) ; static { filter . add ( Predicates . or (  new CardTypePredicate ( CardType . CREATURE ) , new CardTypePredicate ( CardType . LAND ) , new CardTypePredicate ( CardType . ARTIFACT )  )  ) ; } public GhostlyFlicker ( UUID ownerId )  { super ( ownerId, 57, "Ghostly Flicker", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetControlledPermanent ( 2, 2, filter, false )  ) ; this . getSpellAbility (  )  . addEffect ( new GhostlyFlickerEffect (  )  ) ; } public GhostlyFlicker ( final GhostlyFlicker card )  { super ( card ) ; } @Override public GhostlyFlicker copy (  )  { return new GhostlyFlicker ( this ) ; } } class GhostlyFlickerEffect extends OneShotEffect { public GhostlyFlickerEffect (  )  { super ( Outcome . Benefit ) ; staticText = "Exile two target artifacts, creatures, and/or lands you control, then return those cards to the battlefield under your control"; } public GhostlyFlickerEffect ( final GhostlyFlickerEffect effect )  { super ( effect ) ; } @Override public GhostlyFlickerEffect copy (  )  { return new GhostlyFlickerEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { UUID exileId = source . getSourceId (  ) ; for  ( UUID permanentId : targetPointer . getTargets ( game, source )  )  { Permanent target = game . getPermanent ( permanentId ) ; if  ( target != null )  { target . moveToExile ( exileId, "Ghostly Flicker", source . getSourceId (  ) , game ) ; Card card = game . getCard ( target . getId (  )  ) ; if  ( card != null )  { Zone currentZone = game . getState (  )  . getZone ( card . getId (  )  ) ; card . putOntoBattlefield ( game, currentZone, source . getSourceId (  ) , source . getControllerId (  )  ) ; } } } return true; } } 
public class GhostlyTouch extends CardImpl { public GhostlyTouch ( UUID ownerId )  { super ( ownerId, 58, "Ghostly Touch", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability gainedAbility = new AttacksTriggeredAbility ( new MayTapOrUntapTargetEffect (  ) , true ) ; gainedAbility . addTarget ( new TargetPermanent (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA )  )  ) ; } public GhostlyTouch ( final GhostlyTouch card )  { super ( card ) ; } @Override public GhostlyTouch copy (  )  { return new GhostlyTouch ( this ) ; } } 
public class Ghoulflesh extends CardImpl { public Ghoulflesh ( UUID ownerId )  { super ( ownerId, 103, "Ghoulflesh", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . UnboostCreature )  ) ; this . addAbility ( new EnchantAbility ( auraTarget . getTargetName (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( -1, -1, Duration . WhileOnBattlefield )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardSubtypeAttachedEffect ( "Zombie", Duration . WhileOnBattlefield, AttachmentType . AURA )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new AddCardColorAttachedEffect ( ObjectColor . BLACK, Duration . WhileOnBattlefield, AttachmentType . AURA )  )  ) ; } public Ghoulflesh ( final Ghoulflesh card )  { super ( card ) ; } @Override public Ghoulflesh copy (  )  { return new Ghoulflesh ( this ) ; } } 
public class GiselaBladeOfGoldnight extends CardImpl { public GiselaBladeOfGoldnight ( UUID ownerId )  { super ( ownerId, 209, "Gisela, Blade of Goldnight", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{R}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GiselaBladeOfGoldnightDoubleDamageEffect (  )  )  ) ; } public GiselaBladeOfGoldnight ( final GiselaBladeOfGoldnight card )  { super ( card ) ; } @Override public GiselaBladeOfGoldnight copy (  )  { return new GiselaBladeOfGoldnight ( this ) ; } } class GiselaBladeOfGoldnightDoubleDamageEffect extends ReplacementEffectImpl { public GiselaBladeOfGoldnightDoubleDamageEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Damage ) ; staticText = "If a source would deal damage to an opponent or a permanent an opponent controls, that source deals double that damage to that player or permanent instead . " + "If a source would deal damage to you or a permanent you control, prevent half that damage, rounded up"; } public GiselaBladeOfGoldnightDoubleDamageEffect ( final GiselaBladeOfGoldnightDoubleDamageEffect effect )  { super ( effect ) ; } @Override public GiselaBladeOfGoldnightDoubleDamageEffect copy (  )  { return new GiselaBladeOfGoldnightDoubleDamageEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  . equals ( EventType . DAMAGE_CREATURE )  || event . getType (  )  . equals ( EventType . DAMAGE_PLANESWALKER )  || event . getType (  )  . equals ( EventType . DAMAGE_PLAYER ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return true; } private void preventDamage ( GameEvent event, Ability source, UUID target, Game game )  { int amount =  ( int ) Math . ceil ( event . getAmount (  )  / 2 . 0 ) ; GameEvent preventEvent = new GameEvent ( GameEvent . EventType . PREVENT_DAMAGE, target, source . getSourceId (  ) , source . getControllerId (  ) , amount, false ) ; if  ( !game . replaceEvent ( preventEvent )  )  { event . setAmount ( event . getAmount (  )  - amount ) ; game . fireEvent ( GameEvent . getEvent ( GameEvent . EventType . PREVENTED_DAMAGE, target, source . getSourceId (  ) , source . getControllerId (  ) , amount )  ) ; } } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { switch  ( event . getType (  )  )  { case DAMAGE_PLAYER: if  ( event . getTargetId (  )  . equals ( source . getControllerId (  )  )  )  { preventDamage ( event, source, source . getControllerId (  ) , game ) ; } else if  ( game . getOpponents ( source . getControllerId (  )  )  . contains ( event . getTargetId (  )  )  )  { event . setAmount ( event . getAmount (  )  * 2 ) ; } break; case DAMAGE_CREATURE: case DAMAGE_PLANESWALKER: Permanent permanent = game . getPermanent ( event . getTargetId (  )  ) ; if  ( permanent != null )  { if  ( permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  )  { preventDamage ( event, source, permanent . getId (  ) , game ) ; } else if  ( game . getOpponents ( source . getControllerId (  )  )  . contains ( permanent . getControllerId (  )  )  )  { event . setAmount ( event . getAmount (  )  * 2 ) ; } } } return false; } } 
public class GloomSurgeon extends CardImpl { public GloomSurgeon ( UUID ownerId )  { super ( ownerId, 104, "Gloom Surgeon", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GloomSurgeonEffect (  )  )  ) ; } public GloomSurgeon ( final GloomSurgeon card )  { super ( card ) ; } @Override public GloomSurgeon copy (  )  { return new GloomSurgeon ( this ) ; } } class GloomSurgeonEffect extends ReplacementEffectImpl { GloomSurgeonEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Exile ) ; staticText = "If combat damage would be dealt to {this}, prevent that damage and exile that many cards from the top of your library"; } GloomSurgeonEffect ( final GloomSurgeonEffect effect )  { super ( effect ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { GameEvent preventEvent = new GameEvent ( GameEvent . EventType . PREVENT_DAMAGE, source . getFirstTarget (  ) , source . getSourceId (  ) , source . getControllerId (  ) , event . getAmount (  ) , false ) ; if  ( !game . replaceEvent ( preventEvent )  )  { int preventedDamage = event . getAmount (  ) ; game . fireEvent ( GameEvent . getEvent ( GameEvent . EventType . PREVENTED_DAMAGE, source . getFirstTarget (  ) , source . getSourceId (  ) , source . getControllerId (  ) , preventedDamage )  ) ; Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player != null )  { player . moveCards ( player . getLibrary (  )  . getTopCards ( game, preventedDamage ) , Zone . EXILED, source, game ) ; } return true; } return false; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . DAMAGE_CREATURE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( event . getTargetId (  )  . equals ( source . getSourceId (  )  )  )  { DamageCreatureEvent damageEvent =  ( DamageCreatureEvent )  event; if  ( damageEvent . isCombatDamage (  )  )  { return true; } } return false; } @Override public GloomSurgeonEffect copy (  )  { return new GloomSurgeonEffect ( this ) ; } } 
public class Gloomwidow extends CardImpl { public Gloomwidow ( UUID ownerId )  { super ( ownerId, 180, "Gloomwidow", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spider" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( ReachAbility . getInstance (  )  ) ; this . addAbility ( new CanBlockOnlyFlyingAbility (  )  ) ; } public Gloomwidow ( final Gloomwidow card )  { super ( card ) ; } @Override public Gloomwidow copy (  )  { return new Gloomwidow ( this ) ; } } 
public class GoldnightCommander extends CardImpl { public GoldnightCommander ( UUID ownerId )  { super ( ownerId, 22, "Goldnight Commander", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new EntersAnotherCreatureYourControlTriggeredAbility ( new BoostControlledEffect ( 1, 1, Duration . EndOfTurn )  )  ) ; } public GoldnightCommander ( final GoldnightCommander card )  { super ( card ) ; } @Override public GoldnightCommander copy (  )  { return new GoldnightCommander ( this ) ; } } 
public class GoldnightRedeemer extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "other creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public GoldnightRedeemer ( UUID ownerId )  { super ( ownerId, 23, "Goldnight Redeemer", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( new PermanentsOnBattlefieldCount ( filter, 2 )  ) , false )  ) ; } public GoldnightRedeemer ( final GoldnightRedeemer card )  { super ( card ) ; } @Override public GoldnightRedeemer copy (  )  { return new GoldnightRedeemer ( this ) ; } } 
public class GraveExchange extends CardImpl { private static final FilterCreatureCard filter = new FilterCreatureCard ( "creature card from your graveyard" ) ; public GraveExchange ( UUID ownerId )  { super ( ownerId, 105, "Grave Exchange", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{4}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCardInYourGraveyard ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new GraveExchangeEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public GraveExchange ( final GraveExchange card )  { super ( card ) ; } @Override public GraveExchange copy (  )  { return new GraveExchange ( this ) ; } } class GraveExchangeEffect extends OneShotEffect { public GraveExchangeEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "Target player sacrifices a creature"; } public GraveExchangeEffect ( final GraveExchangeEffect effect )  { super ( effect ) ; } @Override public GraveExchangeEffect copy (  )  { return new GraveExchangeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( player == null )  { return false; } Target target = new TargetControlledPermanent ( new FilterControlledCreaturePermanent (  )  ) ; if  ( target . canChoose ( player . getId (  ) , game )  && player . choose ( Outcome . Sacrifice, target, source . getSourceId (  ) , game )  )  { Permanent permanent = game . getPermanent ( target . getFirstTarget (  )  ) ; if  ( permanent != null )  { return permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } return false; } } 
public class Griselbrand extends CardImpl { public Griselbrand ( UUID ownerId )  { super ( ownerId, 106, "Griselbrand", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{4}{B}{B}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 7 ) ; this . toughness = new MageInt ( 7 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( LifelinkAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 7 ) , new PayLifeCost ( 7 )  )  ) ; } public Griselbrand ( final Griselbrand card )  { super ( card ) ; } @Override public Griselbrand copy (  )  { return new Griselbrand ( this ) ; } } 
public class Grounded extends CardImpl { public Grounded ( UUID ownerId )  { super ( ownerId, 181, "Grounded", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . LoseAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new LoseAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; } public Grounded ( final Grounded card )  { super ( card ) ; } @Override public Grounded copy (  )  { return new Grounded ( this ) ; } } 
public class GryffVanguard extends CardImpl { public GryffVanguard ( UUID ownerId )  { super ( ownerId, 59, "Gryff Vanguard", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 )  )  ) ; } public GryffVanguard ( final GryffVanguard card )  { super ( card ) ; } @Override public GryffVanguard copy (  )  { return new GryffVanguard ( this ) ; } } 
public class HarvesterOfSouls extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "another nontoken creature" ) ; static { filter . add ( Predicates . not ( new TokenPredicate (  )  )  ) ; filter . add ( new AnotherPredicate (  )  ) ; } public HarvesterOfSouls ( UUID ownerId )  { super ( ownerId, 107, "Harvester of Souls", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( DeathtouchAbility . getInstance (  )  ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 ) , true, filter )  ) ; } public HarvesterOfSouls ( final HarvesterOfSouls card )  { super ( card ) ; } @Override public HarvesterOfSouls copy (  )  { return new HarvesterOfSouls ( this ) ; } } 
public class HauntedGuardian extends CardImpl { public HauntedGuardian ( UUID ownerId )  { super ( ownerId, 216, "Haunted Guardian", Rarity . UNCOMMON, new CardType[]{CardType . ARTIFACT, CardType . CREATURE}, "{2}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Construct" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( DefenderAbility . getInstance (  )  ) ; this . addAbility ( FirstStrikeAbility . getInstance (  )  ) ; } public HauntedGuardian ( final HauntedGuardian card )  { super ( card ) ; } @Override public HauntedGuardian copy (  )  { return new HauntedGuardian ( this ) ; } } 
public class HavengulSkaab extends CardImpl { public HavengulSkaab ( UUID ownerId )  { super ( ownerId, 60, "Havengul Skaab", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{5}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Horror" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( new HavengulSkaabAbility (  )  ) ; } public HavengulSkaab ( final HavengulSkaab card )  { super ( card ) ; } @Override public HavengulSkaab copy (  )  { return new HavengulSkaab ( this ) ; } } class HavengulSkaabAbility extends TriggeredAbilityImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public HavengulSkaabAbility (  )  { super ( Zone . BATTLEFIELD, new DestroyTargetEffect (  )  ) ; this . addEffect ( new ReturnToHandTargetEffect (  )  ) ; } public HavengulSkaabAbility ( final HavengulSkaabAbility ability )  { super ( ability ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . ATTACKER_DECLARED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  . equals ( this . getSourceId (  )  )  )  { TargetControlledCreaturePermanent target = new TargetControlledCreaturePermanent ( 1, 1, filter, false ) ; this . addTarget ( target ) ; return true; } return false; } @Override public String getRule (  )  { return "Whenever {this} attacks, return another creature you control to its owner's hand . "; } @Override public HavengulSkaabAbility copy (  )  { return new HavengulSkaabAbility ( this ) ; } } 
public class HavengulVampire extends CardImpl { public HavengulVampire ( UUID ownerId )  { super ( ownerId, 139, "Havengul Vampire", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; this . addAbility ( new DiesCreatureTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false, true )  ) ; } public HavengulVampire ( final HavengulVampire card )  { super ( card ) ; } @Override public HavengulVampire copy (  )  { return new HavengulVampire ( this ) ; } } 
public class HeirsOfStromkirk extends CardImpl { public HeirsOfStromkirk ( UUID ownerId )  { super ( ownerId, 140, "Heirs of Stromkirk", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Vampire" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( IntimidateAbility . getInstance (  )  ) ; this . addAbility ( new DealsCombatDamageToAPlayerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; } public HeirsOfStromkirk ( final HeirsOfStromkirk card )  { super ( card ) ; } @Override public HeirsOfStromkirk copy (  )  { return new HeirsOfStromkirk ( this ) ; } } 
public class HeraldOfWar extends CardImpl { public HeraldOfWar ( UUID ownerId )  { super ( ownerId, 24, "Herald of War", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new AttacksTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance (  )  ) , false )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new HeraldOfWarCostReductionEffect (  )  )  ) ; } public HeraldOfWar ( final HeraldOfWar card )  { super ( card ) ; } @Override public HeraldOfWar copy (  )  { return new HeraldOfWar ( this ) ; } } class HeraldOfWarCostReductionEffect extends CostModificationEffectImpl { HeraldOfWarCostReductionEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit, CostModificationType . REDUCE_COST ) ; staticText = "Angel spells and Human spells you cast cost {1} less to cast for each +1/+1 counter on Herald of War"; } HeraldOfWarCostReductionEffect ( HeraldOfWarCostReductionEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source, Ability abilityToModify )  { SpellAbility spellAbility =  ( SpellAbility )  abilityToModify; Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null )  { int amount = sourcePermanent . getCounters (  )  . getCount ( CounterType . P1P1 ) ; if  ( amount > 0 )  { CardUtil . adjustCost ( spellAbility, amount ) ; return true; } } return false; } @Override public boolean applies ( Ability abilityToModify, Ability source, Game game )  { if  ( abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility )  { Card sourceCard = game . getCard ( abilityToModify . getSourceId (  )  ) ; if  ( sourceCard != null && abilityToModify . getControllerId (  )  . equals ( source . getControllerId (  )  )  &&  ( sourceCard . hasSubtype ( "Angel" )  || sourceCard . hasSubtype ( "Human" )  )  )  { return true; } } return false; } @Override public HeraldOfWarCostReductionEffect copy (  )  { return new HeraldOfWarCostReductionEffect ( this ) ; } } 
public class HolyJusticiar extends CardImpl { public HolyJusticiar ( UUID ownerId )  { super ( ownerId, 25, "Holy Justiciar", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new HolyJusticiarEffect (  ) , new ManaCostsImpl ( "{2}{W}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public HolyJusticiar ( final HolyJusticiar card )  { super ( card ) ; } @Override public HolyJusticiar copy (  )  { return new HolyJusticiar ( this ) ; } } class HolyJusticiarEffect extends OneShotEffect { public HolyJusticiarEffect (  )  { super ( Outcome . Detriment ) ; staticText = "Tap target creature .  If that creature is a Zombie, exile it"; } public HolyJusticiarEffect ( final HolyJusticiarEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent creature = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( creature != null )  { if  ( creature . hasSubtype ( "Zombie" )  )  { creature . tap ( game ) ; creature . moveToExile ( source . getSourceId (  ) , creature . getName (  ) , source . getSourceId (  ) , game ) ; } else { creature . tap ( game ) ; } return true; } return false; } @Override public HolyJusticiarEffect copy (  )  { return new HolyJusticiarEffect ( this ) ; } } 
public class HomicidalSeclusion extends CardImpl { private static final String rule = "As long as you control exactly one creature, that creature gets +3/+1"; public HomicidalSeclusion ( UUID ownerId )  { super ( ownerId, 108, "Homicidal Seclusion", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; ContinuousEffect boostEffect = new BoostControlledEffect ( 3, 1, Duration . WhileOnBattlefield ) ; Effect effect = new ConditionalContinuousEffect ( boostEffect, new OneControlledCreatureCondition (  ) , rule ) ; Ability ability = new SimpleStaticAbility ( Zone . BATTLEFIELD, effect ) ; ContinuousEffect lifelinkEffect = new GainAbilityControlledEffect ( LifelinkAbility . getInstance (  ) , Duration . WhileOnBattlefield ) ; effect = new ConditionalContinuousEffect ( lifelinkEffect, new OneControlledCreatureCondition (  ) , "and has lifelink" ) ; ability . addEffect ( effect ) ; this . addAbility ( ability ) ; } public HomicidalSeclusion ( final HomicidalSeclusion card )  { super ( card ) ; } @Override public HomicidalSeclusion copy (  )  { return new HomicidalSeclusion ( this ) ; } } 
public class HoundOfGriselbrand extends CardImpl { public HoundOfGriselbrand ( UUID ownerId )  { super ( ownerId, 141, "Hound of Griselbrand", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . subtype . add ( "Hound" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( DoubleStrikeAbility . getInstance (  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public HoundOfGriselbrand ( final HoundOfGriselbrand card )  { super ( card ) ; } @Override public HoundOfGriselbrand copy (  )  { return new HoundOfGriselbrand ( this ) ; } } 
public class Howlgeist extends CardImpl { public Howlgeist ( UUID ownerId )  { super ( ownerId, 182, "Howlgeist", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . subtype . add ( "Wolf" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new CantBeBlockedByCreaturesWithLessPowerEffect (  )  )  ) ; this . addAbility ( new UndyingAbility (  )  ) ; } public Howlgeist ( final Howlgeist card )  { super ( card ) ; } @Override public Howlgeist copy (  )  { return new Howlgeist ( this ) ; } } 
public class HumanFrailty extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Human creature" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public HumanFrailty ( UUID ownerId )  { super ( ownerId, 109, "Human Frailty", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( filter )  ) ; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; } public HumanFrailty ( final HumanFrailty card )  { super ( card ) ; } @Override public HumanFrailty copy (  )  { return new HumanFrailty ( this ) ; } } 
public class HuntedGhoul extends CardImpl { public HuntedGhoul ( UUID ownerId )  { super ( ownerId, 110, "Hunted Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SimpleEvasionAbility ( new CantBlockCreaturesSourceEffect ( new FilterCreaturePermanent ( "Human", "Humans" )  )  )  ) ; } public HuntedGhoul ( final HuntedGhoul card )  { super ( card ) ; } @Override public HuntedGhoul copy (  )  { return new HuntedGhoul ( this ) ; } } 
public class InfiniteReflection extends CardImpl { public InfiniteReflection ( UUID ownerId )  { super ( ownerId, 61, "Infinite Reflection", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{5}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Copy )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new InfiniteReflectionTriggeredEffect (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new InfiniteReflectionEntersBattlefieldEffect (  )  )  ) ; } public InfiniteReflection ( final InfiniteReflection card )  { super ( card ) ; } @Override public InfiniteReflection copy (  )  { return new InfiniteReflection ( this ) ; } } class InfiniteReflectionTriggeredEffect extends OneShotEffect { private static final FilterPermanent filter = new FilterControlledCreaturePermanent (  ) ; public InfiniteReflectionTriggeredEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = " attached to a creature, each other nontoken creature you control becomes a copy of that creature"; } public InfiniteReflectionTriggeredEffect ( final InfiniteReflectionTriggeredEffect effect )  { super ( effect ) ; } @Override public InfiniteReflectionTriggeredEffect copy (  )  { return new InfiniteReflectionTriggeredEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && sourcePermanent . getAttachedTo (  )  != null )  { Permanent toCopyFromPermanent = game . getPermanent ( sourcePermanent . getAttachedTo (  )  ) ; if  ( toCopyFromPermanent != null )  { for  ( Permanent toCopyToPermanent : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { if  ( !toCopyToPermanent . equals ( toCopyFromPermanent )  && ! ( toCopyToPermanent instanceof PermanentToken )  )  { game . copyPermanent ( toCopyFromPermanent, toCopyToPermanent . getId (  ) , source, new EmptyApplyToPermanent (  )  ) ; } } return true; } } return false; } } class InfiniteReflectionEntersBattlefieldEffect extends ReplacementEffectImpl { public InfiniteReflectionEntersBattlefieldEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; } public InfiniteReflectionEntersBattlefieldEffect ( InfiniteReflectionEntersBattlefieldEffect effect )  { super ( effect ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . ENTERS_THE_BATTLEFIELD; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { Permanent permanent =  (  ( EntersTheBattlefieldEvent )  event )  . getTarget (  ) ; return permanent != null && permanent . getControllerId (  )  . equals ( source . getControllerId (  )  )  && permanent . getCardType (  )  . contains ( CardType . CREATURE )  && ! ( permanent instanceof PermanentToken ) ; } @Override public boolean replaceEvent ( GameEvent event, Ability source, Game game )  { MageObject toCopyToObject =  (  ( EntersTheBattlefieldEvent )  event )  . getTarget (  ) ; Permanent sourcePermanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( sourcePermanent != null && toCopyToObject != null && sourcePermanent . getAttachedTo (  )  != null )  { Permanent toCopyFromPermanent = game . getPermanent ( sourcePermanent . getAttachedTo (  )  ) ; if  ( toCopyFromPermanent != null )  { game . copyPermanent ( toCopyFromPermanent, toCopyToObject . getId (  ) , source, new EmptyApplyToPermanent (  )  ) ; } } return false; } @Override public String getText ( Mode mode )  { return "Nontoken creatures you control enter the battlefield as a copy of enchanted creature"; } @Override public InfiniteReflectionEntersBattlefieldEffect copy (  )  { return new InfiniteReflectionEntersBattlefieldEffect ( this ) ; } } 
public class IntoTheVoid extends CardImpl { public IntoTheVoid ( UUID ownerId )  { super ( ownerId, 62, "Into the Void", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new ReturnToHandTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( 0, 2 )  ) ; } public IntoTheVoid ( final IntoTheVoid card )  { super ( card ) ; } @Override public IntoTheVoid copy (  )  { return new IntoTheVoid ( this ) ; } } 
public class JointAssault extends CardImpl { public JointAssault ( UUID ownerId )  { super ( ownerId, 183, "Joint Assault", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new JointAssaultBoostTargetEffect ( 2, 2, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public JointAssault ( final JointAssault card )  { super ( card ) ; } @Override public JointAssault copy (  )  { return new JointAssault ( this ) ; } } class JointAssaultBoostTargetEffect extends ContinuousEffectImpl { private int power; private int toughness; private UUID paired; public JointAssaultBoostTargetEffect ( int power, int toughness, Duration duration )  { super ( duration, Layer . PTChangingEffects_7, SubLayer . ModifyPT_7c, Outcome . BoostCreature ) ; this . power = power; this . toughness = toughness; staticText = "Target creature gets +2/+2 until end of turn .  If it's paired with a creature, that creature also gets +2/+2 until end of turn"; } public JointAssaultBoostTargetEffect ( final JointAssaultBoostTargetEffect effect )  { super ( effect ) ; this . power = effect . power; this . toughness = effect . toughness; } @Override public JointAssaultBoostTargetEffect copy (  )  { return new JointAssaultBoostTargetEffect ( this ) ; } @Override public void init ( Ability source, Game game )  { super . init ( source, game ) ; UUID permanentId = targetPointer . getFirst ( game, source ) ; Permanent target = game . getPermanent ( permanentId ) ; if  ( target != null )  { if  ( target . getPairedCard (  )  != null )  { this . paired = target . getPairedCard (  ) ; } } } @Override public boolean apply ( Game game, Ability source )  { int affectedTargets = 0; UUID permanentId = targetPointer . getFirst ( game, source ) ; Permanent target = game . getPermanent ( permanentId ) ; if  ( target != null )  { target . addPower ( power ) ; target . addToughness ( toughness ) ; affectedTargets++; } if  ( this . paired != null )  { Permanent paired = game . getPermanent ( this . paired ) ; if  ( paired != null )  { paired . addPower ( power ) ; paired . addToughness ( toughness ) ; affectedTargets++; } } return affectedTargets > 0; } } 
public class KessigMalcontents extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "Humans you control" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public KessigMalcontents ( UUID ownerId )  { super ( ownerId, 142, "Kessig Malcontents", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new DamageTargetEffect ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public KessigMalcontents ( final KessigMalcontents card )  { super ( card ) ; } @Override public KessigMalcontents copy (  )  { return new KessigMalcontents ( this ) ; } } 
public class KillingWave extends CardImpl { public KillingWave ( UUID ownerId )  { super ( ownerId, 111, "Killing Wave", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{X}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new KillingWaveEffect (  )  ) ; } public KillingWave ( final KillingWave card )  { super ( card ) ; } @Override public KillingWave copy (  )  { return new KillingWave ( this ) ; } } class KillingWaveEffect extends OneShotEffect { public KillingWaveEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "For each creature, its controller sacrifices it unless he or she pays X life"; } public KillingWaveEffect ( final KillingWaveEffect effect )  { super ( effect ) ; } @Override public KillingWaveEffect copy (  )  { return new KillingWaveEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } int amount =  ( new ManacostVariableValue (  )  )  . calculate ( game, source, this ) ; if  ( amount > 0 )  { LinkedList<Permanent> sacrifices = new LinkedList<Permanent> (  ) ; HashMap<UUID, Integer> lifePaidAmounts = new HashMap<UUID, Integer> (  ) ; FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; List<Permanent> creatures = game . getBattlefield (  )  . getAllActivePermanents ( filter, playerId, game ) ; int lifePaid = 0; int playerLife = player . getLife (  ) ; for  ( Permanent creature : creatures )  { String message = "Pay " + amount + " life? If you don't, " + creature . getName (  )  + " will be sacrificed . "; if  ( playerLife - amount - lifePaid >= 0 && player != null && player . chooseUse ( Outcome . Neutral, message, source, game )  )  { game . informPlayers ( player . getLogName (  )  + " pays " + amount + " life .  He will not sacrifice " + creature . getName (  )  ) ; lifePaid += amount; } else { game . informPlayers ( player . getLogName (  )  + " will sacrifice " + creature . getName (  )  ) ; sacrifices . add ( creature ) ; } } lifePaidAmounts . put ( playerId, lifePaid ) ; } for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { int lifePaid = lifePaidAmounts . get ( playerId ) ; if  ( lifePaid > 0 )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { player . loseLife ( lifePaid, game ) ; } } } for  ( Permanent creature : sacrifices )  { creature . sacrifice ( source . getSourceId (  ) , game ) ; } } return true; } } 
public class KruinStriker extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "another creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public KruinStriker ( UUID ownerId )  { super ( ownerId, 143, "Kruin Striker", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new EntersBattlefieldAllTriggeredAbility ( new BoostSourceEffect ( 1, 0, Duration . EndOfTurn ) , filter, "Whenever another creature enters the battlefield under your control, Kruin Striker gets +1/+0 and gains trample until end of turn . " ) ; ability . addEffect ( new GainAbilitySourceEffect ( TrampleAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . addAbility ( ability ) ; } public KruinStriker ( final KruinStriker card )  { super ( card ) ; } @Override public KruinStriker copy (  )  { return new KruinStriker ( this ) ; } } 
public class LeapOfFaith extends CardImpl { public LeapOfFaith ( UUID ownerId )  { super ( ownerId, 26, "Leap of Faith", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( FlyingAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new PreventDamageToTargetEffect ( Duration . EndOfTurn, Integer . MAX_VALUE )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public LeapOfFaith ( final LeapOfFaith card )  { super ( card ) ; } @Override public LeapOfFaith copy (  )  { return new LeapOfFaith ( this ) ; } } 
public class LightningMauler extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have haste"; public LightningMauler ( UUID ownerId )  { super ( ownerId, 144, "Lightning Mauler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Berserker" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( HasteAbility . getInstance (  ) , ruleText )  )  ) ; } public LightningMauler ( final LightningMauler card )  { super ( card ) ; } @Override public LightningMauler copy (  )  { return new LightningMauler ( this ) ; } } 
public class LightningProwess extends CardImpl { public LightningProwess ( UUID ownerId )  { super ( ownerId, 145, "Lightning Prowess", Rarity . UNCOMMON, new CardType[]{CardType . ENCHANTMENT}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( HasteAbility . getInstance (  ) , AttachmentType . AURA )  )  ) ; ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( ability, AttachmentType . AURA )  )  ) ; } public LightningProwess ( final LightningProwess card )  { super ( card ) ; } @Override public LightningProwess copy (  )  { return new LightningProwess ( this ) ; } } 
public class LoneRevenant extends CardImpl { public LoneRevenant ( UUID ownerId )  { super ( ownerId, 64, "Lone Revenant", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{3}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( HexproofAbility . getInstance (  )  ) ; this . addAbility ( new LoneRevenantTriggeredAbility (  )  ) ; } public LoneRevenant ( final LoneRevenant card )  { super ( card ) ; } @Override public LoneRevenant copy (  )  { return new LoneRevenant ( this ) ; } } class LoneRevenantTriggeredAbility extends TriggeredAbilityImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent (  ) ; public LoneRevenantTriggeredAbility (  )  { super ( Zone . BATTLEFIELD, new LookLibraryAndPickControllerEffect ( new StaticValue ( 4 ) , false, new StaticValue ( 1 ) , new FilterCard (  ) , Zone . LIBRARY, false, false )  ) ; } public LoneRevenantTriggeredAbility ( final LoneRevenantTriggeredAbility ability )  { super ( ability ) ; } @Override public LoneRevenantTriggeredAbility copy (  )  { return new LoneRevenantTriggeredAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . DAMAGED_PLAYER; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { if  ( event . getSourceId (  )  . equals ( this . sourceId )  &&  (  ( DamagedPlayerEvent )  event )  . isCombatDamage (  )  )  { Permanent permanent = game . getPermanent ( event . getSourceId (  )  ) ; int number = game . getBattlefield (  )  . countAll ( filter, controllerId, game ) ; if  ( permanent != null && number != 1 )  { return false; } return permanent != null || number == 0; } return false; } @Override public String getRule (  )  { return "Whenever {this} deals combat damage to a player, if you control no other creatures, " + super . getRule (  ) ; } } 
public class LunarMystic extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "an instant spell" ) ; static { filter . add ( new CardTypePredicate ( CardType . INSTANT )  ) ; } public LunarMystic ( UUID ownerId )  { super ( ownerId, 65, "Lunar Mystic", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new SpellCastControllerTriggeredAbility ( new DoIfCostPaid ( new DrawCardSourceControllerEffect ( 1 ) , new GenericManaCost ( 1 )  ) , filter, false )  ) ; } public LunarMystic ( final LunarMystic card )  { super ( card ) ; } @Override public LunarMystic copy (  )  { return new LunarMystic ( this ) ; } } 
public class MaalfeldTwins extends CardImpl { public MaalfeldTwins ( UUID ownerId )  { super ( ownerId, 112, "Maalfeld Twins", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{5}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( new DiesTriggeredAbility ( new CreateTokenEffect ( new ZombieToken (  ) , 2 )  )  ) ; } public MaalfeldTwins ( final MaalfeldTwins card )  { super ( card ) ; } @Override public MaalfeldTwins copy (  )  { return new MaalfeldTwins ( this ) ; } } 
public class MadProphet extends CardImpl { public MadProphet ( UUID ownerId )  { super ( ownerId, 146, "Mad Prophet", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( HasteAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new TapSourceCost (  )  ) ; ability . addCost ( new DiscardTargetCost ( new TargetCardInHand (  )  )  ) ; this . addAbility ( ability ) ; } public MadProphet ( final MadProphet card )  { super ( card ) ; } @Override public MadProphet copy (  )  { return new MadProphet ( this ) ; } } 
public class MaliciousIntent extends CardImpl { public MaliciousIntent ( UUID ownerId )  { super ( ownerId, 147, "Malicious Intent", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . AddAbility )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; Ability gainedAbility = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new CantBlockTargetEffect ( Duration . EndOfTurn ) , new TapSourceCost (  )  ) ; gainedAbility . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( gainedAbility, AttachmentType . AURA )  )  ) ; } public MaliciousIntent ( final MaliciousIntent card )  { super ( card ) ; } @Override public MaliciousIntent copy (  )  { return new MaliciousIntent ( this ) ; } } 
public class Malignus extends CardImpl { public Malignus ( UUID ownerId )  { super ( ownerId, 148, "Malignus", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{3}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 0 ) ; this . toughness = new MageInt ( 0 ) ; this . addAbility ( new SimpleStaticAbility ( Zone . ALL, new SetPowerToughnessSourceEffect ( new HighestLifeTotalAmongOpponentsCount (  ) , Duration . EndOfGame )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new MalignusEffect (  )  )  ) ; } public Malignus ( final Malignus card )  { super ( card ) ; } @Override public Malignus copy (  )  { return new Malignus ( this ) ; } } class HighestLifeTotalAmongOpponentsCount implements DynamicValue { @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { if  ( sourceAbility != null )  { Player controller = game . getPlayer ( sourceAbility . getControllerId (  )  ) ; if  ( controller != null )  { int max = 0; for  ( UUID uuid : game . getOpponents ( controller . getId (  )  )  )  { Player opponent = game . getPlayer ( uuid ) ; if  ( opponent != null )  { if  ( opponent . getLife (  )  > max )  { max = opponent . getLife (  ) ; } } } return  ( int ) Math . ceil ( max / 2 . 0 ) ; } } return 0; } @Override public DynamicValue copy (  )  { return new CardsInControllerHandCount (  ) ; } @Override public String getMessage (  )  { return "half the highest life total among your opponents, rounded up"; } @Override public String toString (  )  { return "1"; } } class MalignusEffect extends ContinuousRuleModifyingEffectImpl { public MalignusEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Damage that would be dealt by {this} can't be prevented"; } public MalignusEffect ( final MalignusEffect effect )  { super ( effect ) ; } @Override public MalignusEffect copy (  )  { return new MalignusEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . PREVENT_DAMAGE; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return event . getSourceId (  )  . equals ( source . getSourceId (  )  ) ; } } 
public class MarrowBats extends CardImpl { public MarrowBats ( UUID ownerId )  { super ( ownerId, 113, "Marrow Bats", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Bat" ) ; this . subtype . add ( "Skeleton" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new RegenerateSourceEffect (  ) , new PayLifeCost ( 4 )  )  ) ; } public MarrowBats ( final MarrowBats card )  { super ( card ) ; } @Override public MarrowBats copy (  )  { return new MarrowBats ( this ) ; } } 
public class MassAppeal extends CardImpl { private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "Human you control" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public MassAppeal ( UUID ownerId )  { super ( ownerId, 66, "Mass Appeal", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DrawCardSourceControllerEffect ( new PermanentsOnBattlefieldCount ( filter )  )  ) ; } public MassAppeal ( final MassAppeal card )  { super ( card ) ; } @Override public MassAppeal copy (  )  { return new MassAppeal ( this ) ; } } 
public class MentalAgony extends CardImpl { public MentalAgony ( UUID ownerId )  { super ( ownerId, 114, "Mental Agony", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{3}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DiscardTargetEffect ( 2 )  ) ; this . getSpellAbility (  )  . addEffect ( new LoseLifeTargetEffect ( 2 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPlayer (  )  ) ; } public MentalAgony ( final MentalAgony card )  { super ( card ) ; } @Override public MentalAgony copy (  )  { return new MentalAgony ( this ) ; } } 
public class MidnightDuelist extends CardImpl { private static final FilterPermanent filter = new FilterCreaturePermanent ( "Vampires" ) ; static { filter . add ( new SubtypePredicate ( "Vampire" )  ) ; } public MidnightDuelist ( UUID ownerId )  { super ( ownerId, 27, "Midnight Duelist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new ProtectionAbility ( filter )  ) ; } public MidnightDuelist ( final MidnightDuelist card )  { super ( card ) ; } @Override public MidnightDuelist copy (  )  { return new MidnightDuelist ( this ) ; } } 
public class MidvastProtector extends CardImpl { public MidvastProtector ( UUID ownerId )  { super ( ownerId, 28, "Midvast Protector", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new GainProtectionFromColorTargetEffect ( Duration . EndOfTurn ) , false ) ; ability . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MidvastProtector ( final MidvastProtector card )  { super ( card ) ; } @Override public MidvastProtector copy (  )  { return new MidvastProtector ( this ) ; } } 
public class MisthollowGriffin extends CardImpl { public MisthollowGriffin ( UUID ownerId )  { super ( ownerId, 68, "Misthollow Griffin", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Griffin" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . EXILED, new MisthollowGriffinPlayEffect (  )  )  ) ; } public MisthollowGriffin ( final MisthollowGriffin card )  { super ( card ) ; } @Override public MisthollowGriffin copy (  )  { return new MisthollowGriffin ( this ) ; } } class MisthollowGriffinPlayEffect extends AsThoughEffectImpl { public MisthollowGriffinPlayEffect (  )  { super ( AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE, Duration . EndOfGame, Outcome . Benefit ) ; staticText = "You may cast {this} from exile"; } public MisthollowGriffinPlayEffect ( final MisthollowGriffinPlayEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public MisthollowGriffinPlayEffect copy (  )  { return new MisthollowGriffinPlayEffect ( this ) ; } @Override public boolean applies ( UUID sourceId, Ability source, UUID affectedControllerId, Game game )  { if  ( sourceId . equals ( source . getSourceId (  )  )  )  { Card card = game . getCard ( source . getSourceId (  )  ) ; if  ( card != null && card . getOwnerId (  )  . equals ( source . getControllerId (  )  )  && game . getState (  )  . getZone ( source . getSourceId (  )  )  == Zone . EXILED )  { return true; } } return false; } } 
public class MistRaven extends CardImpl { public MistRaven ( UUID ownerId )  { super ( ownerId, 67, "Mist Raven", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Bird" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new EntersBattlefieldTriggeredAbility ( new ReturnToHandTargetEffect (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public MistRaven ( final MistRaven card )  { super ( card ) ; } @Override public MistRaven copy (  )  { return new MistRaven ( this ) ; } } 
public class MoonlightGeist extends CardImpl { public MoonlightGeist ( UUID ownerId )  { super ( ownerId, 29, "Moonlight Geist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PreventCombatDamageToSourceEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}{W}" )  ) ; ability . addEffect ( new PreventCombatDamageBySourceEffect ( Duration . EndOfTurn )  ) ; this . addAbility ( ability ) ; } public MoonlightGeist ( final MoonlightGeist card )  { super ( card ) ; } @Override public MoonlightGeist copy (  )  { return new MoonlightGeist ( this ) ; } } 
public class MoonsilverSpear extends CardImpl { public MoonsilverSpear ( UUID ownerId )  { super ( ownerId, 217, "Moonsilver Spear", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Equipment" ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityAttachedEffect ( FirstStrikeAbility . getInstance (  ) , AttachmentType . EQUIPMENT )  )  ) ; this . addAbility ( new AttacksAttachedTriggeredAbility ( new CreateTokenEffect ( new AngelToken (  )  )  )  ) ; this . addAbility ( new EquipAbility ( Outcome . AddAbility, new GenericManaCost ( 4 )  )  ) ; } public MoonsilverSpear ( final MoonsilverSpear card )  { super ( card ) ; } @Override public MoonsilverSpear copy (  )  { return new MoonsilverSpear ( this ) ; } } 
public class NaturalEnd extends CardImpl { public NaturalEnd ( UUID ownerId )  { super ( ownerId, 185, "Natural End", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( new GainLifeEffect ( 3 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetPermanent ( new FilterArtifactOrEnchantmentPermanent (  )  )  ) ; } public NaturalEnd ( final NaturalEnd card )  { super ( card ) ; } @Override public NaturalEnd copy (  )  { return new NaturalEnd ( this ) ; } } 
public class NearheathPilgrim extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have lifelink"; public NearheathPilgrim ( UUID ownerId )  { super ( ownerId, 31, "Nearheath Pilgrim", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{1}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Cleric" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( LifelinkAbility . getInstance (  ) , ruleText )  )  ) ; } public NearheathPilgrim ( final NearheathPilgrim card )  { super ( card ) ; } @Override public NearheathPilgrim copy (  )  { return new NearheathPilgrim ( this ) ; } } 
public class Necrobite extends CardImpl { public Necrobite ( UUID ownerId )  { super ( ownerId, 115, "Necrobite", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( DeathtouchAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new RegenerateTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public Necrobite ( final Necrobite card )  { super ( card ) ; } @Override public Necrobite copy (  )  { return new Necrobite ( this ) ; } } 
public class NephaliaSmuggler extends CardImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "another target creature you control" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; } public NephaliaSmuggler ( UUID ownerId )  { super ( ownerId, 69, "Nephalia Smuggler", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Rogue" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new ExileTargetForSourceEffect (  ) , new ManaCostsImpl ( "{3}{U}" )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addEffect ( new ReturnToBattlefieldUnderYourControlTargetEffect ( true )  ) ; ability . addTarget ( new TargetControlledCreaturePermanent ( filter )  ) ; this . addAbility ( ability ) ; } public NephaliaSmuggler ( final NephaliaSmuggler card )  { super ( card ) ; } @Override public NephaliaSmuggler copy (  )  { return new NephaliaSmuggler ( this ) ; } } 
public class NettleSwine extends CardImpl { public NettleSwine ( UUID ownerId )  { super ( ownerId, 186, "Nettle Swine", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Boar" ) ; this . power = new MageInt ( 4 ) ; this . toughness = new MageInt ( 3 ) ; } public NettleSwine ( final NettleSwine card )  { super ( card ) ; } @Override public NettleSwine copy (  )  { return new NettleSwine ( this ) ; } } 
public class NightshadePeddler extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have deathtouch"; public NightshadePeddler ( UUID ownerId )  { super ( ownerId, 187, "Nightshade Peddler", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Druid" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( DeathtouchAbility . getInstance (  ) , ruleText )  )  ) ; } public NightshadePeddler ( final NightshadePeddler card )  { super ( card ) ; } @Override public NightshadePeddler copy (  )  { return new NightshadePeddler ( this ) ; } } 
public class OtherworldAtlas extends CardImpl { public OtherworldAtlas ( UUID ownerId )  { super ( ownerId, 219, "Otherworld Atlas", Rarity . RARE, new CardType[]{CardType . ARTIFACT}, "{4}" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new AddCountersSourceEffect ( CounterType . CHARGE . createInstance (  )  ) , new TapSourceCost (  )  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new OtherworldAtlasDrawEffect (  ) , new TapSourceCost (  )  )  ) ; } public OtherworldAtlas ( final OtherworldAtlas card )  { super ( card ) ; } @Override public OtherworldAtlas copy (  )  { return new OtherworldAtlas ( this ) ; } } class OtherworldAtlasDrawEffect extends OneShotEffect { public OtherworldAtlasDrawEffect (  )  { super ( Outcome . DrawCard ) ; staticText = "Each player draws a card for each charge counter on {this}"; } public OtherworldAtlasDrawEffect ( final OtherworldAtlasDrawEffect effect )  { super ( effect ) ; } @Override public OtherworldAtlasDrawEffect copy (  )  { return new OtherworldAtlasDrawEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player sourcePlayer = game . getPlayer ( source . getControllerId (  )  ) ; Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { int amount = permanent . getCounters (  )  . getCount ( CounterType . CHARGE ) ; if  ( amount > 0 )  { for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( sourcePlayer . getId (  ) , game )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { player . drawCards ( amount, game ) ; } } } } return true; } } 
public class Outwit extends CardImpl { private static FilterSpell filter = new FilterSpell ( "spell that targets a player" ) ; public Outwit ( UUID ownerId )  { super ( ownerId, 70, "Outwit", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new CustomTargetSpell ( filter )  ) ; } public Outwit ( final Outwit card )  { super ( card ) ; } @Override public Outwit copy (  )  { return new Outwit ( this ) ; } private class CustomTargetSpell extends TargetObject { protected FilterSpell filter; public CustomTargetSpell (  )  { this ( 1, 1, new FilterSpell (  )  ) ; } public CustomTargetSpell ( FilterSpell filter )  { this ( 1, 1, filter ) ; } public CustomTargetSpell ( int numTargets, FilterSpell filter )  { this ( numTargets, numTargets, filter ) ; } public CustomTargetSpell ( int minNumTargets, int maxNumTargets, FilterSpell filter )  { this . minNumberOfTargets = minNumTargets; this . maxNumberOfTargets = maxNumTargets; this . zone = Zone . STACK; this . filter = filter; this . targetName = filter . getMessage (  ) ; } public CustomTargetSpell ( final CustomTargetSpell target )  { super ( target ) ; this . filter = target . filter . copy (  ) ; } @Override public boolean canChoose ( UUID sourceId, UUID sourceControllerId, Game game )  { return canChoose ( sourceControllerId, game ) ; } @Override public Set<UUID> possibleTargets ( UUID sourceId, UUID sourceControllerId, Game game )  { return possibleTargets ( sourceControllerId, game ) ; } @Override public boolean canTarget ( UUID id, Ability source, Game game )  { if  ( super . canTarget ( id, source, game )  )  { if  ( targetsPlayer ( id, game )  )  { return true; } } return false; } @Override public boolean canChoose ( UUID sourceControllerId, Game game )  { int count = 0; for  ( StackObject stackObject : game . getStack (  )  )  { if  ( stackObject instanceof Spell && filter . match (  ( Spell )  stackObject, game )  )  { if  ( targetsPlayer ( stackObject . getId (  ) , game )  )  { count++; if  ( count >= this . minNumberOfTargets )  { return true; } } } } return false; } @Override public Set<UUID> possibleTargets ( UUID sourceControllerId, Game game )  { Set<UUID> possibleTargets = new HashSet<UUID> (  ) ; for  ( StackObject stackObject : game . getStack (  )  )  { if  ( stackObject instanceof Spell && filter . match (  ( Spell )  stackObject, game )  )  { if  ( targetsPlayer ( stackObject . getId (  ) , game )  )  { possibleTargets . add ( stackObject . getId (  )  ) ; } } } return possibleTargets; } @Override public Filter getFilter (  )  { return filter; } private boolean targetsPlayer ( UUID id, Game game )  { StackObject spell = game . getStack (  )  . getStackObject ( id ) ; if  ( spell != null )  { Ability ability = spell . getStackAbility (  ) ; if  ( ability != null && !ability . getTargets (  )  . isEmpty (  )  )  { for  ( Target target : ability . getTargets (  )  )  { for  ( UUID playerId : target . getTargets (  )  )  { Player player = game . getPlayer ( playerId ) ; if  ( player != null )  { return true; } } } } } return false; } @Override public CustomTargetSpell copy (  )  { return new CustomTargetSpell ( this ) ; } } } 
public class PathbreakerWurm extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have trample"; public PathbreakerWurm ( UUID ownerId )  { super ( ownerId, 188, "Pathbreaker Wurm", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Wurm" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( TrampleAbility . getInstance (  ) , ruleText )  )  ) ; } public PathbreakerWurm ( final PathbreakerWurm card )  { super ( card ) ; } @Override public PathbreakerWurm copy (  )  { return new PathbreakerWurm ( this ) ; } } 
public class PeelFromReality extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "creature you don't control" ) ; static { filter . add ( new ControllerPredicate ( TargetController . NOT_YOU )  ) ; } public PeelFromReality ( UUID ownerId )  { super ( ownerId, 71, "Peel from Reality", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new PeelFromRealityEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent ( filter )  ) ; } public PeelFromReality ( final PeelFromReality card )  { super ( card ) ; } @Override public PeelFromReality copy (  )  { return new PeelFromReality ( this ) ; } } class PeelFromRealityEffect extends OneShotEffect { public PeelFromRealityEffect (  )  { super ( Outcome . ReturnToHand ) ; this . staticText = "Return target creature you control and target creature you don't control to their owners' hands"; } public PeelFromRealityEffect ( final PeelFromRealityEffect effect )  { super ( effect ) ; } @Override public PeelFromRealityEffect copy (  )  { return new PeelFromRealityEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { boolean result = false; Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( permanent != null )  { result |= permanent . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; } permanent = game . getPermanent ( source . getTargets (  )  . get ( 1 )  . getFirstTarget (  )  ) ; if  ( permanent != null )  { result |= permanent . moveToZone ( Zone . HAND, source . getSourceId (  ) , game, false ) ; } return result; } } 
public class PillarOfFlame extends CardImpl { public PillarOfFlame ( UUID ownerId )  { super ( ownerId, 149, "Pillar of Flame", Rarity . COMMON, new CardType[]{CardType . SORCERY}, "{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 2 )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreatureOrPlayer (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DealtDamageToCreatureBySourceDies ( this, Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addWatcher ( new DamagedByWatcher (  )  ) ; } public PillarOfFlame ( final PillarOfFlame card )  { super ( card ) ; } @Override public PillarOfFlame copy (  )  { return new PillarOfFlame ( this ) ; } } 
public class PollutedDead extends CardImpl { public PollutedDead ( UUID ownerId )  { super ( ownerId, 116, "Polluted Dead", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new DiesTriggeredAbility ( new DestroyTargetEffect (  )  ) ; Target target = new TargetLandPermanent (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; } public PollutedDead ( final PollutedDead card )  { super ( card ) ; } @Override public PollutedDead copy (  )  { return new PollutedDead ( this ) ; } } 
public class PredatorsGambit extends CardImpl { private static final String rule = "Enchanted creature has intimidate as long as its controller controls no other creatures"; public PredatorsGambit ( UUID ownerId )  { super ( ownerId, 117, "Predator's Gambit", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . BoostCreature )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 1, Duration . WhileOnBattlefield )  )  ) ; ContinuousEffect effect = new GainAbilityAttachedEffect ( IntimidateAbility . getInstance (  ) , AttachmentType . AURA ) ; ConditionalContinuousEffect intimidate = new ConditionalContinuousEffect ( effect, new OneControlledCreatureCondition (  ) , rule ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, intimidate )  ) ; } public PredatorsGambit ( final PredatorsGambit card )  { super ( card ) ; } @Override public PredatorsGambit copy (  )  { return new PredatorsGambit ( this ) ; } } 
public class PrimalSurge extends CardImpl { public PrimalSurge ( UUID ownerId )  { super ( ownerId, 189, "Primal Surge", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{8}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new PrimalSurgeEffect (  )  ) ; } public PrimalSurge ( final PrimalSurge card )  { super ( card ) ; } @Override public PrimalSurge copy (  )  { return new PrimalSurge ( this ) ; } } class PrimalSurgeEffect extends OneShotEffect { public PrimalSurgeEffect (  )  { super ( Outcome . PutCardInPlay ) ; this . staticText = "Exile the top card of your library .  If it's a permanent card, you may put it onto the battlefield .  If you do, repeat this process"; } public PrimalSurgeEffect ( final PrimalSurgeEffect effect )  { super ( effect ) ; } @Override public PrimalSurgeEffect copy (  )  { return new PrimalSurgeEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; if  ( player == null )  { return false; } boolean repeat; do { repeat = false; if  ( player . getLibrary (  )  . size (  )  > 0 )  { Card card = player . getLibrary (  )  . removeFromTop ( game ) ; if  ( card != null )  { card . moveToExile ( null, "", source . getSourceId (  ) , game ) ; List<CardType> cardType = card . getCardType (  ) ; if  (  ( cardType . contains ( CardType . ARTIFACT )  || cardType . contains ( CardType . CREATURE )  || cardType . contains ( CardType . ENCHANTMENT )  || cardType . contains ( CardType . LAND )  || cardType . contains ( CardType . PLANESWALKER )  )  && player . chooseUse ( Outcome . PutCardInPlay, "Put " + card . getName (  )  + " onto the battlefield?", source, game )  )  { card . moveToZone ( Zone . BATTLEFIELD, source . getSourceId (  ) , game, false ) ; Permanent permanent = game . getPermanent ( card . getId (  )  ) ; if  ( permanent == null )  { permanent =  ( Permanent )  game . getLastKnownInformation ( card . getId (  ) , Zone . BATTLEFIELD ) ; } if  ( permanent != null )  { repeat = true; } } } } } while  ( player . canRespond (  )  && repeat ) ; return true; } } 
public class RagingPoltergeist extends CardImpl { public RagingPoltergeist ( UUID ownerId )  { super ( ownerId, 150, "Raging Poltergeist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 1 ) ; } public RagingPoltergeist ( final RagingPoltergeist card )  { super ( card ) ; } @Override public RagingPoltergeist copy (  )  { return new RagingPoltergeist ( this ) ; } } 
public class RainOfThorns extends CardImpl { public RainOfThorns ( UUID ownerId )  { super ( ownerId, 190, "Rain of Thorns", Rarity . UNCOMMON, new CardType[]{CardType . SORCERY}, "{4}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DestroyTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetArtifactPermanent (  )  ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 1 ) ; this . getSpellAbility (  )  . getModes (  )  . setMaxModes ( 3 ) ; Mode mode1 = new Mode (  ) ; mode1 . getEffects (  )  . add ( new DestroyTargetEffect (  )  ) ; mode1 . getTargets (  )  . add ( new TargetPermanent ( new FilterEnchantmentPermanent (  )  )  ) ; this . getSpellAbility (  )  . addMode ( mode1 ) ; Mode mode2 = new Mode (  ) ; mode2 . getEffects (  )  . add ( new DestroyTargetEffect (  )  ) ; mode2 . getTargets (  )  . add ( new TargetPermanent ( new FilterLandPermanent (  )  )  ) ; this . getSpellAbility (  )  . addMode ( mode2 ) ; } public RainOfThorns ( final RainOfThorns card )  { super ( card ) ; } @Override public RainOfThorns copy (  )  { return new RainOfThorns ( this ) ; } } 
public class ReforgeTheSoul extends CardImpl { public ReforgeTheSoul ( UUID ownerId )  { super ( ownerId, 151, "Reforge the Soul", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new DiscardHandAllEffect (  )  ) ; Effect effect = new DrawCardAllEffect ( 7 ) ; effect . setText ( ", then draws seven cards" ) ; this . getSpellAbility (  )  . addEffect ( effect ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{1}{R}" )  )  ) ; } public ReforgeTheSoul ( final ReforgeTheSoul card )  { super ( card ) ; } @Override public ReforgeTheSoul copy (  )  { return new ReforgeTheSoul ( this ) ; } } 
public class RenegadeDemon extends CardImpl { public RenegadeDemon ( UUID ownerId )  { super ( ownerId, 118, "Renegade Demon", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{3}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 3 ) ; } public RenegadeDemon ( final RenegadeDemon card )  { super ( card ) ; } @Override public RenegadeDemon copy (  )  { return new RenegadeDemon ( this ) ; } } 
public class RidersOfGavony extends CardImpl { public RidersOfGavony ( UUID ownerId )  { super ( ownerId, 33, "Riders of Gavony", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{2}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( VigilanceAbility . getInstance (  )  ) ; this . addAbility ( new AsEntersBattlefieldAbility ( new ChooseCreatureTypeEffect ( Outcome . Protect )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new RidersOfGavonyGainAbilityControlledEffect (  )  )  ) ; } public RidersOfGavony ( final RidersOfGavony card )  { super ( card ) ; } @Override public RidersOfGavony copy (  )  { return new RidersOfGavony ( this ) ; } } class RidersOfGavonyGainAbilityControlledEffect extends ContinuousEffectImpl { private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "Human creatures you control" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } protected FilterPermanent protectionFilter; public RidersOfGavonyGainAbilityControlledEffect (  )  { super ( Duration . WhileOnBattlefield, Layer . AbilityAddingRemovingEffects_6, SubLayer . NA, Outcome . AddAbility ) ; staticText = "Human creatures you control have protection from creatures of the chosen type"; } public RidersOfGavonyGainAbilityControlledEffect ( final RidersOfGavonyGainAbilityControlledEffect effect )  { super ( effect ) ; protectionFilter = effect . protectionFilter; } @Override public RidersOfGavonyGainAbilityControlledEffect copy (  )  { return new RidersOfGavonyGainAbilityControlledEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { if  ( protectionFilter == null )  { Permanent permanent = game . getPermanent ( source . getSourceId (  )  ) ; if  ( permanent != null )  { String subtype =  ( String )  game . getState (  )  . getValue ( permanent . getId (  )  + "_type" ) ; if  ( subtype != null )  { protectionFilter = new FilterPermanent ( subtype + "s" ) ; protectionFilter . add ( new SubtypePredicate ( subtype )  ) ; } } } if  ( protectionFilter != null )  { for  ( Permanent perm : game . getBattlefield (  )  . getAllActivePermanents ( filter, source . getControllerId (  ) , game )  )  { perm . addAbility ( new ProtectionAbility ( protectionFilter ) , source . getSourceId (  ) , game ) ; } return true; } return false; } } 
public class RighteousBlow extends CardImpl { public RighteousBlow ( UUID ownerId )  { super ( ownerId, 34, "Righteous Blow", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addTarget ( new TargetAttackingOrBlockingCreature (  )  ) ; this . getSpellAbility (  )  . addEffect ( new DamageTargetEffect ( 2 )  ) ; } public RighteousBlow ( final RighteousBlow card )  { super ( card ) ; } @Override public RighteousBlow copy (  )  { return new RighteousBlow ( this ) ; } } 
public class RiotRingleader extends CardImpl { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "Human creatures" ) ; static { filter . add ( new SubtypePredicate ( "Human" )  ) ; } public RiotRingleader ( UUID ownerId )  { super ( ownerId, 152, "Riot Ringleader", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new AttacksTriggeredAbility ( new BoostControlledEffect ( 1, 0, Duration . EndOfTurn, filter ) , false )  ) ; } public RiotRingleader ( final RiotRingleader card )  { super ( card ) ; } @Override public RiotRingleader copy (  )  { return new RiotRingleader ( this ) ; } } 
public class RiteOfRuin extends CardImpl { public RiteOfRuin ( UUID ownerId )  { super ( ownerId, 153, "Rite of Ruin", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{5}{R}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new RiteOfRuinEffect (  )  ) ; } public RiteOfRuin ( final RiteOfRuin card )  { super ( card ) ; } @Override public RiteOfRuin copy (  )  { return new RiteOfRuin ( this ) ; } } class RiteOfRuinEffect extends OneShotEffect { public RiteOfRuinEffect (  )  { super ( Outcome . Sacrifice ) ; this . staticText = "Choose an order for artifacts, creatures, and lands .  Each player sacrifices one permanent of the first type, sacrifices two of the second type, then sacrifices three of the third type"; } public RiteOfRuinEffect ( final RiteOfRuinEffect effect )  { super ( effect ) ; } @Override public RiteOfRuinEffect copy (  )  { return new RiteOfRuinEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player controller = game . getPlayer ( source . getControllerId (  )  ) ; if  ( controller == null )  { return false; } HashSet<String> choices = new HashSet<> (  ) ; choices . add ( "Artifacts" ) ; choices . add ( "Creatures" ) ; choices . add ( "Lands" ) ; LinkedList<CardType> order = new LinkedList<> (  ) ; ChoiceImpl choice = new ChoiceImpl ( true ) ; choice . setChoices ( choices ) ; while  ( controller . canRespond (  )  && controller . choose ( Outcome . Sacrifice, choice, game )  && choices . size (  )  > 1 )  { order . add ( getCardType ( choice . getChoice (  )  )  ) ; choices . remove ( choice . getChoice (  )  ) ; choice . clearChoice (  ) ; } order . add ( getCardType ( choices . iterator (  )  . next (  )  )  ) ; LinkedList<UUID> sacrifices = new LinkedList<> (  ) ; int count = 1; for  ( CardType cardType : order )  { FilterControlledPermanent filter = new FilterControlledPermanent ( cardType + " permanent you control" ) ; filter . add ( new CardTypePredicate ( cardType )  ) ; for  ( UUID playerId : game . getState (  )  . getPlayersInRange ( controller . getId (  ) , game )  )  { int amount = Math . min ( count, game . getBattlefield (  )  . countAll ( filter, playerId, game )  ) ; TargetControlledPermanent target = new TargetControlledPermanent ( amount, amount, filter, false ) ; Player player = game . getPlayer ( playerId ) ; if  ( player != null && player . choose ( Outcome . Sacrifice, target, source . getSourceId (  ) , game )  )  { sacrifices . addAll ( target . getTargets (  )  ) ; } } for  ( UUID targetId : sacrifices )  { Permanent permanent = game . getPermanent ( targetId ) ; if  ( permanent != null )  { permanent . sacrifice ( source . getSourceId (  ) , game ) ; } } sacrifices . clear (  ) ; count++; } return true; } private CardType getCardType ( String type )  { if  ( "Artifacts" . equals ( type )  )  { return CardType . ARTIFACT; } if  ( "Creatures" . equals ( type )  )  { return CardType . CREATURE; } if  ( "Lands" . equals ( type )  )  { return CardType . LAND; } return null; } } 
public class RotcrownGhoul extends CardImpl { public RotcrownGhoul ( UUID ownerId )  { super ( ownerId, 72, "Rotcrown Ghoul", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 3 ) ; Ability ability = new DiesTriggeredAbility ( new PutLibraryIntoGraveTargetEffect ( 5 )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public RotcrownGhoul ( final RotcrownGhoul card )  { super ( card ) ; } @Override public RotcrownGhoul copy (  )  { return new RotcrownGhoul ( this ) ; } } 
public class RushOfBlood extends CardImpl { public RushOfBlood ( UUID ownerId )  { super ( ownerId, 154, "Rush of Blood", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{2}{R}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new BoostTargetEffect ( new TargetPermanentPowerCount (  ) , new StaticValue ( 0 ) , Duration . EndOfTurn, true )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public RushOfBlood ( final RushOfBlood card )  { super ( card ) ; } @Override public RushOfBlood copy (  )  { return new RushOfBlood ( this ) ; } } 
public class ScaldingDevil extends CardImpl { public ScaldingDevil ( UUID ownerId )  { super ( ownerId, 155, "Scalding Devil", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Devil" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DamageTargetEffect ( 1 ) , new ManaCostsImpl ( "{2}{R}" )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; } public ScaldingDevil ( final ScaldingDevil card )  { super ( card ) ; } @Override public ScaldingDevil copy (  )  { return new ScaldingDevil ( this ) ; } } 
public class ScrapskinDrake extends CardImpl { public ScrapskinDrake ( UUID ownerId )  { super ( ownerId, 73, "Scrapskin Drake", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Zombie" ) ; this . subtype . add ( "Drake" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 3 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new CanBlockOnlyFlyingAbility (  )  ) ; } public ScrapskinDrake ( final ScrapskinDrake card )  { super ( card ) ; } @Override public ScrapskinDrake copy (  )  { return new ScrapskinDrake ( this ) ; } } 
public class ScrollOfAvacyn extends CardImpl { private static final FilterPermanent filter = new FilterPermanent (  ) ; static { filter . add ( new SubtypePredicate ( "Angel" )  ) ; } public ScrollOfAvacyn ( UUID ownerId )  { super ( ownerId, 220, "Scroll of Avacyn", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "AVR"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addEffect ( new ConditionalOneShotEffect ( new GainLifeEffect ( 5 ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "If you control an Angel, you gain 5 life" )  ) ; this . addAbility ( ability ) ; } public ScrollOfAvacyn ( final ScrollOfAvacyn card )  { super ( card ) ; } @Override public ScrollOfAvacyn copy (  )  { return new ScrollOfAvacyn ( this ) ; } } 
public class ScrollOfGriselbrand extends CardImpl { private static final FilterPermanent filter = new FilterPermanent (  ) ; static { filter . add ( new SubtypePredicate ( "Demon" )  ) ; } public ScrollOfGriselbrand ( UUID ownerId )  { super ( ownerId, 221, "Scroll of Griselbrand", Rarity . COMMON, new CardType[]{CardType . ARTIFACT}, "{1}" ) ; this . expansionSetCode = "AVR"; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new DiscardTargetEffect ( 1 ) , new GenericManaCost ( 1 )  ) ; ability . addCost ( new SacrificeSourceCost (  )  ) ; ability . addEffect ( new ConditionalOneShotEffect ( new LoseLifeTargetEffect ( 3 ) , new PermanentsOnTheBattlefieldCondition ( filter ) , "If you control a Demon, that player loses 3 life" )  ) ; ability . addTarget ( new TargetOpponent (  )  ) ; this . addAbility ( ability ) ; } public ScrollOfGriselbrand ( final ScrollOfGriselbrand card )  { super ( card ) ; } @Override public ScrollOfGriselbrand copy (  )  { return new ScrollOfGriselbrand ( this ) ; } } 
public class SearchlightGeist extends CardImpl { public SearchlightGeist ( UUID ownerId )  { super ( ownerId, 119, "Searchlight Geist", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD, new GainAbilitySourceEffect ( DeathtouchAbility . getInstance (  ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "{3}{B}" )  )  ) ; } public SearchlightGeist ( final SearchlightGeist card )  { super ( card ) ; } @Override public SearchlightGeist copy (  )  { return new SearchlightGeist ( this ) ; } } 
public class SecondGuess extends CardImpl { private static final FilterSpell filter = new FilterSpell ( "spell that's the second spell cast this turn" ) ; static { filter . add ( new SecondSpellPredicate (  )  ) ; } public SecondGuess ( UUID ownerId )  { super ( ownerId, 74, "Second Guess", Rarity . UNCOMMON, new CardType[]{CardType . INSTANT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new CounterTargetEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetSpell ( filter )  ) ; } public SecondGuess ( final SecondGuess card )  { super ( card ) ; } @Override public SecondGuess copy (  )  { return new SecondGuess ( this ) ; } } class SecondSpellPredicate implements Predicate<Spell> { @Override public boolean apply ( Spell input, Game game )  { CastSpellLastTurnWatcher watcher =  ( CastSpellLastTurnWatcher )  game . getState (  )  . getWatchers (  )  . get ( "CastSpellLastTurnWatcher" ) ; if  ( watcher . getSpellOrder ( new MageObjectReference ( input . getId (  ) , game ) , game )  == 2 )  { return true; } return false; } @Override public String toString (  )  { return "SecondSpellThisTurn"; } } 
public class SeraphOfDawn extends CardImpl { public SeraphOfDawn ( UUID ownerId )  { super ( ownerId, 35, "Seraph of Dawn", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{2}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 4 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( LifelinkAbility . getInstance (  )  ) ; } public SeraphOfDawn ( final SeraphOfDawn card )  { super ( card ) ; } @Override public SeraphOfDawn copy (  )  { return new SeraphOfDawn ( this ) ; } } 
public class SeraphSanctuary extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "an Angel" ) ; static { filter . add ( new SubtypePredicate ( "Angel" )  ) ; } public SeraphSanctuary ( UUID ownerId )  { super ( ownerId, 228, "Seraph Sanctuary", Rarity . COMMON, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( 1 )  )  ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( new GainLifeEffect ( 1 ) , filter )  ) ; this . addAbility ( new ColorlessManaAbility (  )  ) ; } public SeraphSanctuary ( final SeraphSanctuary card )  { super ( card ) ; } @Override public SeraphSanctuary copy (  )  { return new SeraphSanctuary ( this ) ; } } 
public class ShelteringWord extends CardImpl { public ShelteringWord ( UUID ownerId )  { super ( ownerId, 192, "Sheltering Word", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new GainAbilityTargetEffect ( HexproofAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; this . getSpellAbility (  )  . addEffect ( new ShelteringWordEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetControlledCreaturePermanent (  )  ) ; } public ShelteringWord ( final ShelteringWord card )  { super ( card ) ; } @Override public ShelteringWord copy (  )  { return new ShelteringWord ( this ) ; } } class ShelteringWordEffect extends OneShotEffect { public ShelteringWordEffect (  )  { super ( Outcome . GainLife ) ; this . staticText = "You gain life equal to that creature's toughness"; } public ShelteringWordEffect ( final ShelteringWordEffect effect )  { super ( effect ) ; } @Override public ShelteringWordEffect copy (  )  { return new ShelteringWordEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player player = game . getPlayer ( source . getControllerId (  )  ) ; Permanent permanent = game . getPermanent ( source . getFirstTarget (  )  ) ; if  ( player != null && permanent != null )  { int amount = permanent . getToughness (  )  . getValue (  ) ; if  ( amount > 0 )  { player . gainLife ( amount, game ) ; return true; } } return false; } } 
public class SigardaHostOfHerons extends CardImpl { public SigardaHostOfHerons ( UUID ownerId )  { super ( ownerId, 210, "Sigarda, Host of Herons", Rarity . MYTHIC, new CardType[]{CardType . CREATURE}, "{2}{G}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . supertype . add ( "Legendary" ) ; this . subtype . add ( "Angel" ) ; this . power = new MageInt ( 5 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( FlyingAbility . getInstance (  )  ) ; this . addAbility ( HexproofAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new SigardaHostOfHeronsEffect (  )  )  ) ; } public SigardaHostOfHerons ( final SigardaHostOfHerons card )  { super ( card ) ; } @Override public SigardaHostOfHerons copy (  )  { return new SigardaHostOfHerons ( this ) ; } } class SigardaHostOfHeronsEffect extends ContinuousRuleModifyingEffectImpl { public SigardaHostOfHeronsEffect (  )  { super ( Duration . WhileOnBattlefield, Outcome . Benefit ) ; staticText = "Spells and abilities your opponents control can't cause you to sacrifice permanents"; } public SigardaHostOfHeronsEffect ( final SigardaHostOfHeronsEffect effect )  { super ( effect ) ; } @Override public SigardaHostOfHeronsEffect copy (  )  { return new SigardaHostOfHeronsEffect ( this ) ; } @Override public boolean checksEventType ( GameEvent event, Game game )  { return event . getType (  )  == GameEvent . EventType . SACRIFICE_PERMANENT; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { if  ( event . getPlayerId (  )  . equals ( source . getControllerId (  )  )  )  { MageObject object = game . getObject ( event . getSourceId (  )  ) ; if  ( object instanceof PermanentCard )  { if  ( game . getOpponents ( source . getControllerId (  )  )  . contains (  (  ( PermanentCard )  object )  . getControllerId (  )  )  )  { return true; } } if  ( object instanceof Spell )  { if  ( game . getOpponents ( source . getControllerId (  )  )  . contains (  (  ( Spell )  object )  . getControllerId (  )  )  )  { return true; } } } return false; } } 
public class SilverbladePaladin extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have double strike"; public SilverbladePaladin ( UUID ownerId )  { super ( ownerId, 36, "Silverblade Paladin", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{1}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Knight" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( DoubleStrikeAbility . getInstance (  ) , ruleText )  )  ) ; } public SilverbladePaladin ( final SilverbladePaladin card )  { super ( card ) ; } @Override public SilverbladePaladin copy (  )  { return new SilverbladePaladin ( this ) ; } } 
public class SlayersStronghold extends CardImpl { public SlayersStronghold ( UUID ownerId )  { super ( ownerId, 229, "Slayers' Stronghold", Rarity . RARE, new CardType[]{CardType . LAND}, "" ) ; this . expansionSetCode = "AVR"; this . addAbility ( new ColorlessManaAbility (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostTargetEffect ( 2, 0, Duration . EndOfTurn ) , new ManaCostsImpl ( "{R}{W}" )  ) ; ability . addEffect ( new GainAbilityTargetEffect ( VigilanceAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; ability . addEffect ( new GainAbilityTargetEffect ( HasteAbility . getInstance (  ) , Duration . EndOfTurn )  ) ; ability . addCost ( new TapSourceCost (  )  ) ; ability . addTarget ( new TargetCreaturePermanent (  )  ) ; this . addAbility ( ability ) ; } public SlayersStronghold ( final SlayersStronghold card )  { super ( card ) ; } @Override public SlayersStronghold copy (  )  { return new SlayersStronghold ( this ) ; } } 
public class SomberwaldVigilante extends CardImpl { public SomberwaldVigilante ( UUID ownerId )  { super ( ownerId, 156, "Somberwald Vigilante", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Warrior" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( new BecomesBlockedByCreatureTriggeredAbility ( new DamageTargetEffect ( 1, true, "that creature" ) , false )  ) ; } public SomberwaldVigilante ( final SomberwaldVigilante card )  { super ( card ) ; } @Override public SomberwaldVigilante copy (  )  { return new SomberwaldVigilante ( this ) ; } } 
public class SoulcageFiend extends CardImpl { public SoulcageFiend ( UUID ownerId )  { super ( ownerId, 120, "Soulcage Fiend", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{1}{B}{B}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Demon" ) ; this . power = new MageInt ( 3 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( new DiesTriggeredAbility ( new LoseLifeAllPlayersEffect ( 3 )  )  ) ; } public SoulcageFiend ( final SoulcageFiend card )  { super ( card ) ; } @Override public SoulcageFiend copy (  )  { return new SoulcageFiend ( this ) ; } } 
public class SoulOfTheHarvest extends CardImpl { private static final FilterPermanent filter = new FilterControlledCreaturePermanent ( "another nontoken creature" ) ; static { filter . add ( new AnotherPredicate (  )  ) ; filter . add ( Predicates . not ( new TokenPredicate (  )  )  ) ; } public SoulOfTheHarvest ( UUID ownerId )  { super ( ownerId, 195, "Soul of the Harvest", Rarity . RARE, new CardType[]{CardType . CREATURE}, "{4}{G}{G}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Elemental" ) ; this . power = new MageInt ( 6 ) ; this . toughness = new MageInt ( 6 ) ; this . addAbility ( TrampleAbility . getInstance (  )  ) ; this . addAbility ( new EntersBattlefieldControlledTriggeredAbility ( Zone . BATTLEFIELD, new DrawCardSourceControllerEffect ( 1 ) , filter, true )  ) ; } public SoulOfTheHarvest ( final SoulOfTheHarvest card )  { super ( card ) ; } @Override public SoulOfTheHarvest copy (  )  { return new SoulOfTheHarvest ( this ) ; } } 
public class SpectralGateguards extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, both creatures have vigilance"; public SpectralGateguards ( UUID ownerId )  { super ( ownerId, 37, "Spectral Gateguards", Rarity . COMMON, new CardType[]{CardType . CREATURE}, "{4}{W}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Spirit" ) ; this . subtype . add ( "Soldier" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 5 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( VigilanceAbility . getInstance (  ) , ruleText )  )  ) ; } public SpectralGateguards ( final SpectralGateguards card )  { super ( card ) ; } @Override public SpectralGateguards copy (  )  { return new SpectralGateguards ( this ) ; } } 
public class SpectralPrison extends CardImpl { public SpectralPrison ( UUID ownerId )  { super ( ownerId, 75, "Spectral Prison", Rarity . COMMON, new CardType[]{CardType . ENCHANTMENT}, "{1}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . Detriment )  ) ; this . addAbility ( new EnchantAbility ( auraTarget . getTargetName (  )  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new DontUntapInControllersUntapStepEnchantedEffect (  )  )  ) ; this . addAbility ( new SpectralPrisonAbility (  )  ) ; } public SpectralPrison ( final SpectralPrison card )  { super ( card ) ; } @Override public SpectralPrison copy (  )  { return new SpectralPrison ( this ) ; } } class SpectralPrisonAbility extends TriggeredAbilityImpl { public SpectralPrisonAbility (  )  { super ( Zone . BATTLEFIELD, new DestroySourceEffect (  )  ) ; } public SpectralPrisonAbility ( final SpectralPrisonAbility ability )  { super ( ability ) ; } @Override public SpectralPrisonAbility copy (  )  { return new SpectralPrisonAbility ( this ) ; } @Override public boolean checkEventType ( GameEvent event, Game game )  { return event . getType (  )  == EventType . TARGETED; } @Override public boolean checkTrigger ( GameEvent event, Game game )  { MageObject eventSourceObject = game . getObject ( event . getSourceId (  )  ) ; if  ( eventSourceObject != null && eventSourceObject instanceof Spell )  { Permanent enchantment = game . getPermanent ( sourceId ) ; if  ( enchantment != null && enchantment . getAttachedTo (  )  != null )  { if  ( event . getTargetId (  )  . equals ( enchantment . getAttachedTo (  )  )  )  { return true; } } } return false; } @Override public String getRule (  )  { return "When enchanted creature becomes the target of a spell or ability, destroy {this} . "; } } 
public class SpiritAway extends CardImpl { public SpiritAway ( UUID ownerId )  { super ( ownerId, 76, "Spirit Away", Rarity . RARE, new CardType[]{CardType . ENCHANTMENT}, "{5}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Aura" ) ; TargetPermanent auraTarget = new TargetCreaturePermanent (  ) ; this . getSpellAbility (  )  . addTarget ( auraTarget ) ; this . getSpellAbility (  )  . addEffect ( new AttachEffect ( Outcome . GainControl )  ) ; Ability ability = new EnchantAbility ( auraTarget . getTargetName (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new ControlEnchantedEffect (  )  )  ) ; SimpleStaticAbility ability2 = new SimpleStaticAbility ( Zone . BATTLEFIELD, new BoostEnchantedEffect ( 2, 2, Duration . WhileOnBattlefield )  ) ; ability2 . addEffect ( new GainAbilityAttachedEffect ( FlyingAbility . getInstance (  ) , AttachmentType . AURA )  ) ; this . addAbility ( ability2 ) ; } public SpiritAway ( final SpiritAway card )  { super ( card ) ; } @Override public SpiritAway copy (  )  { return new SpiritAway ( this ) ; } } 
public class SternMentor extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{T}: Target player puts the top two cards of his or her library into his or her graveyard . \""; public SternMentor ( UUID ownerId )  { super ( ownerId, 77, "Stern Mentor", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Wizard" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 2 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new PutLibraryIntoGraveTargetEffect ( 2 ) , new TapSourceCost (  )  ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public SternMentor ( final SternMentor card )  { super ( card ) ; } @Override public SternMentor copy (  )  { return new SternMentor ( this ) ; } } 
public class StolenGoods extends CardImpl { public StolenGoods ( UUID ownerId )  { super ( ownerId, 78, "Stolen Goods", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{3}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new StolenGoodsEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetOpponent (  )  ) ; } public StolenGoods ( final StolenGoods card )  { super ( card ) ; } @Override public StolenGoods copy (  )  { return new StolenGoods ( this ) ; } } class StolenGoodsEffect extends OneShotEffect { public StolenGoodsEffect (  )  { super ( Outcome . Detriment ) ; this . staticText = "Target opponent exiles cards from the top of his or her library until he or she exiles a nonland card .  Until end of turn, you may cast that card without paying its mana cost"; } public StolenGoodsEffect ( final StolenGoodsEffect effect )  { super ( effect ) ; } @Override public StolenGoodsEffect copy (  )  { return new StolenGoodsEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { Player opponent = game . getPlayer ( targetPointer . getFirst ( game, source )  ) ; MageObject sourceObject = source . getSourceObject ( game ) ; if  ( opponent != null && opponent . getLibrary (  )  . size (  )  > 0 && sourceObject != null )  { Library library = opponent . getLibrary (  ) ; Card card; do { card = library . removeFromTop ( game ) ; if  ( card != null )  { opponent . moveCardsToExile ( card, source, game, true, source . getSourceId (  ) , sourceObject . getIdName (  )  ) ; } } while  ( library . size (  )  > 0 && card != null && card . getCardType (  )  . contains ( CardType . LAND )  ) ; if  ( card != null )  { ContinuousEffect effect = new StolenGoodsCastFromExileEffect (  ) ; effect . setTargetPointer ( new FixedTarget ( card . getId (  ) , card . getZoneChangeCounter ( game )  )  ) ; game . addEffect ( effect, source ) ; } return true; } return false; } } class StolenGoodsCastFromExileEffect extends AsThoughEffectImpl { public StolenGoodsCastFromExileEffect (  )  { super ( AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE, Duration . EndOfTurn, Outcome . Benefit ) ; staticText = "You may cast card from exile"; } public StolenGoodsCastFromExileEffect ( final StolenGoodsCastFromExileEffect effect )  { super ( effect ) ; } @Override public boolean apply ( Game game, Ability source )  { return true; } @Override public StolenGoodsCastFromExileEffect copy (  )  { return new StolenGoodsCastFromExileEffect ( this ) ; } @Override public boolean applies ( UUID sourceId, Ability source, UUID affectedControllerId, Game game )  { if  ( sourceId != null && sourceId . equals ( getTargetPointer (  )  . getFirst ( game, source )  )  && affectedControllerId . equals ( source . getControllerId (  )  )  )  { Card card = game . getCard ( sourceId ) ; if  ( card != null && game . getState (  )  . getZone ( sourceId )  == Zone . EXILED )  { Player player = game . getPlayer ( affectedControllerId ) ; player . setCastSourceIdWithAlternateMana ( sourceId, null, null ) ; return true; } } return false; } } 
public class Stonewright extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{R}: This creature gets +1/+0 until end of turn . \""; public Stonewright ( UUID ownerId )  { super ( ownerId, 157, "Stonewright", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{R}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Shaman" ) ; this . power = new MageInt ( 1 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD, new BoostSourceEffect ( 1, 0, Duration . EndOfTurn ) , new ManaCostsImpl ( "{R}" )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public Stonewright ( final Stonewright card )  { super ( card ) ; } @Override public Stonewright copy (  )  { return new Stonewright ( this ) ; } } 
public class TamiyoTheMoonSage extends CardImpl { public TamiyoTheMoonSage ( UUID ownerId )  { super ( ownerId, 79, "Tamiyo, the Moon Sage", Rarity . MYTHIC, new CardType[]{CardType . PLANESWALKER}, "{3}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Tamiyo" ) ; this . addAbility ( new PlanswalkerEntersWithLoyalityCountersAbility ( 4 )  ) ; LoyaltyAbility ability = new LoyaltyAbility ( new TapTargetEffect (  ) , 1 ) ; ability . addEffect ( new DontUntapInControllersNextUntapStepTargetEffect (  )  ) ; Target target = new TargetPermanent (  ) ; ability . addTarget ( target ) ; this . addAbility ( ability ) ; ability = new LoyaltyAbility ( new DrawCardSourceControllerEffect ( new TappedCreaturesControlledByTargetCount (  )  ) , -2 ) ; ability . addTarget ( new TargetPlayer (  )  ) ; this . addAbility ( ability ) ; this . addAbility ( new LoyaltyAbility ( new GetEmblemEffect ( new TamiyoTheMoonSageEmblem (  )  ) , -8 )  ) ; } public TamiyoTheMoonSage ( final TamiyoTheMoonSage card )  { super ( card ) ; } @Override public TamiyoTheMoonSage copy (  )  { return new TamiyoTheMoonSage ( this ) ; } } class TappedCreaturesControlledByTargetCount implements DynamicValue { private static final FilterCreaturePermanent filter = new FilterCreaturePermanent (  ) ; static { filter . add ( new TappedPredicate (  )  ) ; } @Override public int calculate ( Game game, Ability sourceAbility, Effect effect )  { return game . getBattlefield (  )  . countAll ( filter, sourceAbility . getFirstTarget (  ) , game ) ; } @Override public DynamicValue copy (  )  { return new TappedCreaturesControlledByTargetCount (  ) ; } @Override public String toString (  )  { return "a"; } @Override public String getMessage (  )  { return "tapped creature target player controls"; } } /** * Emblem with "You have no maximum hand size" and "Whenever a card is put into * your graveyard from anywhere, you may return it to your hand . " */ class TamiyoTheMoonSageEmblem extends Emblem { public TamiyoTheMoonSageEmblem (  )  { this . setName ( "EMBLEM: Tamiyo, the Moon Sage" ) ; Ability ability = new SimpleStaticAbility ( Zone . COMMAND, new MaximumHandSizeControllerEffect ( Integer . MAX_VALUE, Duration . EndOfGame, HandSizeModification . SET )  ) ; this . getAbilities (  )  . add ( ability ) ; Effect effect = new ReturnToHandTargetEffect (  ) ; effect . setText ( "return it to your hand" ) ; this . getAbilities (  )  . add ( new PutCardIntoGraveFromAnywhereAllTriggeredAbility (  Zone . COMMAND, effect, true, new FilterCard ( "a card" ) , TargetController . YOU, SetTargetPointer . CARD )  ) ; } } 
public class TandemLookout extends CardImpl { private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"Whenever this creature deals damage to an opponent, draw a card . \""; public TandemLookout ( UUID ownerId )  { super ( ownerId, 80, "Tandem Lookout", Rarity . UNCOMMON, new CardType[]{CardType . CREATURE}, "{2}{U}" ) ; this . expansionSetCode = "AVR"; this . subtype . add ( "Human" ) ; this . subtype . add ( "Scout" ) ; this . power = new MageInt ( 2 ) ; this . toughness = new MageInt ( 1 ) ; this . addAbility ( SoulbondAbility . getInstance (  )  ) ; Ability ability = new DealsDamageToOpponentTriggeredAbility ( new DrawCardSourceControllerEffect ( 1 )  ) ; this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD, new GainAbilityPairedEffect ( ability, ruleText )  )  ) ; } public TandemLookout ( final TandemLookout card )  { super ( card ) ; } @Override public TandemLookout copy (  )  { return new TandemLookout ( this ) ; } } 
public class TemporalMastery extends CardImpl { public TemporalMastery ( UUID ownerId )  { super ( ownerId, 81, "Temporal Mastery", Rarity . MYTHIC, new CardType[]{CardType . SORCERY}, "{5}{U}{U}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new AddExtraTurnControllerEffect (  )  ) ; this . getSpellAbility (  )  . addEffect ( ExileSpellEffect . getInstance (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{1}{U}" )  )  ) ; } public TemporalMastery ( final TemporalMastery card )  { super ( card ) ; } @Override public TemporalMastery copy (  )  { return new TemporalMastery ( this ) ; } } 
public class Terminus extends CardImpl { public Terminus ( UUID ownerId )  { super ( ownerId, 38, "Terminus", Rarity . RARE, new CardType[]{CardType . SORCERY}, "{4}{W}{W}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new TerminusEffect (  )  ) ; this . addAbility ( new MiracleAbility ( this, new ManaCostsImpl ( "{W}" )  )  ) ; } public Terminus ( final Terminus card )  { super ( card ) ; } @Override public Terminus copy (  )  { return new Terminus ( this ) ; } } class TerminusEffect extends OneShotEffect { public TerminusEffect (  )  { super ( Outcome . Removal ) ; this . staticText = "Put all creatures on the bottom of their owners' libraries"; } public TerminusEffect ( final TerminusEffect effect )  { super ( effect ) ; } @Override public TerminusEffect copy (  )  { return new TerminusEffect ( this ) ; } @Override public boolean apply ( Game game, Ability source )  { List<Permanent> permanents = game . getBattlefield (  )  . getActivePermanents (  new FilterCreaturePermanent (  ) , source . getControllerId (  ) , source . getSourceId (  ) , game ) ; for  ( Permanent permanent : permanents )  { permanent . moveToZone ( Zone . LIBRARY, source . getSourceId (  ) , game, false ) ; } return true; } } 
public class TerrifyingPresence extends CardImpl { public TerrifyingPresence ( UUID ownerId )  { super ( ownerId, 196, "Terrifying Presence", Rarity . COMMON, new CardType[]{CardType . INSTANT}, "{1}{G}" ) ; this . expansionSetCode = "AVR"; this . getSpellAbility (  )  . addEffect ( new TerrifyingPresenceEffect (  )  ) ; this . getSpellAbility (  )  . addTarget ( new TargetCreaturePermanent (  )  ) ; } public TerrifyingPresence ( final TerrifyingPresence card )  { super ( card ) ; } @Override public TerrifyingPresence copy (  )  { return new TerrifyingPresence ( this ) ; } } class TerrifyingPresenceEffect extends PreventionEffectImpl { public TerrifyingPresenceEffect (  )  { super ( Duration . EndOfTurn, Integer . MAX_VALUE, true ) ; this . staticText = "Prevent all combat damage that would be dealt by creatures other than target creature this turn"; } public TerrifyingPresenceEffect ( final TerrifyingPresenceEffect effect )  { super ( effect ) ; } @Override public TerrifyingPresenceEffect copy (  )  { return new TerrifyingPresenceEffect ( this ) ; } @Override public boolean applies ( GameEvent event, Ability source, Game game )  { return super . applies ( event, source, game )  && !event . getSourceId (  )  . equals ( getTargetPointer (  )  . getFirst ( game, source )  ) ; } } 